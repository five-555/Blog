<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>15445_study_notes_01_04</title>
    <url>/2024/02/10/15445-study-notes-01-04/</url>
    <content><![CDATA[<h2 id="01-Relational-Model-amp-Relational-Algebra"><a href="#01-Relational-Model-amp-Relational-Algebra" class="headerlink" title="01-Relational Model &amp; Relational Algebra"></a>01-Relational Model &amp; Relational Algebra</h2><h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p>数据库管理系统：允许应用在数据库中存储、操作、分析数据信息的一种软件。通常的数据库管理系统（DBMS）支持通过一些数据模型（data model）定义、创建、查询、更新以及数据库的管理工作</p>
<p>数据模型（data model）： 将存储的概念的高级抽象在数据库中，是数据库中描述数据的一种概念集合，能够表明数据的形状、属性等。</p>
<ul>
<li>关系型数据模型：关系型数据库</li>
<li>非关系型模型Nosql：key/value、Graph、Document/Object</li>
<li>矩阵/向量/列表</li>
<li>分层、网络</li>
</ul>
<p>模式（schema）：是一个逻辑概念，用于组织数据库中的对象。模式中的对象通常包括表、索引、数据类型、序列、视图、存储过程、主键、外键等。</p>
<h3 id="关系型模型（Relational-Model）"><a href="#关系型模型（Relational-Model）" class="headerlink" title="关系型模型（Relational Model）"></a>关系型模型（Relational Model）</h3><p>定义了一个数据库抽象层，用于如何替换表示关系以避免数据库维护的开销。</p>
<ul>
<li>三大原则<ul>
<li>存储数据库的简单数据结构</li>
<li>数据库的存储由数据库管理系统来实现，无需用户定义数据的存储形式，例如tree等</li>
<li>允许数据使用高级语言，数据库管理系统产生最优的执行策略</li>
</ul>
</li>
</ul>
<p>关系（table、relation）：包含代表实体属性关系的一种无序集合</p>
<p>元组（tuple）：关系中的属性值表现的集合，值也叫做域（domain）</p>
<p>主键（primary key）：识别唯一元组的方法，是一组关键的属性</p>
<p>外键（foreign key）：允许定义一个关系中的数据如何与另一个关系相关，外键作为一个映射表（交叉引用表）</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>SELECT</p>
<p>从一个关系中通过某些过滤信息选择出元组的子集，条件通常写在where 后面</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240102163927925.png" class="" title="image-20240102163927925">
</li>
<li><p>PROJECTION（投影）</p>
<p>使用数据库中的元组重新生成一个关系，只包含某一些特殊的属性。</p>
<p>把原来的表映射成一个新的表</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240102201317281.png" class="" title="image-20240102201317281">
</li>
<li><p>UNION（联合关系）</p>
<p>UNION ALL：不去重</p>
<p>UNION：去重</p>
<p>联合不同的数据库，但是数据库具有完全相同的属性。</p>
<p>默认情况下并集允许重复性</p>
</li>
<li><p>INTERSECT（交集关系）</p>
<p>两个数据库关系的交集，相同的元组集合</p>
</li>
<li><p>DIFFERENCE（取补集）</p>
<p>语法：EXCEPT</p>
</li>
<li><p>PRODUCT（笛卡尔积）</p>
<p>语法CROSS JOIN</p>
</li>
<li><p>JOIN</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240103093506806.png" class="" title="image-20240103093506806">
</li>
</ul>
<h2 id="02-Modern-SQL"><a href="#02-Modern-SQL" class="headerlink" title="02-Modern SQL"></a>02-Modern SQL</h2><h3 id="AGGREGATES"><a href="#AGGREGATES" class="headerlink" title="AGGREGATES"></a>AGGREGATES</h3><blockquote>
<p>聚合（aggregations）：类似一个在查询中获取一组元组的函数</p>
<p>AVG、MIN、MAX、SUM、COUNT</p>
</blockquote>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240104092359606.png" class="" title="image-20240104092359606">
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(<br>	sid <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>	<span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>	<span class="hljs-keyword">login</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>	age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>	gpa <span class="hljs-type">FLOAT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (sid, <span class="hljs-type">name</span>, <span class="hljs-keyword">login</span>, age, gpa) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">53666</span>, &quot;Kanye&quot;, &quot;kanye@cs&quot;, <span class="hljs-number">44</span>, <span class="hljs-number">4.0</span>),<br>(<span class="hljs-number">53688</span>, &quot;Bieber&quot;, &quot;jbieber@cs&quot;, <span class="hljs-number">27</span>, <span class="hljs-number">3.9</span>),<br>(<span class="hljs-number">53655</span>, &quot;Tupac&quot;, &quot;shakur@cs&quot;, <span class="hljs-number">25</span>, <span class="hljs-number">3.5</span>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> enrolled(<br>	sid <br>)<br></code></pre></td></tr></table></figure>
<ul>
<li>获取到student表中的注册统计数</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> COUNT(<span class="hljs-keyword">login</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br>// 大多数数据库都对count（*）有优化<br><span class="hljs-keyword">SELECT</span> COUNT(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> COUNT(<span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>多聚合，多个属性的聚合</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> AVG(gpa), COUNT(sid) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>DISTINCT</p>
<p>COUNT、SUM、AVG支持DISTINCT，表示只会统计不同的元素，去重</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> COUNTA(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">login</span>) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>GROUP BY</p>
<p>按照group by后面的元组进行select操作</p>
</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">// 按照cid的分组来计算gpa的平均值，并聚合cid和平均值两列元素<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(s.gpa), <span class="hljs-built_in">e</span>.cid<br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> <span class="hljs-built_in">e</span>, student <span class="hljs-keyword">AS</span> s<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.sid = s.sid<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">e</span>.cid;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>HAVING</p>
<p>在完成group by以后还需要再进行一些筛选，可以使用having</p>
</li>
</ul>
<h3 id="STRING-OPERATIONS（字符串操作）"><a href="#STRING-OPERATIONS（字符串操作）" class="headerlink" title="STRING OPERATIONS（字符串操作）"></a>STRING OPERATIONS（字符串操作）</h3><ul>
<li><p>模糊查询</p>
<blockquote>
<p>数据库中没有搜索引擎，少用右模糊查询或者全模糊查询，百分号尽量不放在前面，在索引过程当中遵循最左匹配原则</p>
</blockquote>
<p>%：代表一个或多个字符</p>
<p>_：代表单个字符</p>
</li>
<li><p>SUBSTRING</p>
<p>字符串切片操作</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">// 对<span class="hljs-type">name</span>这一列中的字符串进行切片操作<br><span class="hljs-keyword">SELECT</span> SUBSTRING(<span class="hljs-type">name</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>) <span class="hljs-keyword">AS</span> abbrv_name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> sid = <span class="hljs-number">53688</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>UPPER：大写</p>
</li>
<li><p>LOWER：小写</p>
</li>
<li><p>CONCAT</p>
<p>连接操作，将字符串拼接起来</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> = CONCAT(LOWER(<span class="hljs-type">name</span>), <span class="hljs-string">&#x27;@cs&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="OUTPUT-REDIRECTION（输出重定向）"><a href="#OUTPUT-REDIRECTION（输出重定向）" class="headerlink" title="OUTPUT REDIRECTION（输出重定向）"></a>OUTPUT REDIRECTION（输出重定向）</h3><p>将一个查询的结果集建成一个新的表，要求重定向的表是没有被定义的表，同时</p>
<ul>
<li>CREATE TABLE</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 使用查询建一张表格<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> CourseIds(<br>	<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> cid <span class="hljs-keyword">FROM</span> enrolled<br>);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>ORDER BY <cloumn*> [ASC|DESC]</p>
<p>按照某一列或者多列进行增序或者降序</p>
</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"># <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>: 根据第一列进行排序<br><span class="hljs-keyword">SELECT</span> sid, grade <span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">WHERE</span> cid = <span class="hljs-string">&#x27;15-721&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade<br></code></pre></td></tr></table></figure>
<ul>
<li><p>LIMIT &lt; count &gt; [offset]</p>
<p>输出count行，从第offset个开始</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 从满足条件的第<span class="hljs-number">10</span>个开始查找<span class="hljs-number">20</span>个学生<br><span class="hljs-keyword">SELECT</span> sid, <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span><br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">20</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<h3 id="NESTED-QUERIES（嵌套查询）"><a href="#NESTED-QUERIES（嵌套查询）" class="headerlink" title="NESTED QUERIES（嵌套查询）"></a>NESTED QUERIES（嵌套查询）</h3><p>将一个查询或多个查询嵌入到另一个查询当中</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240104193223551.png" class="" title="image-20240104193223551">
<p>对子嵌套的关系进行操作</p>
<ul>
<li>ALL：所有的行必须满足子查询中的表达式</li>
<li>ANY：至少一行必须在子查询中匹配</li>
<li>IN：等价于=ANY</li>
<li>EXISTS：只要内部查询产生一个输出记录就返回</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> sid = <span class="hljs-keyword">ANY</span>(<br><span class="hljs-keyword">SELECT</span> sid <span class="hljs-keyword">FROM</span> enrolled<br><span class="hljs-keyword">WHERE</span> cid = <span class="hljs-string">&#x27;15-445&#x27;</span><br>);<br></code></pre></td></tr></table></figure>
<h3 id="WINDOW-FUNCTIONS（窗口函数）"><a href="#WINDOW-FUNCTIONS（窗口函数）" class="headerlink" title="WINDOW FUNCTIONS（窗口函数）"></a>WINDOW FUNCTIONS（窗口函数）</h3><p>类似于聚合，但不仅仅是将元组折叠成单个聚合，而是以一种增量的方式计算聚合</p>
<ul>
<li><p>SELECT … FUNC-NAME(…) OVER(…) FROM table</p>
<p>使用窗口函数FUNC-NAME，按照OVER的方式对查询的col进行聚合</p>
</li>
<li><p>窗口函数种类</p>
<ul>
<li>ROW_NUMBER() ：每一行的行号</li>
<li>RANK() ：位置</li>
<li>二者的区别在于，rank可以并列，但是row_number是唯一的</li>
</ul>
</li>
<li><p>PARTITION BY  cid：按照cid分组，可以写在over中的条件里面</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 先将enrolled表按照cid分组，并按照grade排序<br># 再找出每一门课当中的第二名，ranking中第<span class="hljs-number">2</span>高成绩的数据<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> (<br><span class="hljs-keyword">SELECT</span> *, RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cid<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">ASC</span>) <span class="hljs-keyword">AS</span> rank<br><span class="hljs-keyword">FROM</span> enrolled) <span class="hljs-keyword">AS</span> ranking<br><span class="hljs-keyword">WHERE</span> ranking.rank = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>CTE（COMMON TABLE EXPRESSIONS）</p>
<p>通用表达式：只在sql语句内部起作用的临时语句</p>
<p>RECURSIVE：递归调用，不是所有的sql都能够使用递归</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">WITH</span> cteName (col1, col2) <span class="hljs-keyword">AS</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>)<br><span class="hljs-keyword">SELECT</span> col1 + col2 <span class="hljs-keyword">FROM</span> cteName<br><br><span class="hljs-keyword">WITH</span> cteSource (maxId) <span class="hljs-keyword">AS</span> (<br><span class="hljs-keyword">SELECT</span> MAX(sid) <span class="hljs-keyword">FROM</span> enrolled<br>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student, cteSource<br><span class="hljs-keyword">WHERE</span> student.sid = cteSource.maxId<br><br># CTE递归的调用，很少用，可读性差<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> cteSource (counter) <span class="hljs-keyword">AS</span> (<br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>)<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br>(<span class="hljs-keyword">SELECT</span> counter + <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> cteSource<br><span class="hljs-keyword">WHERE</span> counter &lt; <span class="hljs-number">10</span>)<br>)<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> cteSource<br></code></pre></td></tr></table></figure>
<ul>
<li>CTE可以递归调用自身</li>
</ul>
<h2 id="03-Database-Storage-1"><a href="#03-Database-Storage-1" class="headerlink" title="03-Database Storage 1"></a>03-Database Storage 1</h2><h3 id="基于磁盘的架构"><a href="#基于磁盘的架构" class="headerlink" title="基于磁盘的架构"></a>基于磁盘的架构</h3><blockquote>
<p> 数据库管理系统（DBMS）假设数据库的主要存储位置位于非易失性磁盘上。DBMS 的各个组件负责管理在非易失性存储和易失性存储之间的数据移动。</p>
</blockquote>
<ul>
<li><p>数据库系统的设计目标</p>
<blockquote>
<p>数据库系统做的操作有点类似于虚拟内存，如下图</p>
</blockquote>
<p>1、系统可以管理超过内存可使用的总内存的数据</p>
<p>2、由于读写内存十分昂贵，需要尽可能避免数据大量的读写内存造成的性能损耗</p>
<p>3、尽可能使用顺序存储的方式提高效率</p>
</li>
<li><p>为什么不适用操作系统？操作系统的虚拟内存可以进行相关操作</p>
<blockquote>
<p>数据库管理系统使用内存映射存储文件的内容到程序的地址空间</p>
<p>操作系统负责文件页面的命中与否，数据库管理系统不需要考虑</p>
</blockquote>
</li>
</ul>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240105160547664.png" class="" title="image-20240105160547664">
<ul>
<li><p>内存映射会遇到的问题（MEMORY MAPPED I/O PROBLEMS）</p>
<ul>
<li><p>事务安全Transaction Safety</p>
</li>
<li><p>I/O阻塞</p>
<p>数据库系统不知道内存中有哪些页面，所以在取数据如果发生错误，操作系统会阻塞线程</p>
</li>
<li><p>错误处理</p>
</li>
<li><p>性能问题</p>
</li>
</ul>
</li>
</ul>
<p>结论：数据库管理系统不使用MMAP内存映射</p>
<ul>
<li><p>数据库进行管理</p>
<p>问题1、数据库系统如何表示磁盘上的文件数据</p>
<p>问题2、如何管理内存以从磁盘中来回移动这些页面的数据，数据的读入与写回</p>
</li>
</ul>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><blockquote>
<p>数据库系统会使用数据库独有的文件格式在磁盘上存储一个或者多个文件</p>
<p>操作系统并无法知晓文件的内容</p>
</blockquote>
<ul>
<li><p>存储管理器</p>
<p>用于维护数据库文件，进行页面调度提升性能，利用局部性原则，组织一系列的页面文件读写</p>
</li>
<li><p>数据页面</p>
<blockquote>
<p>页面被锁定为固定大小的数据块，可以包含任何内容，不可以包含混合的数据</p>
</blockquote>
<p>硬件页面：存储设备可以保证它原子写出的最小数据或数据块大小，默认大小4KB</p>
<p>操作系统页面：通常4KB</p>
<p>数据库页面：512B-16KB</p>
<ul>
<li>硬件页面是存储设备能够保证正确写入的最大块大小</li>
<li>使用更大的页面可以减少IO，运用到局部性原理，但是不能够确保更大的页面读写是原子的，需要使用一些操作来确保数据不会丢失</li>
</ul>
</li>
<li><p>堆文件heap file</p>
<p>按照随机顺序存储的无序页面的集合</p>
<p>包含有获取、创建、写入、删除页面，以及迭代功能</p>
<p>数据库管理系统维护一张特殊的表格用于定位数据库文件中的页面，也可以称为目录</p>
</li>
</ul>
<h3 id="页面Page"><a href="#页面Page" class="headerlink" title="页面Page"></a>页面Page</h3><ul>
<li><p>页面标头</p>
<p>页面大小</p>
<p>校验和：检查是否有数据损坏</p>
<p>数据库管理系统版本：升级系统会更新</p>
<p>事务可见性：用于进行权限管理</p>
<p>压缩信息、备份</p>
</li>
<li><p>内部组织形式</p>
<ul>
<li><p>面向元组tuple的存储方式</p>
<ul>
<li>方式1</li>
</ul>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240110074224104.png" class="" title="image-20240110074224104">
<p>删除其中一个tuple需要进行线性的移动</p>
<p>无法对可变长度的属性进行存储</p>
<ul>
<li>方式二、开槽页面slot</li>
</ul>
<p>在页面开头存入槽数组，将元组映射到页面的实际位置</p>
<p>槽页面是从尾端按照顺序存储</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240110074349028.png" class="" title="image-20240110074349028">
</li>
</ul>
</li>
<li><p>Record IDS</p>
<blockquote>
<p>每一个元组都有一个唯一的记录ID号</p>
</blockquote>
<p>大部分格式为：页面ID+偏移量，可以使用ctid来获取（数据库中不能有列名为ctid的列） </p>
<ul>
<li>每个元组都有元数据，元组头部：可见性信息（元组是否删除）、使用位图表示元组中的空值</li>
</ul>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#在数据库中可以对碎片整理，会填补前面因为元组删除而空余的slot<br><span class="hljs-keyword">VACUUM</span> <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">table</span>;<br></code></pre></td></tr></table></figure>
<h2 id="04-Database-Storage-2"><a href="#04-Database-Storage-2" class="headerlink" title="04-Database Storage 2"></a>04-Database Storage 2</h2><h3 id="基于日志的架构"><a href="#基于日志的架构" class="headerlink" title="基于日志的架构"></a>基于日志的架构</h3><blockquote>
<p>数据库管理系统存包含改变元组的日志记录（PUT、DELETE）</p>
<p>每一条日志记录包含元组独特的ID</p>
<p>PUT：包含元组修改后的内容</p>
<p>DELETE：将元组标记为删除</p>
</blockquote>
<p>数据库管理系统在内存页面中存储对元组操作的一些记录，例如修改某一个元组，删除某一个元组，当页面存满以后，记录会被永久保存，并切换到下一个页面，这样的好处可以磁盘IO更少，便于写入</p>
<p>读入的时候，会需要向前不断追溯到最新的记录，读入很慢，在数据库管理系统中会维护一张index的表，映射到元组id的最新记录</p>
<ul>
<li><p>日志压缩</p>
<p>因为日志是随着数据库的操作而进行持续增长的，数据库管理系统会定期的压缩页面以减少空间浪费</p>
<p>通过将多个页面合并（找到记录的最新版本），移除掉不必要的记录</p>
<ul>
<li><p>通用压缩（Universal Compation）</p>
<p>查看两个连续的排序文件，将其组合在一起，随后删除旧的文件</p>
</li>
<li><p>层级压缩（Level Compation）</p>
<p>类似于2048，层级较低的过多以后，整合压缩成更大的高层文件</p>
</li>
</ul>
</li>
<li><p>基于日志的架构有什么缺点</p>
<ul>
<li><p>对写功能的放大</p>
<p>如果需要更新某一个元组，会在查询的过程中压缩，会和压缩过后的页面一起写回，写就被放大了</p>
</li>
<li><p>压缩代价较大</p>
</li>
</ul>
</li>
</ul>
<h3 id="元组的存储"><a href="#元组的存储" class="headerlink" title="元组的存储"></a>元组的存储</h3><p>4类基本数据类型：整型，浮点（FLOAT/REAL，NUMERIC/DECIMAL），varchar，time</p>
<ul>
<li>高精度的数据<ul>
<li>Postgres，最终结果使用字符串的别名来表示，需要实现不同数据的拼接，很影响性能</li>
</ul>
</li>
</ul>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240112101151040.png" class="" title="image-20240112101151040">
<ul>
<li><p>大数据：例如大小超过一个页面的数据</p>
<p>使用其它的页面存储这些更大的页</p>
</li>
</ul>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240112102928169.png" class="" title="image-20240112102928169">
<ul>
<li><p>外部资源数据</p>
<p>一些数据库系统允许存储外部文件的数据，对于这些外部文件，数据库系统无法做到持续性保护以及业务的保护，无法保证外部文件不被修改</p>
</li>
<li><p>系统目录</p>
<p>数据库系统维护数据库的一些表格</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>CMU15445</tag>
      </tags>
  </entry>
  <entry>
    <title>C++使用zlib库来压缩文件</title>
    <url>/2024/01/26/C-%E4%BD%BF%E7%94%A8zlib%E5%BA%93%E6%9D%A5%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="C-使用zlib库来压缩文件"><a href="#C-使用zlib库来压缩文件" class="headerlink" title="C++使用zlib库来压缩文件"></a>C++使用zlib库来压缩文件</h2><p>zlib压缩库提供内存压缩和解压缩功能，包括对未压缩的完整性检查数据，提供支持的压缩方法为：deflation，默认使用压缩数据格式为zlib格式。</p>
<p>zlib库支持读取和写入gzip(.gz)格式的文件，zlib格式旨在紧凑且快速，可用于内存和通信渠道。gzip格式设计用于文件系统上的单文件压缩，比zlib具有更大的头部以维护目录信息，并且使用与zlib不同且更慢的检查方法。</p>
<p>该库不安装任何信号处理程序。解码器检查压缩数据的一致性，因此即使在输入损坏的情况下，库也不应崩溃。</p>
<h3 id="数据流结构"><a href="#数据流结构" class="headerlink" title="数据流结构"></a>数据流结构</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span>pf (*alloc_func)(<span class="hljs-built_in">void</span>pf opaque, uInt items, uInt size);<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span>   (*free_func)(<span class="hljs-built_in">void</span>pf opaque, <span class="hljs-built_in">void</span>pf address);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);</code>这个函数指针通常用于内存分配，允许用户自定义的内存分配函数</li>
<li><code>typedef void   (*free_func)(voidpf opaque, voidpf address);</code>这个函数指针通常用于内存释放，允许用户自定义的内存释放函数</li>
</ul>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">ZEXTERN <span class="hljs-type">int</span> ZEXPORT <span class="hljs-title">deflateInit</span><span class="hljs-params">(z_streamp strm, <span class="hljs-type">int</span> level)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>level</code>表示压缩级别，要么为<code>Z_DEFAULT_COMPRESSION</code>，要么介于0-9之间，1表示最佳速度，9表示最佳压缩，0表示没有压缩，<code>Z_DEFAULT_COMPRESSION</code>默认在6级别。</li>
<li><code>deflateInit</code> 返回 <code>Z_OK</code> 如果成功，则返回 <code>Z_MEM_ERROR</code> 如果没有 足够的内存，<code>Z_STREAM_ERROR</code> <code>level</code> 不是有效的压缩级别，<code>Z_VERSION_ERROR</code> <em>zlib</em> 库版本 （<code>zlib_version</code>） 不兼容 替换为调用方 （<code>ZLIB_VERSION</code>） 假定的版本。如果没有错误消息，<code>则 msg</code> 设置为 null。<code>deflateInit</code> 不 执行任何压缩：这将由 <code>deflate（）</code> 完成。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">ZEXTERN <span class="hljs-type">int</span> ZEXPORT <span class="hljs-title">deflate</span><span class="hljs-params">(z_streamp strm, <span class="hljs-type">int</span> flush)</span></span>;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>zlib</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101现代计算机图形学入门-01</title>
    <url>/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/</url>
    <content><![CDATA[<h2 id="计算机图形学01"><a href="#计算机图形学01" class="headerlink" title="计算机图形学01"></a>计算机图形学01</h2><blockquote>
<p>应用场景：电影，动画，可视化，家具，模拟，虚拟现实（VR），GUI（图形用户接口），字体</p>
</blockquote>
<ul>
<li>好的画面：足够亮（全局光照）</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>、光栅化	Resterization<br><span class="hljs-number">2</span>、曲线曲面（几何）	Curves <span class="hljs-keyword">and</span> Meshes<br><span class="hljs-number">3</span>、光线追踪	Ray	Tracing<br><span class="hljs-number">4</span>、动画/模拟	Animation/Simulation<br></code></pre></td></tr></table></figure>
<h3 id="计算机图形学-VS-计算机视觉"><a href="#计算机图形学-VS-计算机视觉" class="headerlink" title="计算机图形学 VS 计算机视觉"></a>计算机图形学 VS 计算机视觉</h3><img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104113151777-17084112899531.png" class="" title="image-20231104113151777">
<ul>
<li><p>MODEL，计算机画（图形学）</p>
<p>正向箭头：将三维空间的图形在二维中展示出来，特指图像渲染</p>
<p>自我箭头：MODEL的自我渲染，与图像无关</p>
</li>
<li><p>IMAGE，计算机看（计算机视觉）</p>
<p>反向箭头：从图形中推导和识别出图像的特征</p>
<p>自我箭头：依赖深度学习对图像进行处理</p>
</li>
</ul>
<p>作业相关</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、作业链接：http:<span class="hljs-regexp">//g</span>ames-cn.org<span class="hljs-regexp">/forums/</span>topic<span class="hljs-regexp">/allhw/</span><br><span class="hljs-number">2</span>、作业使用的系统：smartchair<br><span class="hljs-number">3</span>、Use IDE：集成开发环境<br></code></pre></td></tr></table></figure>
<h3 id="线性代数——A-Swift-and-Brutal-Introduction-to-Linear-Algebra"><a href="#线性代数——A-Swift-and-Brutal-Introduction-to-Linear-Algebra" class="headerlink" title="线性代数——A Swift and Brutal Introduction to Linear Algebra"></a>线性代数——A Swift and Brutal Introduction to Linear Algebra</h3><blockquote>
<p>数学：线性代数，微积分，统计，物理：光学，力学，信号处理，数值分析</p>
</blockquote>
<h4 id="向量Vectors"><a href="#向量Vectors" class="headerlink" title="向量Vectors"></a>向量Vectors</h4><p>方向、长度、向量的模、单位向量、点乘、余弦值</p>
<ul>
<li><p>点乘的重要性</p>
<p>使用向量的点积便于计算一个向量在另一个向量上的投影（光的投影）</p>
<p>衡量两个向量的接近程度</p>
<p>分解一个向量（使用投影可以进行加减运算）分解为垂直方向和水平方向</p>
<p>确定向量的基本方向，大于零同方向，小于零反方向</p>
</li>
</ul>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104150955701-17084112899532.png" class="" title="image-20231104150955701">
<ul>
<li><p>叉乘的重要性（使用右手螺旋定则可以确定叉乘的方向）</p>
<p>叉乘可以建立一个三位空间的直角坐标系</p>
<p>任意的三维空间向量都可以分解到三位的单位向量中</p>
</li>
</ul>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104164704660-17084112899533.png" class="" title="image-20231104164704660">
<p>​        叉乘的代数表示（矩阵相乘）</p>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104164849274-17084112899534.png" class="" title="image-20231104164849274">
<p><strong>Q&amp;A:判断一个点是否在三角形的内部</strong></p>
<p>对三角形做逆时针，分别做三条边之间的向量，三个顶点分别于需要判断的点进行叉乘，如AB叉乘AP，如果都大于0，则说明在三角形内部。</p>
<p>结论比较简单，很容易在计算机中使用公式实现出来。</p>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104165645532-17084112899535.png" class="" title="image-20231104165645532">
<ul>
<li><p>矩阵的重要性</p>
<p>图像转换，旋转，平移，剪切，数乘</p>
<ul>
<li><p>矩阵的乘积（第一个矩阵的列数等于第二个矩阵的行数）</p>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231116154858801-17084112899536.png" class="" title="image-20231116154858801">
<p><strong>矩阵的乘积没有任何交换律</strong>，但是有结合律</p>
</li>
<li><p>矩阵与向量的乘积（列向量，可以表示为点的坐标）</p>
<p>可以利用矩阵乘积做一些变化操作（如下：将x，y变化为-x，y）</p>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231116155210293-17084112899537.png" class="" title="image-20231116155210293">
</li>
<li><p>转置矩阵、单位矩阵（对角矩阵）</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>GAMES101</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101现代计算机图形学入门-02</title>
    <url>/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/</url>
    <content><![CDATA[<h2 id="计算机图形学02"><a href="#计算机图形学02" class="headerlink" title="计算机图形学02"></a>计算机图形学02</h2><blockquote>
<p>Transform（变换），图形的变换</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">为什么学习变换<br>2维变换：旋转、缩放、切变<br>齐次坐标 Homogeneous coordinates<br>组合变换<br>3维变换<br></code></pre></td></tr></table></figure>
<h3 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h3><p>将矩阵和变换联系起来</p>
<ul>
<li><p>1、缩放</p>
<p>将坐标在向量左边乘一个对角矩阵</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161524873-17084118809551.png" class="" title="image-20231116161524873">
</li>
<li><p>2、反射对称</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161727694-17084118809562.png" class="" title="image-20231116161727694">
</li>
<li><p>3、切变（Shear Matrix）</p>
<p>水平方向坐标发生改变，竖直方向不变，水平的移动大小，按照Y的当前坐标成正比</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161842894-17084118809563.png" class="" title="image-20231116161842894">
</li>
<li><p>4、旋转</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116164956551-17084118809564.png" class="" title="image-20231116164956551">
<p>.PNG)</p>
</li>
</ul>
<p>通过矩阵乘积可以将一个输入图形的坐标转化为想要的输出矩阵的坐标，这样的变换都称为<strong>线性变换</strong></p>
<h3 id="齐次坐标（homogeneous-coordinates）"><a href="#齐次坐标（homogeneous-coordinates）" class="headerlink" title="齐次坐标（homogeneous coordinates）"></a>齐次坐标（homogeneous coordinates）</h3><blockquote>
<p>平移操作无法使用线性变化即矩阵的乘法来获得，所以引入齐次坐标，增加一个维度</p>
<p>齐次坐标的矩阵操作，可以叫做仿射变换</p>
</blockquote>
<p>增加维度以后，通过与新增加列的运算就可以达到平移的变换</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116165833300-17084118809565.png" class="" title="image-20231116165833300">
<ul>
<li><p>Q：Why？将二维的点，增加一个1，将二维的向量，增加一个0</p>
<p>1、通过增加的维度可以标识当前的坐标表示点还是表示向量。可以保证向量具有平移不变性</p>
<p>2、最后一个维度的运算正好表示运算结果的性质</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116170520355-17084118809566.png" class="" title="image-20231116170520355">
<p>3、点+点，得到的结果为两个点的终点，因为第三维为2，与两点之和相除便是中点</p>
</li>
</ul>
<p><strong>齐次坐标下的变换操作矩阵</strong></p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116171041924-17084118809567.png" class="" title="image-20231116171041924">
<ul>
<li><p>逆变换</p>
<p>乘以变化矩阵的逆矩阵，可以变换成原来的图片</p>
</li>
</ul>
<h3 id="变换组合"><a href="#变换组合" class="headerlink" title="变换组合"></a>变换组合</h3><p>1、复杂变换可以通过简单的变化来得到</p>
<p>2、变换的顺序不同，得到的结果不同</p>
<p>3、变换的组合，等价于原始矩阵依次乘上按照一定顺序的齐次矩阵</p>
<ul>
<li>将一个变化还原，或者以任意一个点为中心进行变化，可以先移动到原点，再进行操作</li>
</ul>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116200444279-17084118809568.png" class="" title="image-20231116200444279">
<h3 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h3><ul>
<li><p>三维点和三维向量</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116201112834-17084118809569.png" class="" title="image-20231116201112834">
</li>
<li><p>三维变换齐次矩阵</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116201139440-170841188095610.png" class="" title="image-20231116201139440">
</li>
<li><p>旋转</p>
<p>绕哪个轴旋转哪个轴保持不变</p>
<p>对于一般性的旋转，可以使用简单旋转的组合来完成</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231118142130480-170841188095611.png" class="" title="image-20231118142130480">
</li>
<li><p>使用旋转公式</p>
<p>旋转角度定义为a</p>
<p>旋转轴定义为n</p>
<p>其中<strong>I</strong>表示为单位矩阵</p>
<p>表示为，沿着旋转轴n旋转a的角度得到的旋转矩阵</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231118142833380-170841188095612.png" class="" title="image-20231118142833380">
</li>
</ul>
<h3 id="观测变换（Viewing-transformation）"><a href="#观测变换（Viewing-transformation）" class="headerlink" title="观测变换（Viewing transformation）"></a>观测变换（Viewing transformation）</h3><blockquote>
<p>视图变换、投影变换（正交投影，透视投影）</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>GAMES101</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库-MySQL</title>
    <url>/2024/02/10/database-mysql/</url>
    <content><![CDATA[<h2 id="数据库-Mysql"><a href="#数据库-Mysql" class="headerlink" title="数据库-Mysql"></a>数据库-Mysql</h2><blockquote>
<p>Mysql数据库的关键词：事务、存储引擎、索引、SQL优化、<strong>锁、日志、主从复制、读写分离、分库分表</strong></p>
</blockquote>
<img src="/2024/02/10/database-mysql/image-20240210160421874.png" class="" title="image-20240210160421874">
<h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="1、Mysql概述"><a href="#1、Mysql概述" class="headerlink" title="1、Mysql概述"></a>1、Mysql概述</h3><p>关系型数据库：建立在关系模型基础上，由多张互连接的二维表组成的数据库</p>
<p>特点：使用表存储数据，便于维护；使用sql语句操作，使用方便</p>
<p><strong>MySQL数据模型</strong></p>
<blockquote>
<p>1、客户端通过与数据库管理系统进行连接</p>
<p>2、使用sql语句通过数据库管理系统对指定的数据库进行增删改查</p>
<p>3、一个数据库模型中可以对多个数据库进行管理，一个数据库中可以拥有多个表</p>
</blockquote>
<p>// TODO数据库模型的图</p>
<h3 id="2、SQL"><a href="#2、SQL" class="headerlink" title="2、SQL"></a>2、SQL</h3><p><strong>SQL分类</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DDL</td>
<td>Data Definition Language</td>
<td>数据库定义语句，定义数据库对象，数据库，表，字段等</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据库操作语句，用于对数据库表中的数据进行增增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据库查询语句，查询数据库表中的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据库控制语句，创建数据库用户，控制数据库的访问权限</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p><strong>数据库层次</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询所有数据库表格<br>SHOW DATABASES;<br># 查询当前所在的数据库<br>SELECT DATABASE();<br># 创建数据库，方括号可以省略<br>CREATE DATABASE [IF NOT EXISTS] 数据库名 [COLLATE 排序规则]<br># 删除数据库<br>DROP DATABASE [IF EXISTS] 数据库名<br># 使用数据库，切换到数据库当中<br>USE 数据库名<br></code></pre></td></tr></table></figure>
<p>​        表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看所有表<br>SHOW TABLES;<br># 查询表结构<br>DESC 表名<br># 查询指定表的建表语句<br>SHOW CREATE TABLE 表名;<br></code></pre></td></tr></table></figure>
<p>​        MySQL中的数据类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>微小整数，有符号或无符号（UNSIGNED）</td>
<td>1 字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>小整数，有符号或无符号</td>
<td>2 字节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>中等整数，有符号或无符号</td>
<td>3 字节</td>
</tr>
<tr>
<td>INT 或 INTEGER</td>
<td>整数，有符号或无符号</td>
<td>4 字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数，有符号或无符号</td>
<td>8 字节</td>
</tr>
<tr>
<td>FLOAT(M,D)</td>
<td>单精度浮点数，M 是总位数，D 是小数位数</td>
<td>4 字节</td>
</tr>
<tr>
<td>DOUBLE(M,D)</td>
<td>双精度浮点数，M 是总位数，D 是小数位数</td>
<td>8 字节</td>
</tr>
<tr>
<td>DECIMAL(M,D)</td>
<td>定点数，M 是总位数，D 是小数位数</td>
<td>取决于 M 和 D</td>
</tr>
<tr>
<td>DATE</td>
<td>日期 YYYY-MM-DD</td>
<td>3 字节</td>
</tr>
<tr>
<td>TIME</td>
<td>时间 HH:MM:SS</td>
<td>3 字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期和时间</td>
<td>8 字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>时间戳</td>
<td>4 字节</td>
</tr>
<tr>
<td>CHAR(N)</td>
<td><strong>定长</strong>字符串，最大长度为 N</td>
<td>最大 255 字节</td>
</tr>
<tr>
<td>VARCHAR(N)</td>
<td><strong>变长</strong>字符串，最大长度为 N</td>
<td>最大 65,535 字节</td>
</tr>
<tr>
<td>TEXT</td>
<td>变长文本，最大长度为 65,535 字节</td>
<td>最大 65,535 字节</td>
</tr>
<tr>
<td>BLOB</td>
<td>二进制大对象，最大长度为 65,535 字节</td>
<td>最大 65,535 字节</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型</td>
<td>1 或 2 字节，取决于成员数量</td>
</tr>
<tr>
<td>SET</td>
<td>集合类型</td>
<td>1、2、3、4 或 8 字节，取决于成员数量</td>
</tr>
</tbody>
</table>
</div>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE member(<br>    number INT COMMENT &#x27;编号&#x27;,<br>    id CHAR(10) COMMENT &#x27;员工工号&#x27;,<br>    name VARCHAR(10) COMMENT &#x27;员工姓名&#x27;,<br>    gender CHAR(4) COMMENT &#x27;员工性别&#x27;,<br>    age INT UNSIGNED COMMENT &#x27;年龄&#x27;,<br>    id_number CHAR(18) COMMENT &#x27;身份证号&#x27;,<br>    time DATE COMMENT &#x27;入职时间&#x27;<br>)<br></code></pre></td></tr></table></figure>
<p><strong>表结构的修改</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 添加字段<br>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束];<br><br># 修改字段和字段类型<br>ALTER TABLE 表明 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束]<br><br># 删除字段<br>ALTER TABLE 表名 DROP 字段名;<br><br># 修改表名<br>ALTER TABLE 表名 RENAME TO 新表名;<br><br># 删除表<br>DROP TABLE [IF EXSITS] 表名;<br># 删除指定表并重新创建该表，清空数据<br>TRUNCATE TABLE 表名;<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h4></li>
</ul>
<p><strong>添加数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 给指定字段添加数据<br>INSERT INTO 表名(字段名1, 字段名2, ...) VALUES (值1, 值2, ...);<br><br># 给全部字段添加数据<br>INSERT INTO 表名 VALUES(值1, 值2, ...);<br></code></pre></td></tr></table></figure>
<p><strong>修改数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 修改数据<br>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ...[WHERE 条件];<br></code></pre></td></tr></table></figure>
<p><strong>删除数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 删除数据<br>DELETE FROM 表名 [WHERE 条件];<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><blockquote>
<p>数据库查询语言，用来查询数据库中的表的记录</p>
<p>SELECT后面加上\G可以将某一行转化为一列查看</p>
</blockquote>
</li>
</ul>
<p><strong>语法结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT<br>	字段列表<br>FROM<br>	表名列表<br>WHERE<br>	条件列表(条件查询)<br>GROUP BY<br>	分组字段列表(分组查询)<br>HAVING<br>	分组后条件列表<br>ORDER BY<br>	排序字段列表<br>LIMIT<br>	分页参数<br></code></pre></td></tr></table></figure>
<p><strong>基本查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段1 [AS 别名]，字段2 [AS 别名]， FROM 表名;<br><br># 去重<br>SELECT DISTINCT 字段列表 FROM 表名;<br></code></pre></td></tr></table></figure>
<p><strong>条件查询</strong></p>
<p>条件运算符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">比较运算符</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;&gt;或!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN … AND …</td>
<td style="text-align:center">在某个范围之内</td>
</tr>
<tr>
<td style="text-align:center">IN(…)</td>
<td style="text-align:center">在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td style="text-align:center">LIKE 占位符</td>
<td style="text-align:center">模糊匹配(_匹配单个字符，%匹配任意个字符)</td>
</tr>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">是NULL</td>
</tr>
</tbody>
</table>
</div>
<p><strong>聚和函数</strong></p>
<blockquote>
<p>将一列数据作为一个整体，进行纵向计算。</p>
</blockquote>
<p>所有的null值不参与聚合函数的计算</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:center">统计数量</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">最大值</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">最小值</td>
</tr>
<tr>
<td style="text-align:center">avg</td>
<td style="text-align:center">平均值</td>
</tr>
<tr>
<td style="text-align:center">sum</td>
<td style="text-align:center">求和</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 聚合函数(字段列表) FROM 表名;<br></code></pre></td></tr></table></figure>
<p><strong>分组查询</strong></p>
<blockquote>
<p>在where中不可以使用聚合函数，在having中可以使用聚合函数</p>
<p>分组之前过滤用where，分组之后过滤条件用having</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段列表	FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];<br></code></pre></td></tr></table></figure>
<p>执行顺序：where &gt; 聚合函数 &gt; having</p>
<p><strong>排序查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2<br></code></pre></td></tr></table></figure>
<p>排序方式： ASC升序（默认），DESC降序</p>
<p><strong>分页查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;<br></code></pre></td></tr></table></figure>
<p>显示从起始索引开始的记录数条的查询结果</p>
<p><strong>DQL执行顺序</strong></p>
<p>FROM &gt; WHERE &gt; GROUP BY &gt; SELECT &gt; ORDER BY &gt; LIMIT</p>
<ul>
<li><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4></li>
</ul>
<blockquote>
<p>数据控制语句，用来管理数据库用户，控制数据库访问权限</p>
</blockquote>
<p><strong>DCL用户管理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询用户<br>USE mysql;<br>SELECT * FROM user;<br><br># 创建用户，主机名换成&quot;%&quot;表示可以在任意主机访问数据库<br>CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;<br><br># 修改用户密码<br>ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;<br><br># 删除用户<br>DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></td></tr></table></figure>
<p><strong>权限控制</strong></p>
<p>常用权限</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALL, ALL PRIVILEGES</td>
<td style="text-align:center">所有权限</td>
</tr>
<tr>
<td style="text-align:center">SELECT</td>
<td style="text-align:center">查询数据</td>
</tr>
<tr>
<td style="text-align:center">INSERT</td>
<td style="text-align:center">插入数据</td>
</tr>
<tr>
<td style="text-align:center">UPDATE</td>
<td style="text-align:center">修改数据</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">删除数据</td>
</tr>
<tr>
<td style="text-align:center">ALTER</td>
<td style="text-align:center">修改表</td>
</tr>
<tr>
<td style="text-align:center">DROP</td>
<td style="text-align:center">删除数据库/表/视图</td>
</tr>
<tr>
<td style="text-align:center">CREATE</td>
<td style="text-align:center">创建数据库/表</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询权限<br>SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br># 授予权限<br>GRANT 权限列表 ON 数据库名.表名(*.*所有表) TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br># 撤销权限<br>REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></td></tr></table></figure>
<h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><ul>
<li><strong>字符串函数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONCAT(S1,S2, … Sn)</td>
<td style="text-align:center">字符串拼接，将S1-Sn拼接成一个字符串</td>
</tr>
<tr>
<td style="text-align:center">LOWER(str)</td>
<td style="text-align:center">将字符串str全部转为小写</td>
</tr>
<tr>
<td style="text-align:center">UPPER(str)</td>
<td style="text-align:center">将字符串全部转为大写</td>
</tr>
<tr>
<td style="text-align:center">LPAD(str, n, pad)</td>
<td style="text-align:center">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td style="text-align:center">RPAD(str, n,  pad)</td>
<td style="text-align:center">右填充</td>
</tr>
<tr>
<td style="text-align:center">TRIM(str)</td>
<td style="text-align:center">去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td style="text-align:center">SUBSTRING(str, start, len)</td>
<td style="text-align:center">返回从字符串str从start起的len长度的字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 函数;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>数值函数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CEIL(x)</td>
<td style="text-align:center">向上取整</td>
</tr>
<tr>
<td style="text-align:center">FLOOR(x)</td>
<td style="text-align:center">向下取整</td>
</tr>
<tr>
<td style="text-align:center">MOD(x, y)</td>
<td style="text-align:center">返回x/y的模</td>
</tr>
<tr>
<td style="text-align:center">RAND()</td>
<td style="text-align:center">返回0~1内的随机数</td>
</tr>
<tr>
<td style="text-align:center">ROUND(x, y)</td>
<td style="text-align:center">求参数x的四舍五入的值，保留y位小数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>日期函数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CURDATE()</td>
<td style="text-align:center">返回当前日期</td>
</tr>
<tr>
<td style="text-align:center">CURTIME()</td>
<td style="text-align:center">返回当前时间</td>
</tr>
<tr>
<td style="text-align:center">NOW()</td>
<td style="text-align:center">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:center">YEAR(date)</td>
<td style="text-align:center">获取指定date的年份</td>
</tr>
<tr>
<td style="text-align:center">MONTH(date)</td>
<td style="text-align:center">获取指定date的月份</td>
</tr>
<tr>
<td style="text-align:center">DAY(date)</td>
<td style="text-align:center">获取指定date的日期</td>
</tr>
<tr>
<td style="text-align:center">DATE_ADD(date, INTERVAL expr type)</td>
<td style="text-align:center">返回上一个日期加上时间间隔expr以后的时间值，type(year,month,day)指定年月天</td>
</tr>
<tr>
<td style="text-align:center">DATEDIFF(date1, date2)</td>
<td style="text-align:center">返回起始时间date1和结束时间date2之间的天数，第一个时间减去第二个时间</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>流程函数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IF(value, t. f)</td>
<td style="text-align:center">如果value为true，返回t，否则返回f</td>
</tr>
<tr>
<td style="text-align:center">IFNULL(value1, value2)</td>
<td style="text-align:center">如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td style="text-align:center">CASE WHEN [val] THEN [res1] … ELSE [ default ] END</td>
<td style="text-align:center">如果val1为true，返回res1，…否则返回default默认值</td>
</tr>
<tr>
<td style="text-align:center">CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td style="text-align:center">如果expr的值等于val1，返回res1，…否则返回default默认值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4、约束"><a href="#4、约束" class="headerlink" title="4、约束"></a>4、约束</h3><p>作用于表中字段上的规则，用于限制存储在表中的数据</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">约束</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">非空约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">唯一约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">主键约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">默认约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">检查约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">外键约束</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="5、多表查询"><a href="#5、多表查询" class="headerlink" title="5、多表查询"></a>5、多表查询</h3><ul>
<li><p><strong>多表关系</strong></p>
<p>一对多：在多的一方建立外键，指向一的一方的主键</p>
</li>
</ul>
<p>​        多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方的主键</p>
<p>​        一对一：用于做单表拆分，基础字段放在一张表，详情字段放在另一张表。在任意一方加入外键，关联另一方的主键，并设置外键为唯一（UNIQUE）</p>
<ul>
<li><p><strong>多表查询</strong></p>
<ul>
<li><p>内连接</p>
<blockquote>
<p>相当于查询A、B交集部分数据</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 隐式内连接<br>SELECT 字段列表 FROM 表1，表2 WHERE 条件...;<br><br># 显示内连接<br>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>外连接</p>
<blockquote>
<p>左外连接：查询左表所有数据，以及两张表交集部分数据，将左表的数据和右表的部分数据连接起来</p>
<p>右外连接：查询右表所有数据，以及两张表交集部分数据</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 左外连接，表1所有数据以及和表2交集部分的数据<br>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;<br><br># 右外连接，表2所有数据以及和表1交集部分的数据<br>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>自连接</p>
<blockquote>
<p>自连接：当前表与自身的连接查询，自连接必须使用表别名</p>
</blockquote>
</li>
<li><p>联合查询-union，union all</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 把多次查询的结果合并起来，形成一个新的查询结果集<br># ALL去掉以后会对结果进行去重<br>SELECT 字段列表 表A<br>UNION [ALL]<br>SELECT 字段列表 表B;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>子查询</strong></p>
<ul>
<li><p>标量子查询，子查询返回一个标量</p>
</li>
<li><p>列子查询，子查询返回一列</p>
<p>| 操作符 |                 描述                 |<br>| :——: | :—————————————————: |<br>|   IN   |     在指定的集合范围之内，多选一     |<br>| NOT IN |          不在指定的范围之内          |<br>|  ANY   | 子查询返回列表中，有任意一个满足即可 |<br>|  SOME  |              与ANY等同               |<br>|  ALL   |   子查询返回列表的所有值都必须满足   |</p>
</li>
<li><p>行子查询，子查询返回的结果是一行</p>
<p>此时column1可以使用(column1， column2)聚合成多个参数</p>
<p>操作符：=、&lt;&gt;、IN、NOT IN</p>
</li>
<li><p>表子查询，子查询的返回结果是一个表，可以和行子查询加上列子查询的操作符使用，表可以放到from后面</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 对于子查询，可以将问题拆解成多个不同的查询步骤<br>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);<br></code></pre></td></tr></table></figure>
<h3 id="6、事务"><a href="#6、事务" class="headerlink" title="6、事务"></a>6、事务</h3><blockquote>
<p>一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么<strong>同时成功，要么同时失败</strong></p>
<p>默认Mysql的事务是自动提交的，当执行一条DML语句，Mysql会立即隐式的提交事务</p>
</blockquote>
<ul>
<li><strong>事务操作</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看/设置事务提交方式<br>SELECT @@autocommit;<br># 事务设置为手动提交<br>SET @@autocommit = 0;<br><br># 提交事务<br>COMMIT;<br><br># 回滚事务<br>ROLLBACK;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 不修改事务的提交方式操作事务<br># 开启事务<br>START TRANSACTION 或 BEGIN;<br><br># 提交事务<br>COMMIT;<br><br># 回滚事务<br>ROLLBACK;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><strong>事务四大特性</strong></p>
<ul>
<li>原子性(Atomicity)：事务时不可分割的最小操作单元，要么全部成功，要么全部失败</li>
<li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
<li>持久性(Durability)：事务一旦提交或者回滚，它对数据库中的数据改变就是永久的</li>
</ul>
</li>
<li><p><strong>并发事务问题</strong></p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">问题</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">脏读</td>
<td style="text-align:center">一个事务读到另一个事务还没有提交的数据</td>
</tr>
<tr>
<td style="text-align:center">不可重复读</td>
<td style="text-align:center">一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读</td>
</tr>
<tr>
<td style="text-align:center">幻读</td>
<td style="text-align:center">一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这一行数据已经存在</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>事务隔离级别</strong></p>
<blockquote>
<p>读未提交、读已提交、可重复读、串行化</p>
<p>√表示会出现这个问题，×表示不会出现这个问题</p>
</blockquote>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read uncommitted</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Read committed</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Repeatable Read</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Serializable</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看事务的隔离级别<br>SELECT @@TRANSACTION_ISOLATION;<br><br># 设置事务隔离级别<br>SET [SESSION(只对当前窗口有效)|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;<br></code></pre></td></tr></table></figure>
<p>  事务的隔离界别越高，数据越安全，但是性能越低</p>
<h2 id="数据库进阶"><a href="#数据库进阶" class="headerlink" title="数据库进阶"></a>数据库进阶</h2><h3 id="1、存储引擎"><a href="#1、存储引擎" class="headerlink" title="1、存储引擎"></a>1、存储引擎</h3><ul>
<li><p>Mysql体系结构 </p>
<p>连接层：完成一些类似于连接处理、授权认证及相关的安全方案</p>
<p>服务层：主要完成大多数的核心服务功能</p>
<p>引擎层：负责mysql中数据的存储和提取，服务器通过API和存储引擎进行通信</p>
<p>存储层：将数据存储在文件系统之上，并完成与存储引擎的交互</p>
<img src="/2024/02/10/database-mysql/Mysql.png" class="" title="Mysql">
</li>
<li><p>存储引擎</p>
<blockquote>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎时基于表的，而不是基于库的。一个数据库的不同的表可以选择不同的存储引擎</p>
<p>Mysql默认InnoDB</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询支持的存储引擎<br>show engines;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>InnoDB</p>
<ul>
<li>DML操作遵循ACID模型，支持事务</li>
<li>行级锁，提高并发访问性能</li>
<li>支持外键，保证事务的完整性和正确性</li>
</ul>
<p>文件：每个表对应一个.ibd文件，代表表空间文件，可以通过命令<code>idb2sdi 文件名</code>查看表结构json文件格式</p>
<img src="/2024/02/10/database-mysql/image-20240216162915509.png" class="" title="image-20240216162915509">
</li>
<li><p>MyISAM</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁、不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件.MYD（数据），.MYI（索引），.sdi（表结构）</p>
</li>
<li><p>Memory</p>
<ul>
<li>表数据存储在内存当中，收到硬件问题或断电影响只能作为临时表或者缓存使用</li>
<li>内存存放</li>
<li>hash索引（默认）</li>
</ul>
</li>
</ul>
<img src="/2024/02/10/database-mysql/image-20240216163439353.png" class="" title="image-20240216163439353">
<ul>
<li><p>存储引擎选择</p>
<p>InnoDB：如果对事务的完整性有比较高的要求，在并发情况下要求事务的一致性，数据操作除了插入和查询意外，还包括很多的更新、删除操作，InnoDB引擎比较合适</p>
<p>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性和并发现要求不是很高。<strong>这个场景被Nosql数据库MongoDB替代了</strong></p>
<p>MEMORY：将所有数据保存在内存当中，访问速度快，通常用于临时表以及缓存。MEMORY对表的大小有限制，太大的表无法缓存在内存中。<strong>这个场景被Redis替代了</strong></p>
</li>
</ul>
<h3 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h3><ul>
<li><p><strong>索引概述</strong></p>
<ul>
<li>索引的结构</li>
</ul>
</li>
<li><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a><strong>索引分类</strong></h4></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主键索引</td>
<td style="text-align:center">针对于表中主键创建的索引</td>
<td style="text-align:center">默认自动创建，只能有一个</td>
<td style="text-align:center">PRIMARY</td>
</tr>
<tr>
<td style="text-align:center">唯一索引</td>
<td style="text-align:center">避免同一个表中某数据列中的值重复</td>
<td style="text-align:center">可以有多个</td>
<td style="text-align:center">UNIQUE</td>
</tr>
<tr>
<td style="text-align:center">常规索引</td>
<td style="text-align:center">快速定位特定数据</td>
<td style="text-align:center">可以有多个</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">全文索引</td>
<td style="text-align:center">全文索引查找的是文本中通过的关键词</td>
<td style="text-align:center">可以有多个</td>
<td style="text-align:center">FULLTEXT</td>
</tr>
</tbody>
</table>
</div>
<p>按照索引的存储形式分类</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">聚集索引</td>
<td style="text-align:center">将数据存储与索引放到了一块</td>
<td style="text-align:center">必须有，而且只有一个</td>
</tr>
<tr>
<td style="text-align:center">二级索引</td>
<td style="text-align:center">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td style="text-align:center">可以存在多个</td>
</tr>
</tbody>
</table>
</div>
<img src="/2024/02/10/database-mysql/image-20240218203730285.png" class="" title="image-20240218203730285">
<ul>
<li><h4 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a><strong>索引语法</strong></h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 创建索引<br># 一个索引可以关联多行，如果关联多行称为联合索引<br>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name, )<br><br># 查看索引<br>SHOW INDEX FROM table_name;<br><br># 删除索引<br>DROP INDEX index_name ON table_name;<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a><strong>SQL性能分析</strong></h4><blockquote>
<p>使用于select的优化</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># SQL执行频率，查看当前数据库语句的访问频率<br>SHOW [session|global] STATUS<br># Com七个下划线，模糊匹配<br>SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;<br></code></pre></td></tr></table></figure>
<p><strong>SQL语句的频率</strong></p>
<img src="/2024/02/10/database-mysql/image-20240218204502697.png" class="" title="image-20240218204502697">
<p><strong>慢查询日志</strong></p>
<blockquote>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10)的所有SQL语句的日志</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看是否开启，日志文件默认在/var/lib/mysql里面<br>SHOW VARIABLES LIKE &#x27;slow_query_log&#x27;;<br><br># 修改/etc/my.cnf中配置开启，配置时间<br>slow_query_log=1   <br>long_query_time=2<br></code></pre></td></tr></table></figure>
<p><strong>profile详情</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看是否支持prifile<br>SELECT @@have_profiling;<br><br># 设置为开<br>SET profiling=1;<br><br># 查看profile<br>SHOW PROFILES;<br></code></pre></td></tr></table></figure>
<p>执行完SQL语句以后，通过以下指令查看执行耗时情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看每一条SQL耗时基本情况<br>SHOW PROFILES;<br><br># 查看指定query_id的SQL语句各个阶段的耗时情况<br>SHOW PROFILE FOR QUERY query_id;<br><br># 查看指定SQL语句的CPU使用情况<br>SHOW PROFILE CPU FOR QUERY query_id;<br></code></pre></td></tr></table></figure>
<p><strong>explain执行计划</strong></p>
<blockquote>
<p>EXPLAIN或者DESC命令获取Mysql如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL语句;<br></code></pre></td></tr></table></figure>
<img src="/2024/02/10/database-mysql/image-20240218211138993.png" class="" title="image-20240218211138993">
<p>表头的含义：</p>
<img src="/2024/02/10/database-mysql/image-20240218212814126.png" class="" title="image-20240218212814126">
<img src="/2024/02/10/database-mysql/image-20240218212115878.png" class="" title="image-20240218212115878">
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">type<br>const	以主键或以唯一的列作为索引扫描<br>ref		非唯一的值作为查询索引<br>index	用了索引，但是会对整个索引进行遍历<br>all		全表扫描<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a><strong>索引使用</strong></h4></li>
</ul>
<p><strong>联合索引</strong></p>
<p>使用要遵循<strong>最左前缀法则</strong>：查询<strong>从索引的最左列开始</strong>，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>
<p><strong>范围查询</strong>：联合索引中出现范围查询（&gt;,&lt;)，范围查询右侧的列索引失效。但是使用大于等于和小于等于索引并不会失效。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># student有联合索引(id,name,age)<br># 1、索引都可以使用<br>select * from student where id = 1 and name = &quot;Lili&quot; and age = 20;<br><br># 2、索引name，age失效<br>select * from student where id = 1 and age = 20;<br><br># 范围查询<br># name和age索引均失效<br>select * from student where id &gt; 1 and name = &quot;Lili&quot; and age = 20;<br></code></pre></td></tr></table></figure>
<p><strong>索引失效</strong></p>
<p>索引列操作：不要在索引上进行列操作，否则索引会失效</p>
<p>字符串类型：不加单引号索引会失效</p>
<p>模糊查询：<strong>头部进行模糊匹配(%%某某)</strong>，索引会失效，尾部进行模糊匹配（某某%%），索引不会失效。</p>
<p>or连接的条件：如果or前面的条件列有索引，后面的条件没有索引，所涉及的索引都不会引用到，只有两侧都有索引的时候，才有效</p>
<p>数据分布影响：如果索引比全表扫描更慢，则不使用索引，查询的数据大于一半，走全表不走索引。</p>
<p><strong>SQL提示</strong></p>
<blockquote>
<p>在sql语句中加入一些认为的提示来达到优化操作的目的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># use index指定使用哪个索引<br>explain select * from table use index(idxname) ...<br><br># ignore index<br># force index 同上<br></code></pre></td></tr></table></figure>
<p><strong>覆盖索引</strong></p>
<p>尽量使用覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到，减少使用select *</p>
<p>using index condition：查找使用了索引，但是需要回表查询数据</p>
<p>using where, using index：查询使用了索引，但是不需要回表</p>
<img src="/2024/02/10/database-mysql/image-20240218221642388.png" class="" title="image-20240218221642388">
<p>前两条不需要回表，后一条需要回表</p>
<p><strong>前缀索引</strong></p>
<blockquote>
<p>将字符串的前缀提取出来，创建索引，可以节约索引空间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># n表示取column_name列的前n个数据<br>CREATE INDEX idx_XXX ON table_name(column_name(n));<br><br># 计算前缀长度的选择性，越接近1越好<br>SELECT COUNT(DISTINCT substring(email, 1, 5)) / COUNT(*) FROM table_name;<br></code></pre></td></tr></table></figure>
<p><strong>单列索引和联合索引选择</strong></p>
<p>如果涉及到多个查询条件，推荐使用联合索引，联合索引会更少的回表查询</p>
<h4 id="Quetion"><a href="#Quetion" class="headerlink" title="Quetion"></a>Quetion</h4><img src="/2024/02/10/database-mysql/image-20240218221919863.png" class="" title="image-20240218221919863">
<p>建立id主键，username，password联合索引</p>
<ul>
<li><h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a><strong>索引设计原则</strong></h4></li>
</ul>
<img src="/2024/02/10/database-mysql/image-20240218224016746.png" class="" title="image-20240218224016746">
<h3 id="3、SQL优化"><a href="#3、SQL优化" class="headerlink" title="3、SQL优化"></a>3、SQL优化</h3><ul>
<li><h4 id="插入数据insert优化"><a href="#插入数据insert优化" class="headerlink" title="插入数据insert优化"></a><strong>插入数据</strong>insert优化</h4><p>批量插入而不是单条插入：批量插入只需要建立一次连接即可</p>
<p>建议手动提交事务：不需要每一次插入时自动开启和关闭事务，而是将所有insert执行结束以后统一关闭</p>
<p><strong>建议主键顺序插入</strong></p>
<p>大批量插入数据：使用Mysql数据库提供的load指令进行插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 如何使用load<br># 1、连接服务器时加上参数--local-infile<br>mysql --local-infile -u root -p<br><br># 2、设置全局参数local_infile为1<br>set global local_infile = 1;<br><br># 3、执行load指令将数据加载表结构中<br>load data local infile &#x27;文件名&#x27; into table &#x27;表名&#x27; fields teminated by &#x27;分割符&#x27; lines terminated by &#x27;行分隔符\n&#x27;;<br></code></pre></td></tr></table></figure>
</li>
<li><h4 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a><strong>主键优化</strong></h4></li>
</ul>
<blockquote>
<p>InnoDB中表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表。</p>
</blockquote>
<p>页大小为16kb，每个页至少包含两行数据</p>
<p>主键乱序插入可能会出现页分裂现象，执行删除操作会出现页合并现象</p>
<p>主键设计原则：</p>
<p>​    满足业务需求的情况下，尽量降低主键的长度</p>
<p>​    插入时尽量按照主键顺序插入，选择自增主键</p>
<p>​    尽量不要使用无序的自然主键</p>
<p>​    业务操作，避免对主键的修改</p>
<ul>
<li><strong>order by优化</strong></li>
</ul>
<p>排序方式</p>
<p>Using filesort：先找到数据再进行排序</p>
<p>Using index：通过有序索引直接返回，不需要额外排序</p>
<p>默认会对索引进行升序排序</p>
<ul>
<li><strong>limit优化</strong></li>
</ul>
<p>对于数据量大的，优化思路为使用覆盖索引+子查询</p>
<ul>
<li><p>count</p>
<p>count(*)优于count(1)&gt;count(主键)&gt;count(字段)</p>
</li>
<li><h4 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a><strong>update优化</strong></h4></li>
</ul>
<p>对需要更新的字段尽可能建立索引，这样如果处于多个事务情况下，只会使用行锁，如果没有建立索引，行锁会升级为表锁，无法进行并行</p>
<h3 id="4、视图-存储过程-触发器"><a href="#4、视图-存储过程-触发器" class="headerlink" title="4、视图/存储过程/触发器"></a>4、视图/存储过程/触发器</h3><blockquote>
<p>Mysql数据库当中的存储对象</p>
</blockquote>
<ul>
<li><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4></li>
</ul>
<blockquote>
<p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
</blockquote>
<p>操作视图中的数据就和操作数据库表一样，可以将视图理解为一张不被存储的虚拟表。</p>
<p>视图当中的数据并不存在，如果往视图里面插入数据，数据将存在基表当中，如果不想给用户表的权限，可以给用户一个视图。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 创建视图<br>CREATE [OR REPLACE] VIEW 视图名称(列名列表) AS SELECT语句 [WITH CASCADED|LOCAL CHECk OPTION];<br><br># 查询视图<br># 查看创建视图语句<br>SHOW CREATE VIEW 视图名称;<br># 查看视图数据<br>SELECT * FROM 视图名称...;<br><br># 修改视图<br># 方式一、使用创建的语句，用REPLACE替换掉<br>CREATE[OR REPLACE]...<br># 方式二<br>ALTER VIEW 视图名称(列表名称) AS SELECT ...;<br><br># 删除视图<br>DROP VIEW IF EXISTS 视图名称<br></code></pre></td></tr></table></figure>
<p><strong>视图当中的检查选项</strong></p>
<p><strong>CASCADED（向下级联）</strong></p>
<p>当使用WITH CHECK OPTION子句创建视图时，Mysql会通过视图检查正在更改的每个行。进行校验，所插入的数据是否满足SELECT语句。</p>
<p>Mysql中还可以为视图再创建新的视图，新的视图如果有option选项会影响到之前的视图</p>
<p><strong>LOCAL（不向下级联，只是检查有option的条件）</strong></p>
<p><strong>视图的更新和作用</strong></p>
<p>要使视图可以更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下中任何一项，则该视图不可更新：</p>
<p>聚合函数、DISTINCT、GROUP BY、HAVING、UNION或者UNION ALL</p>
<p>作用：1、可以简化用户对数据的理解，简化用户操作。2、控制用户对表的查看权限。3、数据独立，屏蔽真实表结构。4、可以简化多表联查的操作。</p>
<ul>
<li><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4></li>
</ul>
<blockquote>
<p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输</p>
<p>思想上就是数据库SQL语言层面的代码封装与重用，下一次如果执行相同的业务直接调用存储过程</p>
</blockquote>
<p><strong>特点</strong>    好像跟函数有点像</p>
<p>封装、复用</p>
<p>可以接收参数，也可以返回数据</p>
<p>作用：减少网络交互，提升效率</p>
<blockquote>
<p>在命令行中，执行创建存储过程的sql时，需要通过关键字<code>delimiter</code>指定SQL语句的结束符</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 创建<br># 参数列表为IN/OUT/INOUT 参数名，分别表示参数输入，输出，输入和输出参数<br>CREATE PROCEDURE 存储过程名称([参数列表])<br>BEGIN<br>	--SQL语句，可以是多条<br>END;<br><br># 调用<br>CALL 名称([参数列表]);<br><br># 查看<br># 方法一，查看系统的数据库表，xxx为数据库名<br>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;XXX&#x27;;<br># 方法二，使用show查看创建过程<br>SHOW CREATE PROCEDURE 存储过程名称;<br><br># 删除<br>DROP PROCEDURE [IF EXISTS] 存储过程名称;<br><br># 定义结束符为$$<br>delimiter $$<br></code></pre></td></tr></table></figure>
<p><strong>系统变量</strong>（全局GLOBAL，会话SESSION）</p>
<p>重启以后系统参数会恢复为默认值</p>
<p>永久修改系统参数需要修改/etc/my.cnf中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看所有系统变量<br>SHOW [SESSION|GLOBAL] VARIABLES;<br>SHOW VARIABLES LIKE &#x27;..&#x27;;<br># 查看指定变量<br>SELECT @@[SESSION|GLOBAL].系统变量名<br><br># 设置系统变量，默认为SESSION级别<br>SET [SESSION|GLOBAL] 变量名=值;<br>SET @@[SESSION|GLOBAL].系统变量名 = 值;<br></code></pre></td></tr></table></figure>
<p><strong>用户自定义变量</strong></p>
<blockquote>
<p>作用域为当前连接</p>
<p>变量无需声明，如果拿到的是没有声明的变量，则会获得NULL</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 赋值，可以同时赋值多个变量，用逗号隔开<br>SET @var_name = expr;<br>SET @var_name := expr;<br><br># SELECT赋值<br>SELECT @var_name := expr;<br># 将sql查询的结果赋值给变量<br>SELECT 字段名 INTO @var_name FROM 表名;<br><br># 使用<br>SELECT @var_name;<br></code></pre></td></tr></table></figure>
<p><strong>局部变量</strong></p>
<blockquote>
<p>在局部生效，需要DECLARE声明，作用域在BEGIN…END块内</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 声明<br>DECLARE 变量名 变量类型(数据库数据的类型) [DEFAULT 默认值]<br><br># 赋值<br>SET 变量名 = 值;<br>SET 变量名 := 值;<br>SELECT 字段名 INTO @var_name FROM 表名;<br></code></pre></td></tr></table></figure>
<p><strong>存储过程相关语法</strong></p>
<blockquote>
<p>逻辑语言都在存储过程中定义，可以使用传入的参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># IF 条件判断<br>IF 条件1 THEN<br>	...<br>ELSEIF 条件2 THEN<br>	...<br>ELSE<br>	...<br>END IF;<br><br># CASE 条件选择，WHEN后面可以有多种选择<br># 语法一<br>CASE case_value<br>	WHEN when_value1 THEN ...<br>	WHEN when_value2 THEN ...<br>	ELSE ...<br>END CASE;<br># 语法二<br>CASE <br>	WHEN 表达式真 THEN ...<br>	ELSE ...<br>END CASE;<br><br># WHILE循环<br>WHILE 条件 DO<br>	SQL逻辑<br>END WHILE：<br><br># REPEAT循环，当满足条件时，退出循环<br>REPEAT<br>	SQL逻辑...<br>	UNTIL 条件<br>END REPEAT;<br><br># LOOP循环<br># LOOP实现的是简单循环<br># LEAVE：配合循环使用，退出循环，作用类似于break<br># ITERATE：必须在循环中使用，作用类似于CONTINUE<br>[begin_label:] LOOP<br>	SQL逻辑<br>	<br>END LOOP[end_label]<br><br># 退出循环<br>LEAVE label;<br># 跳过本次进入下一次循环<br>ITERATE label;<br></code></pre></td></tr></table></figure>
<p><strong>游标Cursor</strong></p>
<p>游标（Cursor）是一种用于在存储过程或函数中遍历结果集的机制。游标允许逐行访问结果集，并在每行上执行相应的操作</p>
<p>通常情况下，当执行一个查询语句时，MySQL 会返回一个结果集，该结果集包含了查询返回的所有行。以使用游标来逐行处理这个结果集，而不是一次性获取所有结果。这在处理大量数据或需要逐行处理结果的情况下非常有用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 声明游标、打开游标、获取下一行、关闭游标<br>DELIMITER //<br><br>CREATE PROCEDURE process_users()<br>BEGIN<br>    DECLARE done INT DEFAULT FALSE;<br>    DECLARE user_id INT;<br>    DECLARE user_name VARCHAR(255);<br><br>    -- 声明游标<br>    DECLARE user_cursor CURSOR FOR <br>        SELECT id, name FROM users;<br><br>    -- 打开游标<br>    OPEN user_cursor;<br><br>    -- 循环遍历结果集<br>    read_loop: LOOP<br>        -- 获取下一行数据<br>        FETCH user_cursor INTO user_id, user_name;<br>        IF done THEN<br>            LEAVE read_loop;<br>        END IF;<br>        <br>        -- 处理当前行数据<br>        -- 这里可以执行相应的操作，如输出到日志或进行其他逻辑处理<br>        SELECT CONCAT(&#x27;User ID: &#x27;, user_id, &#x27;, User Name: &#x27;, user_name);<br><br>    END LOOP;<br><br>    -- 关闭游标<br>    CLOSE user_cursor;<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4></li>
</ul>
<blockquote>
<p>有返回值的存储过程，存储函数的参数只能时IN类型’</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 语法结构<br>CREATE FUNCTION 存储函数名称([参数列表])<br>RETURNS type [characteristic...]<br>BEGIN<br>	--SQL语句<br>	RETURN ...;<br>END;<br><br>characteristics存储参数的特性<br>DETERMINISTIC : 相同的输入参数总是产生相同的结果<br>NO SQL : 不包含SQL语句<br>READS SQL DATA : 包含读取数据的语句，但不包含写入数据的语句<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4></li>
</ul>
<blockquote>
<p>在insert/update/delete之前或者之后，触发并执行触发器中定义的SQL语句集合。</p>
<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容</p>
<p>触发器只支持行级触发，不支持语句级别触发：如果一个UPDATE语句影响了5行，则触发器会被出发5次</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">触发器类型</th>
<th style="text-align:center">NEW和OLD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">INSERT型触发器</td>
<td style="text-align:center">NEW表示将要或者已经新增的数据</td>
</tr>
<tr>
<td style="text-align:center">UPDATE型触发器</td>
<td style="text-align:center">OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</td>
</tr>
<tr>
<td style="text-align:center">DELETE型触发器</td>
<td style="text-align:center">OLD表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 创建触发器<br>CREATE TRIGGER trigger_name<br>BEFORE/AFTER(在之前还是之后) INSERT/UPDATE/DELETE(触发器类型)<br>ON tbl_name FOR EACH ROW --行级触发器<br>BEGIN<br>	trigger_stmt; # 触发器逻辑<br>END;<br><br># 查看<br>SHOW TRIGGERS;<br><br># 删除，数据库中的触发器<br>DROP TRIGGER [schema_name.]trigger_name;<br></code></pre></td></tr></table></figure>
<h3 id="5、锁"><a href="#5、锁" class="headerlink" title="5、锁"></a>5、锁</h3><blockquote>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制，用于保证数据的一致性和有效性。</p>
</blockquote>
<ul>
<li>全局锁</li>
</ul>
<p>对整个数据库进行加锁，加锁以后整个实例就处于只读状态，后续的DML的写语句，DDL语句以及更新操作的事务提交语句都会被阻塞</p>
<p>做数据库的全库逻辑备份的时候，会对所有的表进行锁定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 为表加全局锁<br>FLUSH TABLES WITH READ LOCK;<br><br># 备份数据库<br>musqldump -uroot -p1234 数据库&gt;文件名<br><br># 释放全局锁<br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure>
<ul>
<li>表级锁</li>
</ul>
<p>每次操作会锁住整张表，发生锁冲突的概率最高，并发度最低</p>
<p><strong>表锁</strong></p>
<blockquote>
<p>表共享读锁：对于所有客户端的连接都只能读，不能写</p>
<p>表独占写锁：对于获取锁资源的客户端可以写，其他客户端不能进行读也不能执行写会被阻塞</p>
</blockquote>
<p>语法</p>
<p>1、加锁：lock tables 表名… read/write</p>
<p>2、释放锁：unlock tables /  客户端断开连接</p>
<p><strong>元数据锁</strong>（meta data lock）</p>
<blockquote>
<p>MDL加锁过程是系统自动控制的，无需显示使用，在访问一张表的时候会自动加上</p>
<p>元数据锁就是对表结构进行加锁</p>
</blockquote>
<p>当对一张表进行增删改查的时候，自动会加上MDL读锁，当对表结构进行变更时，会自动加上MDL写锁</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">对应SQL</th>
<th style="text-align:center">锁类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock table xx read/write</td>
<td style="text-align:center">SHARED_READ_ONLY/SHARED_NO_READ_WRITE</td>
</tr>
<tr>
<td style="text-align:center">select、select .. lock in share mode</td>
<td style="text-align:center">SHARED_READ</td>
</tr>
<tr>
<td style="text-align:center">insert、update、delet、sekect…from update</td>
<td style="text-align:center">SHARED_WRITE</td>
</tr>
<tr>
<td style="text-align:center">alter table…</td>
<td style="text-align:center">EXCLUSIVVE</td>
</tr>
</tbody>
</table>
</div>
<p><strong>意向锁</strong></p>
<img src="/2024/02/10/database-mysql/image-20240222075448991.png" class="" title="image-20240222075448991">
<img src="/2024/02/10/database-mysql/image-20240222075706155.png" class="" title="image-20240222075706155">
<ul>
<li>行级锁</li>
</ul>
<blockquote>
<p>应用在InnoDB存储引擎当中</p>
</blockquote>
<p>InnoDB的数据时基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</p>
<p><strong>行锁</strong></p>
<p>锁定单个行记录的锁，防止其他事务对此进行update和delete，在RC、RR隔离级别都支持</p>
<p>1、共享锁（S）：允许一个事务去读取一行，阻止其他事务获得相同数据集的排它锁，其他事务能读不能写</p>
<p>2、排它锁（X）：允许获取排它锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排它锁，其他事务不能写也不能读</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">SQL</th>
<th style="text-align:center">行锁类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">INSERT</td>
<td style="text-align:center">排它锁</td>
<td style="text-align:center">自动加锁</td>
</tr>
<tr>
<td style="text-align:center">UPDATE</td>
<td style="text-align:center">排它锁</td>
<td style="text-align:center">自动加锁</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">排它锁</td>
<td style="text-align:center">自动加锁</td>
</tr>
<tr>
<td style="text-align:center">SELECT</td>
<td style="text-align:center">不加任何锁</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SELECT … LOCK IN SHARE MODE</td>
<td style="text-align:center">共享锁</td>
<td style="text-align:center">手动加锁</td>
</tr>
<tr>
<td style="text-align:center">SELECT … FOR UPDATE</td>
<td style="text-align:center">排它锁</td>
<td style="text-align:center">手动</td>
</tr>
</tbody>
</table>
</div>
<p><strong>间隙锁</strong></p>
<p>锁定索引记录间隙，确保索引记录间隙不变，防止其他事务在这个间隙执行insert，产生幻读，在RR级别下支持</p>
<p><strong>临建锁</strong>（next-key）</p>
<p>同时锁住行记录也锁住间隙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询数据库中的锁<br>select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;<br></code></pre></td></tr></table></figure>
<h3 id="6、InnoDB核心"><a href="#6、InnoDB核心" class="headerlink" title="6、InnoDB核心"></a>6、InnoDB核心</h3><h3 id="7、MySQL管理"><a href="#7、MySQL管理" class="headerlink" title="7、MySQL管理"></a>7、MySQL管理</h3><h2 id="数据库运维"><a href="#数据库运维" class="headerlink" title="数据库运维"></a>数据库运维</h2><h3 id="1、日志"><a href="#1、日志" class="headerlink" title="1、日志"></a>1、日志</h3><h3 id="2、主从复制"><a href="#2、主从复制" class="headerlink" title="2、主从复制"></a>2、主从复制</h3><h3 id="3、分库分表"><a href="#3、分库分表" class="headerlink" title="3、分库分表"></a>3、分库分表</h3><h3 id="4、读写分离"><a href="#4、读写分离" class="headerlink" title="4、读写分离"></a>4、读写分离</h3><h3 id=""><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Database</tag>
        <tag>Mysql</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见用法</title>
    <url>/2024/01/04/git/</url>
    <content><![CDATA[<h4 id="怎样撤销一个已经push到远端的版本"><a href="#怎样撤销一个已经push到远端的版本" class="headerlink" title="怎样撤销一个已经push到远端的版本"></a>怎样撤销一个已经push到远端的版本</h4><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">每次<span class="hljs-built_in">push</span>之前线pull一下<br><br><span class="hljs-number">1</span>、查看当前提交的信息，找到需要撤回到的版本号复制，一串十六进制的数<br>git <span class="hljs-built_in">log</span><br><br><span class="hljs-number">2</span>、使用git reset<br>git reset --soft 复制的版本号<br><br><span class="hljs-number">3</span>、强制回退当前版本号<br><span class="hljs-comment">// 确认一下当前版本</span><br>git <span class="hljs-built_in">log</span><br><span class="hljs-comment">// 谨慎使用，强制使用本地仓库代码修改远程仓库</span><br>git <span class="hljs-built_in">push</span> orgin master --force<br></code></pre></td></tr></table></figure>
<h4 id="新建分支并同步到远端的分支"><a href="#新建分支并同步到远端的分支" class="headerlink" title="新建分支并同步到远端的分支"></a>新建分支并同步到远端的分支</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 在本地新建一个名字为branch_name的分支，并与远端的origin/branch_name同步</span><br>git checkout -<span class="hljs-keyword">b </span><span class="hljs-keyword">branch_name </span><span class="hljs-keyword">origin/branch_name</span><br></code></pre></td></tr></table></figure>
<h4 id="解决git-clone超时的问题"><a href="#解决git-clone超时的问题" class="headerlink" title="解决git clone超时的问题"></a>解决git clone超时的问题</h4><p>从github上clone代码仓库报错<code>Failed to connect to github.com port 443 after 21038 ms: Couldn&#39;t connect to server</code>且尝试去ping一下github官网会丢包</p>
<img src="/2024/01/04/git/image-20231204110955462.png" class="" title="image-20231204110955462">
<p>解决方案</p>
<p>修改系统的hosts，跳过域名解析的过程，直接用ip地址访问</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.30.255.112</span> github.com git<br><span class="hljs-number">185.31.16.184</span> github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure>
<img src="/2024/01/04/git/image-20231204111125551.png" class="" title="image-20231204111125551">
<p>修改hosts需要给文件更高的权限</p>
<img src="/2024/01/04/git/image-20231204111350240.png" class="" title="image-20231204111350240">
<h4 id="github中git-push出现超时的问题"><a href="#github中git-push出现超时的问题" class="headerlink" title="github中git push出现超时的问题"></a>github中git push出现超时的问题</h4><img src="/2024/01/04/git/image-20231204112945547.png" class="" title="image-20231204112945547">
<p>解决方案</p>
<p>1、打开本机的代理服务器</p>
<img src="/2024/01/04/git/image-20231204113100512.png" class="" title="image-20231204113100512">
<p>2、取消git config里面的http和https代理</p>
<img src="/2024/01/04/git/image-20231204113208566.png" class="" title="image-20231204113208566">
<p>3、设置http代理服务器</p>
<img src="/2024/01/04/git/image-20231204113304822.png" class="" title="image-20231204113304822">
<h4 id="linux中输出一个文件夹下面的所有文件名"><a href="#linux中输出一个文件夹下面的所有文件名" class="headerlink" title="linux中输出一个文件夹下面的所有文件名"></a>linux中输出一个文件夹下面的所有文件名</h4><ul>
<li><strong><code>/path/to/directory</code></strong>: 替换为目标目录的路径。</li>
<li><strong><code>-maxdepth 1</code></strong>: 限制<code>find</code>的搜索深度为1，即仅在指定的目录中搜索，而不会搜索其子目录。</li>
<li><strong><code>-type f</code></strong>: 限制搜索结果为普通文件（不包括目录和其他类型的文件）。</li>
<li><strong><code>-exec basename &#123;&#125; \;</code></strong>: 对每一个找到的文件执行<code>basename</code>命令，即输出文件的基本名称。<code>&#123;&#125;</code>是<code>find</code>命令的占位符，表示每个找到的文件的路径。<code>\;</code>表示命令结束。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find /path/to/directory -maxdepth 1 -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">basename</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure>
<h4 id="git查看远端仓库地址"><a href="#git查看远端仓库地址" class="headerlink" title="git查看远端仓库地址"></a>git查看远端仓库地址</h4><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> -<span class="hljs-string">v</span><br><br><span class="hljs-comment"># 更改远程仓库</span><br><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> 仓库地址<br></code></pre></td></tr></table></figure>
<h4 id="查看代码贡献量"><a href="#查看代码贡献量" class="headerlink" title="查看代码贡献量"></a>查看代码贡献量</h4><blockquote>
<p>按照各个作者的修改代码总数排序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%aN&quot;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> count author; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$author</span> &quot;</span>; git <span class="hljs-built_in">log</span> --author=<span class="hljs-string">&quot;<span class="hljs-variable">$author</span>&quot;</span> --pretty=tformat: --numstat | awk <span class="hljs-string">&#x27;&#123; add += $1; subs += $2 &#125; END &#123; total = add + subs; printf &quot;%d\n&quot;, total &#125;&#x27;</span>; <span class="hljs-keyword">done</span> | <span class="hljs-built_in">sort</span> -rnk2<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的排序算法</title>
    <url>/2024/02/21/sort-algrithon/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><blockquote>
<p>输入：整数数组nums</p>
<p>输出： 按照升序排序</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 函数接口</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思想：每次选择数组当前数组中最小的元素，放置到数组当前未选定的最前的位置</p>
<p>时间复杂度：n^2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; ++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; ++j)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                std::<span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思想：</p>
<p>每次比较相邻的元素，如果前面的元素大于后面的元素，则进行交换</p>
<p>当某一轮没有进行交换时，说明数组已经有序</p>
<p>时间复杂度：n^2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 冒泡排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 每一次最大的元素都能够沉到最下面</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n-i<span class="hljs-number">-1</span>; ++j)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j+<span class="hljs-number">1</span>])&#123;<br>                std::<span class="hljs-built_in">swap</span>(nums[j], nums[j+<span class="hljs-number">1</span>]);<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思想：</p>
<p>从前往后选择元素，插入到前面已经排序好的数组元素当中</p>
<p>始终保证当前元素前半部分都是有序的，直到所有元素遍历完</p>
<p>时间复杂度：n^2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 插入排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j)&#123;<br>            <span class="hljs-comment">// 注意比较的是相邻的元素，而不是num[i]</span><br>            <span class="hljs-keyword">if</span>(nums[j+<span class="hljs-number">1</span>] &gt;= nums[j])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                std::<span class="hljs-built_in">swap</span>(nums[j+<span class="hljs-number">1</span>], nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：分治法</p>
<p>将长度为n的数组分为两个长度为n/2的数组</p>
<p>继续分为长度为n/4的数组，最后分为长度为1的数组</p>
<p>分别对长度为1的两两数组进行合并</p>
<p>对长度为2的两两数组进行合并</p>
<p>长度为4的两两数组进行合并</p>
<p>最后对长度为n/2的数组进行合并得到的就是长度为n的有序数组</p>
<p><strong>因为合并过程中依赖的小序列都是有序的，通过选择最小元素很容易合并</strong></p>
<p>时间复杂度：nlog(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n1 = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n2 = right - mid;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n1)</span>, <span class="hljs-title">R</span><span class="hljs-params">(n2)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++)<br>        L[i] = nums[left + i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n2; j++)<br>        R[j] = nums[mid + <span class="hljs-number">1</span> + j];<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = left;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) &#123;<br>            nums[k] = L[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums[k] = R[j];<br>            j++;<br>        &#125;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; n1) &#123;<br>        nums[k] = L[i];<br>        i++;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (j &lt; n2) &#123;<br>        nums[k] = R[j];<br>        j++;<br>        k++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(nums, left, mid);<br>        <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-built_in">merge</span>(nums, left, mid, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想：分治法，快排要注意要从right开始</p>
<p>选择一个主元</p>
<p>将小于主元的元素放在左边</p>
<p>将大于主元的元素放在右边</p>
<p>主元的位置则可以确定</p>
<p>分别对主元左边的数组和右边的数组再次进行快速排序</p>
<p>时间复杂度：nlog(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partion</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> value = nums[left];<br>    <span class="hljs-type">int</span> idx = left;<br>    <span class="hljs-comment">// left += 1; left不用+1，相等的情况已经考虑了</span><br>    <br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= value)right--;<br>        nums[idx] = nums[right];<br>        idx = right;<br>        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= value)left++;<br>        nums[idx] = nums[left];<br>        idx = left;<br>    &#125;<br>    nums[idx] = value;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">partion</span>(nums, left, right);<br>    <span class="hljs-built_in">quicksort</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quicksort</span>(nums, mid+<span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思想：</p>
<p>将数组看成一棵完全二叉树，按照数组中的元素建立大顶堆</p>
<p>交换堆顶元素和当前最末端元素，此时最大的元素到了数组尾部，锁定位置</p>
<p>对当前堆进行更新</p>
<p>时间复杂度：nlg(n)</p>
<blockquote>
<p>建堆时间为lg(n)</p>
<p>取出元素为1，更新堆为lg(n)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> largest = i;  <span class="hljs-comment">// 初始化最大值为当前节点</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左孩子节点的索引为 2*i + 1</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 右孩子节点的索引为 2*i + 2</span><br><br>    <span class="hljs-comment">// 如果左孩子节点比当前节点大</span><br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; nums[left] &gt; nums[largest])<br>        largest = left;<br><br>    <span class="hljs-comment">// 如果右孩子节点比当前最大值大</span><br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; nums[right] &gt; nums[largest])<br>        largest = right;<br><br>    <span class="hljs-comment">// 如果最大值不是当前节点</span><br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        <span class="hljs-comment">// 交换当前节点和最大值节点的值</span><br>        <span class="hljs-built_in">swap</span>(nums[i], nums[largest]);<br><br>        <span class="hljs-comment">// 递归地对受影响的子树进行堆化</span><br>        <span class="hljs-built_in">heapify</span>(nums, n, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make_heap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 构建堆（重新排列数组）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-built_in">heapify</span>(nums, n, i);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">make_heap</span>(nums);<br><br>    <span class="hljs-comment">// 逐个从堆中提取元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 将当前根节点移动到末尾</span><br>        <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[i]);<br><br>        <span class="hljs-comment">// 对减小后的堆进行堆化</span><br>        <span class="hljs-built_in">heapify</span>(nums, i, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>思想：</p>
<p>使用一定的间隔（数组长度的一半）对数组进行分组，然后对每个分组进行插入排序</p>
<p>随着排序的进行，间隔逐步减小，直到间隔为1，最终完成排序</p>
<p>时间复杂度：n^1.3</p>
<p>设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 初始化间隔gap为数组长度的一半，然后逐步缩小间隔直至为1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 对每个间隔进行插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> temp = arr[i];<br>            <span class="hljs-type">int</span> j;<br><br>            <span class="hljs-comment">// 将arr[i]插入到正确的位置</span><br>            <span class="hljs-keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;<br>                arr[j] = arr[j - gap];<br>            &#125;<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">shellSort</span>(nums);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>时间复杂度：n+k，k为当前数组中的最大值</p>
<blockquote>
<p>如果有负数还需要进行另外处理</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countingSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到数组中的最大值</span><br>    <span class="hljs-type">int</span> max_num = *std::<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 创建计数数组，并初始化为0</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(max_num + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 统计每个元素出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        count[num]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据计数数组重建排序后的数组</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedArray</span><span class="hljs-params">(nums.size())</span></span>;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= max_num; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (count[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            sortedArray[index++] = i;<br>            count[i]--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sortedArray;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">countingSort</span>(nums);<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法研究</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>选择排序</tag>
        <tag>冒泡排序</tag>
        <tag>插入排序</tag>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
        <tag>堆排序</tag>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>平方根倒数算法</title>
    <url>/2024/01/24/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="平方根倒数算法"><a href="#平方根倒数算法" class="headerlink" title="平方根倒数算法"></a>平方根倒数算法</h3><script type="math/tex; mode=display">
1/\sqrt{x}</script><h4 id="求一个数的平方根倒数"><a href="#求一个数的平方根倒数" class="headerlink" title="求一个数的平方根倒数"></a>求一个数的平方根倒数</h4><p>对于计算机来说求一个数的平方根一般有两种方式，二分法和牛顿迭代法</p>
<ul>
<li><p>二分法</p>
<p>EXP表示精度，从0-num不断开始计算mid的平方，直到left&gt;right，此时返回right的值即为所求的平方根，其中注意边界条件：</p>
<p>当mid <em> mid = num时，此时left需要加上EXP，往后的循环中mid </em> mid 都会大于num，所以right还会不停减小，直到right &lt; left，返回right，这时right已经在精度范围内</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;<br>    <span class="hljs-type">double</span> left = <span class="hljs-number">0</span>, right = num;<br> <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">double</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br> <br>        <span class="hljs-keyword">if</span> (mid * mid &lt;= num)<br>            left = mid + EXP;<br>        <span class="hljs-keyword">else</span><br>            right = mid - EXP;<br>    &#125;   <br> <br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>牛顿迭代法</p>
<p>牛顿迭代法是将原来的求开方问题转化为数学函数问题，即假设<code>x * x = n</code>，求n的开方转化为<code>x * x - n = 0</code>的解，即<code>y = x * x - n</code>与x轴的交点</p>
<p>代码中last表示上一次的切线与x轴的交点的x坐标，初始值为num，ret表示x = last时的切线与x轴的交点，不断迭代，直到ret - last小于精度，即达到精度返回ret。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == num)<br>        <span class="hljs-keyword">return</span> num;<br> <br>    <span class="hljs-type">double</span> last = num, ret = num;<br> <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        last = <span class="hljs-number">0.5</span> * (ret + num / ret);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(ret - last) &lt; EXP)<br>            <span class="hljs-keyword">break</span>;<br>        ret = last;<br>    &#125;   <br> <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>计算完平方根过后，再计算其倒数，也是一个对计算机来说并不是很友好的运算</p>
<h4 id="快速平方根倒数计算推导"><a href="#快速平方根倒数计算推导" class="headerlink" title="快速平方根倒数计算推导"></a>快速平方根倒数计算推导</h4><p>快速平方根算法是利用了计算机存储浮点数的特性并和牛顿迭代法来共同完成的，也是一个近似计算。对于牛顿迭代法，其精髓是如果能够找到一个接近于解的初始值，是有可能通过一次迭代或者较少次数的迭代达到比较高的近似解，而快速平方根算法旨在于找到一个较为近似的初始值。具体的运算如下。</p>
<p><strong>笔记中有一处笔误0xD5F400000应改成0x5F400000</strong></p>
<img src="/2024/01/24/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E7%AE%97%E6%B3%95/%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B.png" class="" title="运算过程">
<p>快速平方根算法代码</p>
<ul>
<li>初始值由0x5F400000改为了0x5f3759df，对于X/2代码中使用了位运算加速求解</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Q_rsqrt</span><span class="hljs-params">(<span class="hljs-type">float</span> number)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">float</span> x2, y;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> threehalfs = <span class="hljs-number">1.5F</span>;<br>    x2 = number * <span class="hljs-number">0.5F</span>;<br>    y = number;<br>    i = * ( <span class="hljs-type">long</span>* ) &amp;y;							<span class="hljs-comment">// evil floating point bit hack</span><br>    i = <span class="hljs-number">0x5f3759df</span> - (i &gt;&gt; <span class="hljs-number">1</span>);					<span class="hljs-comment">// what the fuck? </span><br>    y = * ( <span class="hljs-type">float</span> * ) &amp;i;<br>    y = y * (threehalfs - ( x2 * y * y ) );		<span class="hljs-comment">// 1st iteration</span><br><span class="hljs-comment">//  y = y * (threehalfs - ( x2 * y * y ) );		// 2st iteration, can be removed</span><br>    <br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间的通信方式</title>
    <url>/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>每个进程的用户地址空间是独立的，一般情况之下，不同的进程是<strong>无法</strong>通过进程间各自的地址空间来进行互相访问，但是不同的进程所拥有的内核空间是共享的，因此如果不同进程之间需要进行通信必须要通过内核。</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道通信分为匿名管道和命名管道，通过名字可以区分，匿名管道是无法获取和控制的管道，命名管道是通过用户可以自己建立的管道。</p>
<p>管道智能进行半双工的通信，即数据传输是单向的，如果想要实现互相通信，就需要创建两个管道。</p>
<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><ul>
<li>在linux中的<code>|</code>竖线就是一个管道，将管道符前的操作的输出作为管道符后的操作的输入</li>
</ul>
<p>一个匿名管道的创建会使用到下面的系统调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure>
<p>表示创建了一个匿名管道并返回了两个文件描述符，一个是管道读取端的描述符<code>fd[0]</code>，另一个是管道写入端的描述符<code>fd[1]</code>，<strong>匿名管道是特殊的文件，只存在于内存当中，不存在于文件系统中</strong></p>
<p>管道实际上就是内核中的一串缓存，进程通过文件描述符来对这一串缓存进行读写操作</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130223824673.png" class="" title="image-20240130223824673">
<p><strong>如果说需要实现多个进程之间的通信</strong>，可以使用<code>fork</code>操作来创建子进程，创建子进程时，子进程会同时复制父进程的文件描述符，两个进程便可以通过各自的文件描述符来进行跨进程之间的通信。</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130224638178.png" class="" title="image-20240130224638178">
<p>通过对文件描述符的开放和关闭，可以控制父进程和子进程之间的读写操作。</p>
<ul>
<li>如：父进程关闭读取的 fd[0]，只保留写入的 fd[1]；子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>
<li>便可以实现从父进程向子进程的数据写入</li>
</ul>
<p>实现多个进程之间匿名管道的通信另一种方式就是fork两个子进程，关闭父进程的文件描述符，开启子进程的<code>fd</code>，实现子进程之间的通信。</p>
<p>可以看出来，匿名管道的通信范围仅限于父子关系的进程。因为管道没有实体，没有管道文件，只能通过复制父进程的fd来使用文件描述符。</p>
<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><ul>
<li>在linux中可以通过<code>mkfifo</code>命令来创建并指定管道名字</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> myPipe<br></code></pre></td></tr></table></figure>
<p>因为命名管道，提前创建了一个类型为管道的设备文件，在进程中只要使用到这个设备，便可以互相通信。</p>
<p><strong>管道的通信方式，效率较低，不适合进程间的频繁交换数据</strong></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><blockquote>
<p>在管道通信的缺点下，消息队列可以解决进程间频繁交换数据的问题。</p>
</blockquote>
<p>消息队列是保护在内核中的消息列表，如果进程之间需要进行通信，只需要将消息放在对应的消息队列中便可以正常返回，无需阻塞等待，等到另一个进程需要的时候去消息队列中去读取便可以。</p>
<p>如果消息队列没有释放或者没有关闭操作系统，消息队列会一直存在，而匿名管道则是随着进程的生命周期的结束而销毁。</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>解决频繁交换数据的问题</p>
<p>两个进程之间就像发邮件一样可以你来我往进行沟通</p>
</li>
<li><p>进程发送消息后无需阻塞等待消息的接收</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>不适合比较大的数据传输</p>
<p>消息队列中的消息体是由结构化的数据结构来组织的，有最大长度的限制。</p>
</li>
<li><p>消息队列的通信过程中，存在用户态与内核态之间的数据拷贝开销</p>
</li>
</ul>
</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存用到的是现代操作系统中的内存管理的<strong>虚拟内存技术</strong>，每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。</p>
<p><strong>共享内存的机制：拿出一块虚拟地址空间，映射到相同的物理内存中。</strong>不同的进程可以使用各自的虚拟地址访问到这一片相同的物理内存。</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130232827259.png" class="" title="image-20240130232827259">
<ul>
<li><p>优点</p>
<ul>
<li>解决了消息队列中不适合大的数据的通信</li>
<li>不同进程之间无需进行频繁的用户态和内核态的转换，因为进程都是在自己的用户地址空间中来进行操作</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>对共享内存的读写问题</p>
<p>因为共享内存存储的信息一旦发生改变对于不同的进程都是可见的，所以会涉及到读写一致性的问题</p>
</li>
<li><p>共享内存也变为了临界资源，存在进程进程之间的竞争</p>
<p>需要保护机制，使得共享资源在任意时刻只能被一个进程访问。</p>
</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote>
<p>信号量可以提供对临界资源的保护</p>
</blockquote>
<p>信号量是一个整型的计数器，可以用于实现进程间的互斥以及同步，不是用于缓存进程间通信的数据。</p>
<p>信号量的大小表示为资源的数量，对信号量的操作方式有两种原子操作</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>通过PV操作可以控制进程对资源的互斥访问以及控制进程的同步顺序，<strong>涉及到操作系统的知识</strong></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><blockquote>
<p>在进程工作异常情况下，需要通过信号来通知进程</p>
</blockquote>
<p>信号是进程间通信机制中的唯一的异步通信方式，因为可以在任何时候发送信号到某一进程，一旦有信号产生，用户就可以进行对信号处理。</p>
<ul>
<li><p>信号的处理方式</p>
<ul>
<li>执行默认操作： 例如linux中的SIGTERM 信号，就是终止进程的意思</li>
<li>捕捉信号：可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数</li>
<li>忽略信号：当不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。</li>
</ul>
</li>
<li><p><code>SIGKILL</code> 和 <code>SEGSTOP</code>无法被捕捉和忽略。</p>
</li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket通信实现的是在不同主机之间的通信，分为两种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式</p>
<blockquote>
<p>基于 TCP 协议的通信方式需要客户和服务器之间建立TCP连接，进行三次握手。</p>
</blockquote>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234627976.png" class="" title="image-20240130234627976">
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<blockquote>
<p>基于UDP的Socket通信</p>
</blockquote>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234754230.png" class="" title="image-20240130234754230">
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>
<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>
<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程通信</tag>
      </tags>
  </entry>
</search>
