<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高性能键值存储系统实现</title>
    <url>/2024/02/27/build-sample-redis/</url>
    <content><![CDATA[<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h1 id="简易Redis的实现"><a href="#简易Redis的实现" class="headerlink" title="简易Redis的实现"></a>简易Redis的实现</h1><p>这个项目实现了一个简易的redis，使用hashmap来管理键值对数据，使用hashmap+AVL数来管理Zset数据，并实现了hashmap的渐进式扩容，减少因为扩容重新哈希化带来rehash的代价。使用poll技术来实现IO多路复用，完成一个服务端与多个客户端建立连接的过程，使用双向链表来管理连接，通过最小堆来控制val的生存时间，并通过将两者结合的方式，控制poll的最大超时时间，用来确保每一次poll的陷入内核和退出内核在主进程中都有处理的任务。</p>
<p>1、最小堆的维护，当为某一个key设置好ttl时，会将key当中需要维护的ttl放入到最小堆当中，每一次轮询结束以后，会统一进行处理，已经失效的key</p>
<p>2、双向链表的维护，poll当中，会把第一个fd设置成为用于处理连接事件的fd，当有连接事件发生的时候，会处理连接，接受一个新的连接，并将其放入到双向链表的头部，会有一个conn的结构体，里面实现了读写缓存，以及接受当前连接的空闲队列节点，以及建立连接的时间，然后会把这个连接放入到空闲队列当中的头部。</p>
<p>3、过期时间的处理，会在每一次poll以及对应的事件处理结束以后，对当前的key进行ttl的检查，包括conn的过期时间和key的过期时间，会对空闲队列中的一些长期占用时间的连接进行清除，以及最小堆当中过期的key进行清理（不断地pop掉最小堆当中的数据，直到没有那些超时数据）。</p>
<p>4、线程池的作用，当缓存数据过多时，实现异步清除。</p>
<h2 id="一、实现的命令"><a href="#一、实现的命令" class="headerlink" title="一、实现的命令"></a>一、实现的命令</h2><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">// hashtable<br>set key value	向哈希表中插入键值对<br>get key			从哈希表中查找键对应的值<br>del key			从哈希表中删除键<br>keys			打印出哈希表中所有的keys<br><br>// zset<br>zadd key score name		向键为key中，插入name，score<br>zscore key name			按照key和name查找score<br>zrem key name			删除键为key中的name元素<br>zscore key name			查找键为key的name的score<br>zquery<br><br></code></pre></td></tr></table></figure>
<h2 id="二、Socket编程相关语法"><a href="#二、Socket编程相关语法" class="headerlink" title="二、Socket编程相关语法"></a>二、Socket编程相关语法</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul>
<li>创建句柄</li>
</ul>
<p>函数原型：<code>int socket(int domain, int type, int protocol);</code></p>
<p>domin：指定通信域，ipv4或ipv6，AF_INET表示ipv4地址</p>
<p>type：指定套接字类型</p>
<p>protocol：0表示为TCP协议</p>
<ul>
<li>设置socket可选项</li>
<li>Bind，绑定ip和端口号</li>
<li>Listen</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Server::run_server</span><span class="hljs-params">()</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// init coding...</span><br><br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">die</span>(<span class="hljs-string">&quot;socket()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>(fd, SOL_SOCKET, SO_REUSEADDR, &amp;val, <span class="hljs-built_in">sizeof</span>(val));<br><br>    <span class="hljs-comment">// bind</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr = &#123;&#125;;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">ntohs</span>(<span class="hljs-number">1234</span>);<br>    addr.sin_addr.s_addr = <span class="hljs-built_in">ntohl</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> rv = <span class="hljs-built_in">bind</span>(fd, (<span class="hljs-type">const</span> sockaddr *)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-keyword">if</span> (rv) &#123;<br>        <span class="hljs-built_in">die</span>(<span class="hljs-string">&quot;bind()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// listen</span><br>    rv = <span class="hljs-built_in">listen</span>(fd, SOMAXCONN);<br>    <span class="hljs-keyword">if</span> (rv) &#123;<br>        <span class="hljs-built_in">die</span>(<span class="hljs-string">&quot;listen()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// coding...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// bind</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr = &#123;&#125;;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">ntohs</span>(<span class="hljs-number">1234</span>);<br>    addr.sin_addr.s_addr = <span class="hljs-built_in">ntohl</span>(<span class="hljs-number">0</span>);    <span class="hljs-comment">// wildcard address 0.0.0.0</span><br>    <span class="hljs-function">Server <span class="hljs-title">server</span><span class="hljs-params">(addr, fd)</span></span>;<br>    <br>    server.<span class="hljs-built_in">run_server</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li>创建句柄</li>
<li>设置IP地址和端口号</li>
<li>Connect</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Client::run_client</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">die</span>(<span class="hljs-string">&quot;socket()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> rv = <span class="hljs-built_in">connect</span>(fd, (<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-keyword">if</span> (rv) &#123;<br>        <span class="hljs-built_in">die</span>(<span class="hljs-string">&quot;connect&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// coding...</span><br><br>    <span class="hljs-built_in">close</span>(fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr = &#123;&#125;;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">ntohs</span>(<span class="hljs-number">1234</span>);<br>    addr.sin_addr.s_addr = <span class="hljs-built_in">ntohl</span>(INADDR_LOOPBACK);  <span class="hljs-comment">// 127.0.0.1</span><br>    <br>    <span class="hljs-function">Client <span class="hljs-title">client</span><span class="hljs-params">(addr, fd)</span></span>;<br>    client.<span class="hljs-built_in">run_client</span>(argc, argv);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>使用的协议</strong></p>
<p>len+msg的结合</p>
<p>len表示后面的字长，msg表示要获取的数据</p>
<h2 id="三、事件循环和非阻塞型IO"><a href="#三、事件循环和非阻塞型IO" class="headerlink" title="三、事件循环和非阻塞型IO"></a>三、事件循环和非阻塞型IO</h2><blockquote>
<p>在服务器端网络编程中，处理并发连接有三种方法：forking、多线程（multi-threading）和事件循环（event loops）。forking会为每个客户端连接创建新的进程以实现并发。多线程使用线程而不是进程。事件循环使用轮询和非阻塞 I/O，通常在单个线程上运行。由于进程和线程的开销，大多数现代生产级软件使用事件循环来进行网络编程。</p>
</blockquote>
<p>在项目中用到了IO多路复用中的poll技术来实现，在服务端使用单个进程和多个客户端建立连接，在客户端看来，像是每一个客户端都和一个独立的服务端建立了连接并进行数据通信，而在服务端看来，它所完成的则是在不同的时间段服务不同的客户，但由于时间片比较小，就会让客户端感觉好像实现了多个进程通信的过程。</p>
<h2 id="四、哈希表数据结构"><a href="#四、哈希表数据结构" class="headerlink" title="四、哈希表数据结构"></a>四、哈希表数据结构</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><p>哈希节点</p>
<p>哈希表节点是以链表的形式存储，包含一个next节点和一个hcode（哈希化以后的映射值）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 哈希表节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HNode</span> &#123;<br>    HNode *next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">uint64_t</span> hcode = <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>哈希表</p>
<p>哈希表主要载体是一个HNode的二维指针，第一个指针代表的是哈希值，第二个指针存储的是链表，链表是用来解决哈希冲突的方式。size表示的是当前哈希表中的总结点数目，mask表示掩码，为哈希表第一个维度大小减1。</p>
<p>在哈希表中实现了，insert，lookup，detach，init接口，分别表示节点的插入，节点的查找，节点的删除。</p>
<p>需要使用有参的构造函数初始化，传入的参数为整型，整型必须为2的幂，便于构建mask。</p>
<ul>
<li><p>节点的插入过程</p>
<p>1、先计算当前节点中hcode应该属于的pos（即链表位置），计算方式是与<code>&amp;</code>上mask</p>
<p>2、使用头插法，将节点插入到对应的位置，修改size大小</p>
</li>
<li><p>节点的查找过程</p>
<p>1、查找哈希化后的链表位置。</p>
<p>2、在链表中查找当前节点。</p>
</li>
<li><p>节点的删除过程<code>HNode *detach(HNode **from)</code></p>
<p>1、解除引用，获取链表位置</p>
<p>2、绕过当前节点，指向下一节点</p>
<p>3、具体使用需要先找到节点位置，再调用detach</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 哈希表</span><br><span class="hljs-comment">// 接口: insert, lookup, detach</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HTab</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    HNode **tab = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">size_t</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> mask = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HTab</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-comment">// 传入的n必须为2的幂</span><br>    <span class="hljs-built_in">HTab</span>(<span class="hljs-type">size_t</span> n): <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">mask</span>(n<span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">assert</span>((n &amp; (n<span class="hljs-number">-1</span>)) == <span class="hljs-number">0</span>);<br>        tab = <span class="hljs-keyword">new</span> HNode*[n];<br>    &#125;;<br>    ~<span class="hljs-built_in">HTab</span>() &#123; <span class="hljs-keyword">delete</span>[] tab; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(HNode *node)</span></span>;<br>    <span class="hljs-function">HNode *<span class="hljs-title">lookup</span><span class="hljs-params">(HNode *key, <span class="hljs-type">bool</span> (*eq)(HNode *, HNode *))</span></span>;<br>    <span class="hljs-function">HNode *<span class="hljs-title">detach</span><span class="hljs-params">(HNode **from)</span></span>;<br><br>    <span class="hljs-comment">// setter</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_tab</span><span class="hljs-params">(HNode **t)</span> </span>&#123; tab = t; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_mask</span><span class="hljs-params">(<span class="hljs-type">size_t</span> m)</span> </span>&#123; mask = m; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_size</span><span class="hljs-params">(<span class="hljs-type">size_t</span> s)</span> </span>&#123; size = s; &#125;<br><br>    <span class="hljs-comment">// getter</span><br>    <span class="hljs-function">HNode **<span class="hljs-title">get_tab</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> tab; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">get_mask</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> mask; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">get_size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> size; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>哈希map</p>
<p>哈希表中含有两个HTab，用于完成渐进式的rehash。第一张表存储新的键值，第二张表存储旧的键值，当在第一张表中查找不到元素时，会再在第二张表查找。</p>
<p>固定值的设置，k_max_load_factor表示负载因子，设置为8，即表示当前的总的HMap的节点数大于Mask的8倍的时候，就会对哈希表进行扩容。k_resizing_work的大小表示将哈希扩容分配到各个语句当中的单次转移的节点数量。resizing_pos记录resizing的位置。</p>
<p>哈希Map实现了，insert，lookup，pop，size，destroy的接口，分别表示<strong>插入，查找，删除，返回哈希map节点数，以及销毁</strong>。同时会在负载过大时，重新申请更大的内存，执行resize操作，并分发到其他语句当中。</p>
<p>start_resizing：检查ht2节点数是否大于零，若大于零，说明正在进行rehash中，将指定数量的节点rehash</p>
<p>start_resizing：分配一个更大的表给ht1，要提前将ht2指向ht1</p>
<ul>
<li><p>插入的实现</p>
<p>1、将节点插入到ht1当中，如果ht1为空，则新建ht1</p>
<p>2、检查ht2是否为空，如果为空，则检查表1的负载因子，大于特定值，则开始resizing，如果ht2不为空，则说明正在resize，执行help_resizing。</p>
</li>
<li><p>查找的实现</p>
<p>1、执行start_resizing</p>
<p>2、分别在ht1和ht2中查找</p>
</li>
<li><p>删除的实现</p>
<p>1、执行start_resizing</p>
<p>2、执行查找，用返回节点执行节点删除</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><br><span class="hljs-comment">// 哈希map</span><br><span class="hljs-comment">// 使用两张哈希表用于渐进式rehash</span><br><span class="hljs-comment">// 接口: insert, lookup, pop, size, destroy</span><br><span class="hljs-comment">// private: start_resizing, help_resizing</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HMap</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    HTab ht1;   <span class="hljs-comment">// newer</span><br>    HTab ht2;   <span class="hljs-comment">// older</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">size_t</span> resizing_pos = <span class="hljs-number">0</span>;    <br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> k_resizing_work = <span class="hljs-number">128</span>; <span class="hljs-comment">// constant work</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> k_max_load_factor = <span class="hljs-number">8</span>; <span class="hljs-comment">// constant load factor</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">help_resizing</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start_resizing</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HMap</span>() : <span class="hljs-built_in">ht1</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">ht2</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">resizing_pos</span>(<span class="hljs-number">0</span>) &#123;&#125;;<br>    <span class="hljs-built_in">HMap</span>(<span class="hljs-type">size_t</span> n): <span class="hljs-built_in">ht1</span>(n), <span class="hljs-built_in">ht2</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">resizing_pos</span>(<span class="hljs-number">0</span>) &#123;&#125;;<br>    ~<span class="hljs-built_in">HMap</span>() &#123; ht1.~<span class="hljs-built_in">HTab</span>(); ht2.~<span class="hljs-built_in">HTab</span>(); &#125;<br><br>    <span class="hljs-comment">// 插入、查找、删除、大小、销毁</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(HNode *node)</span></span>;<br>    <span class="hljs-function">HNode *<span class="hljs-title">lookup</span><span class="hljs-params">(HNode *key, <span class="hljs-type">bool</span> (*eq)(HNode *, HNode *))</span></span>;<br>    <span class="hljs-function">HNode *<span class="hljs-title">pop</span><span class="hljs-params">(HNode *key, <span class="hljs-type">bool</span> (*eq)(HNode *, HNode *))</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>实际应用过程中还会有一个结构体</p>
<p>将哈希表节点和键值对进行绑定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">HNode</span> node;<br>    std::string key;<br>    std::string val;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="渐进式rehash过程"><a href="#渐进式rehash过程" class="headerlink" title="渐进式rehash过程"></a>渐进式rehash过程</h3><p>在哈希表的构建时，使用的是用二维指针来存储哈希表，解决哈希冲突的方式是常用的拉链法（使用链表存储映射值相等的哈希元素），第一个维度作为哈希映射的key值来定位到具体的映射链表，第二个维度则是用来解决哈希冲突的，考虑到哈希表定义本身的属性，我们是希望哈希表的哈希冲突尽可能少，也就是我们的链表的长度尽可能短，随着我们插入的数据不断增加，我们产生的哈希冲突也是会增加的。</p>
<p>在这里我们定义了一个负载因子<code>k_max_load_factor</code>，在实际插入的过程中，当当前用于查找的哈希表中的负载（元素个数/掩码）大于负载因子，会启动rehash的过程，我们会申请一张比原来哈希表大两倍的哈希表，将当前哈希表中的数据重新映射到这一张新的哈希表中。这样我们原来短，高的哈希表，就会变成长，矮的哈希表。</p>
<p>我们知道，当哈希表中的元素过多的时候，需要对所有元素都一起进行rehash是一个非常耗时的过程，如果我们只有一张哈希表，我们在进行rehash的过程中，还不能够允许其他插入、删除以及查询操作，为了解决这样一个问题，我们采用将rehash分散在各个其他语句的步骤，在我们负载因子达到一定程度的时候，我们会启动渐进式rehash，当我们有其他插入或者查询语句到来的时候，我们会先进行部分node的rehsah，再进行查询语句。我们可以看下面例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">HNode *<span class="hljs-title">HMap::lookup</span><span class="hljs-params">(HNode *key, <span class="hljs-type">bool</span> (*eq)(HNode *, HNode *))</span> </span>&#123;<br>    <span class="hljs-built_in">help_resizing</span>();<br>    HNode **from = ht1.<span class="hljs-built_in">lookup</span>(key, eq);<br>    from = from ? from : ht2.<span class="hljs-built_in">lookup</span>(key, eq);<br>    <span class="hljs-keyword">return</span> from ? *from : <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// class HMap</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HMap::help_resizing</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">size_t</span> nwork = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (nwork &lt; k_resizing_work &amp;&amp; ht2.<span class="hljs-built_in">get_size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// scan for nodes from ht2 and move them to ht1</span><br>        HNode **from = &amp;ht2.<span class="hljs-built_in">get_tab</span>()[resizing_pos];<br>        <span class="hljs-keyword">if</span> (!*from) &#123;<br>            resizing_pos++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ht1.<span class="hljs-built_in">insert</span>(ht2.<span class="hljs-built_in">detach</span>(from));<br>        nwork++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (ht2.<span class="hljs-built_in">get_size</span>() == <span class="hljs-number">0</span> &amp;&amp; ht2.<span class="hljs-built_in">get_tab</span>()) &#123;<br>        <span class="hljs-comment">// done</span><br>        <span class="hljs-keyword">delete</span>[] ht2.<span class="hljs-built_in">get_tab</span>();<br>        ht2 = HTab&#123;&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="五、平衡二叉树"><a href="#五、平衡二叉树" class="headerlink" title="五、平衡二叉树"></a>五、平衡二叉树</h2><p>平衡二叉树是一种特殊的二叉搜索树，对平衡二叉树来说，它的中序遍历是有序的，并且左右子树的高度差会处于一个平衡的状态，这样可以保证每次查找都能够在比较快的时间内完成。</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><blockquote>
<p>平衡二叉树本身就是由节点构成的</p>
</blockquote>
<p>depth：以当前节点为根节点所在树的高度</p>
<p>cnt：以当前节点为根节点的总节点数，便于进行区间统计</p>
<p>left：左节点，right：右节点，parent：父节点</p>
<p>提供的辅助函数</p>
<ul>
<li>rot_left：对当前节点进行左旋操作</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 对b节点进行左旋，返回d节点</span><br>  <span class="hljs-selector-tag">b</span>         d<br> / \       /<br><span class="hljs-selector-tag">a</span>   d ==&gt; <span class="hljs-selector-tag">b</span><br>   /     / \<br>  c     <span class="hljs-selector-tag">a</span>   c<br></code></pre></td></tr></table></figure>
<ul>
<li><p>rot_right：镜像操作</p>
</li>
<li><p>avl_fix_left</p>
<p>1、左子树的右子树太深需要先左旋后右旋</p>
<p>2、左子树的左子树太深，直接右旋</p>
</li>
</ul>
<figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica">   <span class="hljs-variable">root</span><br>   <span class="hljs-operator">/</span>            左旋<span class="hljs-punctuation">(</span><span class="hljs-variable">root</span><span class="hljs-operator">-&gt;</span><span class="hljs-variable">left</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">A</span><br> <span class="hljs-operator">/</span> \<br><span class="hljs-variable">B</span>   <span class="hljs-built_in">C</span><br>   <span class="hljs-operator">/</span> \<br>  <span class="hljs-built_in">D</span>   <span class="hljs-built_in">E</span><br>  <br>   <span class="hljs-variable">root</span><br>   <span class="hljs-operator">/</span>              右旋<span class="hljs-punctuation">(</span><span class="hljs-variable">root</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-built_in">C</span><br> <span class="hljs-operator">/</span> \<br><span class="hljs-variable">A</span>   <span class="hljs-built_in">E</span><br><span class="hljs-operator">/</span> \<br><span class="hljs-variable">B</span>   <span class="hljs-built_in">D</span><br><br>    <span class="hljs-built_in">C</span><br>   <span class="hljs-operator">/</span> \<br>  <span class="hljs-variable">A</span>   <span class="hljs-variable">root</span><br> <span class="hljs-operator">/</span> \    \<br><span class="hljs-variable">B</span>   <span class="hljs-built_in">D</span>    <span class="hljs-built_in">E</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>avl_fix_right也类似</p>
</li>
<li><p>avl_fix：对平衡二叉树的修复，当执行删除和插入节点时，调用这个函数保持节点的平衡</p>
</li>
<li><p>avl_del：删除节点</p>
<p>1、当当前要删除的节点不存在右节点时，如果有左子树，将左子树向上提，如果没有左子树，说明删除的是root，最终都是返回左子树，返回左子树</p>
<p>2、如果存在右节点，递归的找到右节点当中的最小元素，修改树的结构</p>
</li>
<li><p>avl_offset：从当前节点出发，按照偏移来进行查找节点</p>
<p>1、初始化pos为0，表示当前节点相对于起始节点的位置</p>
<p>2、如果pos等于偏移量，则返回</p>
<p>3、如果小于偏移量，并且加上右节点的节点数大于offset，则说明在右子树</p>
<p>4、如果大于偏移量，并且减去左节点的节点数小于offset，说明在左子树</p>
<p>5、否则在父节点</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 平衡二叉树</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AVLNode</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">uint32_t</span> depth = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">uint32_t</span> cnt = <span class="hljs-number">0</span>;<br>    AVLNode *left = <span class="hljs-literal">NULL</span>;<br>    AVLNode *right = <span class="hljs-literal">NULL</span>;<br>    AVLNode *parent = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">AVLNode</span>(AVLNode *node);<br>    <span class="hljs-built_in">AVLNode</span>();<br>    ~<span class="hljs-built_in">AVLNode</span>();<br>    <span class="hljs-function">AVLNode *<span class="hljs-title">avl_fix</span><span class="hljs-params">(AVLNode *node)</span></span>;<br>    <span class="hljs-function">AVLNode *<span class="hljs-title">avl_del</span><span class="hljs-params">(AVLNode *node)</span></span>;<br>    <span class="hljs-function">AVLNode *<span class="hljs-title">avl_offset</span><span class="hljs-params">(AVLNode *node, <span class="hljs-type">int64_t</span> offset)</span></span>;<br><br>    <span class="hljs-comment">// get </span><br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">avl_depth</span><span class="hljs-params">(AVLNode *node)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">avl_cnt</span><span class="hljs-params">(AVLNode *node)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> lhs, <span class="hljs-type">uint32_t</span> rhs)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">avl_update</span><span class="hljs-params">(AVLNode *node)</span></span>;<br>    <br>    <span class="hljs-function">AVLNode *<span class="hljs-title">rot_left</span><span class="hljs-params">(AVLNode *node)</span></span>;<br>    <span class="hljs-function">AVLNode *<span class="hljs-title">rot_right</span><span class="hljs-params">(AVLNode *node)</span></span>;<br>    <span class="hljs-function">AVLNode *<span class="hljs-title">avl_fix_left</span><span class="hljs-params">(AVLNode *root)</span></span>;<br>    <span class="hljs-function">AVLNode *<span class="hljs-title">avl_fix_right</span><span class="hljs-params">(AVLNode *root)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="六、zset数据结构"><a href="#六、zset数据结构" class="headerlink" title="六、zset数据结构"></a>六、zset数据结构</h2><p>zset在Redis中是使用跳表+哈希表来实现的</p>
<p>这里使用AVL树+哈希表来实现</p>
<ul>
<li><p>ZNode</p>
<p>ZNode中需要存储AVL树节点以及哈希节点，同时存储score是用于排序的键，ZNode中携带的数据可以提供快速查找，也支持有序访问，node同时属于AVL树和哈希表。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZNode</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    AVLNode tree; <span class="hljs-comment">// AVL树节点</span><br>    HNode hmap;   <span class="hljs-comment">// 哈希表节点</span><br>    <span class="hljs-type">double</span> score; <span class="hljs-comment">// 分数</span><br>    <span class="hljs-type">size_t</span> len;   <span class="hljs-comment">// 名称长度</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-built_in">ZNode</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">size_t</span> len, <span class="hljs-type">double</span> score);<br>    ~<span class="hljs-built_in">ZNode</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>ZSet</p>
<p>在ZSet中包含一个tree指向平衡二叉树的根节点，平衡二叉树关联着ZNode中的tree，同时维护一张HMap哈希表，用于对数据的快速查找</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">接口</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ZNode <em>zset_lookup(const char </em>name, size_t len);</td>
<td style="text-align:center">根据传入的name来进行查找，从哈希表中查找</td>
</tr>
<tr>
<td style="text-align:center">bool zset_add(const char *name, size_t len, double score);</td>
<td style="text-align:center">向ZSet中添加一个节点元素</td>
</tr>
<tr>
<td style="text-align:center">ZNode <em>zset_pop(const char </em>name, size_t len);</td>
<td style="text-align:center">从ZSet中弹出一个元素，按照name来弹出</td>
</tr>
<tr>
<td style="text-align:center">ZNode <em>zset_query(double score, const char </em>name, size_t len);</td>
<td style="text-align:center">查找ZSet中分数以及name都相等的ZNode</td>
</tr>
<tr>
<td style="text-align:center">ZNode <em>znode_offset(ZNode </em>node, int64_t offset);</td>
<td style="text-align:center">根据分数的偏移从AVLtree中查找ZNode</td>
</tr>
<tr>
<td style="text-align:center">void zset_dispose();</td>
<td style="text-align:center">清空当前的ZSet，包括AVL树的清空和hmap的清空</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZSet</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    AVLNode *tree = <span class="hljs-literal">nullptr</span>;<br>    HMap hmap;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ZSet</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">ZSet</span>() &#123; <span class="hljs-built_in">zset_dispose</span>(); &#125;<br><br>    <span class="hljs-comment">// helper</span><br>    <span class="hljs-function">ZNode *<span class="hljs-title">znode_new</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len, <span class="hljs-type">double</span> score)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-type">size_t</span> lhs, <span class="hljs-type">size_t</span> rhs)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">zless</span><span class="hljs-params">(AVLNode *lhs, <span class="hljs-type">double</span> score, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">zless</span><span class="hljs-params">(AVLNode *lhs, AVLNode *rhs)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zset_update</span><span class="hljs-params">(ZNode *node, <span class="hljs-type">double</span> score)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tree_add</span><span class="hljs-params">(ZNode *node)</span></span>;<br>    <br>    <span class="hljs-comment">// interface</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">zset_add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len, <span class="hljs-type">double</span> score)</span></span>;<br>    <span class="hljs-comment">// 根据键值来查找哈希表</span><br>    <span class="hljs-function">ZNode *<span class="hljs-title">zset_lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len)</span></span>;<br>    <span class="hljs-function">ZNode *<span class="hljs-title">zset_pop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len)</span></span>;<br>    <span class="hljs-function">ZNode *<span class="hljs-title">zset_query</span><span class="hljs-params">(<span class="hljs-type">double</span> score, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len)</span></span>;<br>    <span class="hljs-function">ZNode *<span class="hljs-title">znode_offset</span><span class="hljs-params">(ZNode *node, <span class="hljs-type">int64_t</span> offset)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">znode_del</span><span class="hljs-params">(ZNode *node)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tree_dispose</span><span class="hljs-params">(AVLNode *node)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zset_dispose</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>zset_lookup</p>
<p>按照name在ZSet中查找节点</p>
<ul>
<li>直接通过hmap查找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ZNode *<span class="hljs-title">ZSet::zset_lookup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!tree) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    HKey key;<br>    key.node.hcode = <span class="hljs-built_in">str_hash</span>((<span class="hljs-type">uint8_t</span>*)name, len);<br>    key.name = name;<br>    key.len = len;<br>    HNode *found = hmap.<span class="hljs-built_in">lookup</span>(&amp;key.node, &amp;hcmp);<br>    <span class="hljs-keyword">return</span> found ? <span class="hljs-built_in">container_of</span>(found, ZNode, hmap) : <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>zset_add</p>
<ul>
<li>先查找set中是否存在有对应的节点，如果有则更新value的值</li>
<li>如果没有，则生成一个新的znode并插入到zset中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ZSet::zset_add</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len, <span class="hljs-type">double</span> score)</span> </span>&#123;<br>    ZNode *node = <span class="hljs-built_in">zset_lookup</span>(name, len);<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>        <span class="hljs-built_in">zset_update</span>(node, score);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        node = <span class="hljs-built_in">znode_new</span>(name, len, score);<br>        hmap.<span class="hljs-built_in">insert</span>(&amp;node-&gt;hmap);<br>        <span class="hljs-built_in">tree_add</span>(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>zset_pop</p>
<blockquote>
<p>通过name在zset数据结构中弹出对应的节点</p>
</blockquote>
<ul>
<li>先从哈希表中查找对应的哈希节点</li>
<li>通过找到的节点找到节点的Znode</li>
<li>在AVL书中删除对应的Znode，并返回当前节点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ZNode *<span class="hljs-title">ZSet::zset_pop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(!tree) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    HKey key;<br>    key.node.hcode = <span class="hljs-built_in">str_hash</span>((<span class="hljs-type">uint8_t</span>*)name, len);<br>    key.name = name;<br>    key.len = len;<br>    HNode *found = hmap.<span class="hljs-built_in">lookup</span>(&amp;key.node, &amp;hcmp);<br>    <span class="hljs-keyword">if</span>(!found) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    ZNode *node = found-&gt;owner;<br>    tree = tree-&gt;<span class="hljs-built_in">avl_del</span>(&amp;node-&gt;tree);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>zset_query</p>
<blockquote>
<p>通过分数以及name查找的znode</p>
</blockquote>
<ul>
<li>先通过分数在AVL树上进行查找，是一个二分查找的过程</li>
<li>再通过比较查找得到的节点的name是否相等来对比返回结果</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ZNode *<span class="hljs-title">ZSet::zset_query</span><span class="hljs-params">(<span class="hljs-type">double</span> score, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    AVLNode *found = <span class="hljs-literal">nullptr</span>;<br>    AVLNode *cur = tree;<br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">zless</span>(cur, score, name, len)) &#123;<br>            cur = cur-&gt;right;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            found = cur;<br>            cur = cur-&gt;left;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> found ? found-&gt;owner : <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ZSet::zless</span><span class="hljs-params">(AVLNode *lhs, <span class="hljs-type">double</span> score, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 根据指针偏移找到ZNode</span><br>    <span class="hljs-keyword">auto</span> zl = lhs-&gt;owner;<br>    <span class="hljs-keyword">if</span> (zl-&gt;score != score) &#123;<br>        <span class="hljs-keyword">return</span> zl-&gt;score &lt; score;<br>    &#125;<br>    <span class="hljs-type">int</span> rv = <span class="hljs-built_in">memcmp</span>(zl-&gt;name, name, <span class="hljs-built_in">min</span>(zl-&gt;len, len));<br>    <span class="hljs-keyword">if</span> (rv != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> rv &lt; <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> zl-&gt;len &lt; len;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>znode_offset</p>
<blockquote>
<p>根据score的偏移在AVL树中查找Znode。在我们的代码中AVL节点的定义，参考上面的avl_offset文字算法伪代码</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">ZNode *<span class="hljs-title">ZSet::znode_offset</span><span class="hljs-params">(ZNode *node, <span class="hljs-type">int64_t</span> offset)</span> </span>&#123;<br>    AVLNode *tnode = node ? tree-&gt;<span class="hljs-built_in">avl_offset</span>(&amp;node-&gt;tree, offset) : <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> tnode ? tnode-&gt;owner : <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="七、测试效果"><a href="#七、测试效果" class="headerlink" title="七、测试效果"></a>七、测试效果</h2>]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>C++</tag>
        <tag>Redis</tag>
        <tag>数据库缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中常见容器的使用方法</title>
    <url>/2024/07/12/c-stl-use/</url>
    <content><![CDATA[<h1 id="序列容器"><a href="#序列容器" class="headerlink" title="序列容器"></a>序列容器</h1><blockquote>
<p>不知道如何解释，凭感觉吧，就是我们想象中的那样。</p>
</blockquote>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><code>vector</code>是我们常用的动态数组，它通过模板泛型编程的方式，让我们能够使用<code>vector</code>来存储任意对象。</p>
<p><code>vector</code>的底层是内存当中一段连续的地址空间，地址空间连续的最大好处就是能够支持用户的随机访问，我们可以和操作数组一样，使用下标的方式来获取到容器中的对象。在<code>vector</code>中有两个关键的成员变量<code>size</code>和<code>capacity</code>，其中<code>size</code>表示的是当前容器中存储的对象实际个数，而<code>capacity</code>则是容器的最大容量。这两个成员是实现<code>vector</code>扩容的关键。</p>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>成员函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>容量相关</td>
<td><code>size()</code></td>
<td>返回容器中元素的个数。</td>
</tr>
<tr>
<td></td>
<td><code>max_size()</code></td>
<td>返回容器所能容纳的最大元素数量。</td>
</tr>
<tr>
<td></td>
<td><code>resize(n, val)</code></td>
<td>调整容器的大小到 <code>n</code> 个元素，如果 <code>n</code> 大，则以 <code>val</code> 填充新位置。</td>
</tr>
<tr>
<td></td>
<td><code>capacity()</code></td>
<td>返回不需要重新分配内存空间的情况下容器可容纳的元素数量。</td>
</tr>
<tr>
<td></td>
<td><code>empty()</code></td>
<td>检测容器是否为空。</td>
</tr>
<tr>
<td></td>
<td><code>reserve(n)</code></td>
<td>请求容器容量至少为 <code>n</code> 个元素。</td>
</tr>
<tr>
<td></td>
<td><code>shrink_to_fit()</code></td>
<td>请求减少容器容量以节省空间。（C++11）</td>
</tr>
<tr>
<td>修改内容</td>
<td><code>clear()</code></td>
<td>移除所有元素，容器大小变为 0。</td>
</tr>
<tr>
<td></td>
<td><code>insert(pos, elem)</code></td>
<td>在迭代器 <code>pos</code> 指定的位置插入元素 <code>elem</code>。</td>
</tr>
<tr>
<td></td>
<td><code>emplace(position, args...)</code></td>
<td>在迭代器 <code>position</code> 指定的位置就地构造元素。（C++11）</td>
</tr>
<tr>
<td></td>
<td><code>erase(pos)</code></td>
<td>删除迭代器 <code>pos</code> 指定位置上的元素。</td>
</tr>
<tr>
<td></td>
<td><code>push_back(elem)</code></td>
<td>在容器尾部添加一个新元素 <code>elem</code>。</td>
</tr>
<tr>
<td></td>
<td><code>emplace_back(args...)</code></td>
<td>在容器尾部就地构造一个新元素。（C++11）</td>
</tr>
<tr>
<td></td>
<td><code>pop_back()</code></td>
<td>移除容器尾部的最后一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>resize(n)</code></td>
<td>改变容器中元素的数量为 <code>n</code>。</td>
</tr>
<tr>
<td></td>
<td><code>swap(vec)</code></td>
<td>与另一个同类型向量 <code>vec</code> 交换数据。</td>
</tr>
<tr>
<td>元素访问</td>
<td><code>operator[]</code></td>
<td>访问指定位置的元素。</td>
</tr>
<tr>
<td></td>
<td><code>at(index)</code></td>
<td>访问指定位置的元素，包含边界检查。</td>
</tr>
<tr>
<td></td>
<td><code>front()</code></td>
<td>访问第一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>back()</code></td>
<td>访问最后一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>data()</code></td>
<td>返回指向容器头部元素的指针。</td>
</tr>
<tr>
<td>迭代器</td>
<td><code>begin()</code> / <code>cbegin()</code></td>
<td>返回指向容器开始的迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>end()</code> / <code>cend()</code></td>
<td>返回指向容器结束（最后元素的下一个位置）的迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>rbegin()</code> / <code>crbegin()</code></td>
<td>返回反向迭代器的起始位置。</td>
</tr>
<tr>
<td></td>
<td><code>rend()</code> / <code>crend()</code></td>
<td>返回反向迭代器的结束位置。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>vector</code>扩容机制</p>
<blockquote>
<p>通常能够触发扩容的行为有：往容器中添加元素、使用<code>resize</code>或<code>reserve</code>使大小超过容量、通过构造函数初始化超出默认容量</p>
</blockquote>
<p>  <code>vector</code>扩容机制是通过重新分配内存来实现的，当向容器中添加元素，并且元素的数量超过了其内部数组容量时，会自动触发扩容。</p>
<p>  1、重新分配：首先，<code>vector</code> 会申请一个新的、更大的内存块来存储元素。新容量通常是当前容量的两倍，但这个增长因子并不是标准规定的，可能因不同的库实现而异。</p>
<p>  2、拷贝或移动元素：现有元素会被拷贝（或移动，如果它们支持 <code>move</code> 语义）到新的内存地址。</p>
<p>  3、释放旧内存：一旦旧元素被成功转移，原来的内存块将被释放。</p>
<p>  4、更新容量：<code>vector</code> 更新其容量值以反映新内存块的大小。</p>
</li>
<li><p><code>reserve</code>和<code>resize</code></p>
<p>  如果我们能够预知到我们需要使用的<code>vector</code>容器的最大个数，我们可以使用<code>reserve</code>来为我们需要用到的容器，提前申请一片足够大的内存，这样就可以保证在程序运行过程中不需要去对容器进行扩容，因为<code>vector</code>的扩容是一个代价相对较大的一件事。</p>
<p>  <code>resize</code>是重新为容器设置<code>size</code>大小，如果容器当前的对象大于设置的<code>size</code>，则容器会被截断，如果小于，则会使用默认构造去填充新的后续空间，如果比<code>capacity</code>还要大，会涉及到触发容器的扩容。</p>
<p>  <code>reserve</code>是重新设置容量的大小，不会更改<code>size</code>的值，只有当需要申请的容量大于<code>capacity</code>，才会起作用，否则不会起任何作用。</p>
</li>
<li><p><code>push_back</code>和<code>emplace_back</code></p>
<p>  使用<code>push_back()</code>向<code>vector</code>添加元素时，是在向函数传递一个已经存在的对象。这个对象是通过调用拷贝构造函数或移动构造函数来添加到容器末尾的。如果传递的是左值（例如一个变量），那么会调用拷贝构造函数；如果传递的是右值，则会调用移动构造函数（前提是该类型支持移动语义）。</p>
<p>  <code>emplace_back()</code>不需要传入一个已经构造好的对象，而是接受任意数量和类型的参数，并将它们直接传递给元素类型的构造函数。也就是说<code>emplace_back()</code>试图在容器管理的内存区域中直接构造对象，避免了额外的拷贝或移动步骤。</p>
</li>
</ul>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p><code>list</code>是我们常用的双向链表，通过节点来组织起来的数据结构，节点中会存有两个指针分别用来指向下一个节点的地址，和上一个节点的地址，通过链接的方式就能够形成一个双向链表的结构。通常链表在内存当中的地址并不是连续的，所以链表并不支持随机存取，无法通过下标的方式来进行访问。但是相比于<code>vector</code>来说，链表对于插入和删除工作来说更具有优势。</p>
<p>其实，我们能够很容易的自己构建自己的链表，只需要定义一个包含指向下一个节点的指针就可以了，所以在实际应用中，我个人用<code>list</code>这个数据结构并不是很多。自己的链表可以根据实际业务来给定相关特定的属性。</p>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>成员函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>容量相关</td>
<td><code>size()</code></td>
<td>返回容器中元素的个数。</td>
</tr>
<tr>
<td></td>
<td><code>empty()</code></td>
<td>检查容器是否为空。</td>
</tr>
<tr>
<td></td>
<td><code>max_size()</code></td>
<td>返回容器所能容纳的最大元素数量。</td>
</tr>
<tr>
<td>修改内容</td>
<td><code>clear()</code></td>
<td>移除所有元素，容器大小变为 0。</td>
</tr>
<tr>
<td></td>
<td><code>insert(position, val)</code></td>
<td>在迭代器 <code>position</code> 指定的位置插入值为 <code>val</code> 的元素。</td>
</tr>
<tr>
<td></td>
<td><code>emplace(position, args...)</code></td>
<td>在迭代器 <code>position</code> 指定的位置就地构造元素。（C++11）</td>
</tr>
<tr>
<td></td>
<td><code>erase(position)</code> / <code>erase(first, last)</code></td>
<td>删除位于迭代器 <code>position</code> 或 <code>[first, last)</code> 范围内的元素。</td>
</tr>
<tr>
<td></td>
<td><code>push_back(val)</code></td>
<td>在容器尾部添加一个新元素。</td>
</tr>
<tr>
<td></td>
<td><code>emplace_back(args...)</code></td>
<td>在容器尾部就地构造一个新元素。（C++11）</td>
</tr>
<tr>
<td></td>
<td><code>pop_back()</code></td>
<td>移除容器尾部的最后一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>push_front(val)</code></td>
<td>在容器头部添加一个新元素。</td>
</tr>
<tr>
<td></td>
<td><code>emplace_front(args...)</code></td>
<td>在容器头部就地构造一个新元素。（C++11）</td>
</tr>
<tr>
<td></td>
<td><code>pop_front()</code></td>
<td>移除容器头部的第一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>resize(n)</code></td>
<td>改变容器中元素的数量为 <code>n</code>。</td>
</tr>
<tr>
<td></td>
<td><code>swap(list)</code></td>
<td>与另一个同类型列表 <code>list</code> 交换数据。</td>
</tr>
<tr>
<td></td>
<td><code>merge(x)</code></td>
<td>合并两个已排序的列表。</td>
</tr>
<tr>
<td></td>
<td><code>remove(val)</code></td>
<td>移除所有值为 <code>val</code> 的元素。</td>
</tr>
<tr>
<td></td>
<td><code>remove_if(predicate)</code></td>
<td>移除满足特定条件的所有元素。</td>
</tr>
<tr>
<td></td>
<td><code>reverse()</code></td>
<td>反转列表中的元素顺序。</td>
</tr>
<tr>
<td></td>
<td><code>sort()</code></td>
<td>对列表中的元素进行排序。</td>
</tr>
<tr>
<td></td>
<td><code>unique()</code></td>
<td>移除连续重复的元素。</td>
</tr>
<tr>
<td>元素访问</td>
<td><code>front()</code></td>
<td>访问第一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>back()</code></td>
<td>访问最后一个元素。</td>
</tr>
<tr>
<td>迭代器</td>
<td><code>begin()</code> / <code>cbegin()</code></td>
<td>返回指向容器开始的迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>end()</code> / <code>cend()</code></td>
<td>返回指向容器结束（最后元素的下一个位置）的迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>rbegin()</code> / <code>crbegin()</code></td>
<td>返回反向迭代器的起始位置。</td>
</tr>
<tr>
<td></td>
<td><code>rend()</code> / <code>crend()</code></td>
<td>返回反向迭代器的结束位置。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>链表Q&amp;A</strong></p>
<ul>
<li><p>检查链表是否有环</p>
<p>  快慢指针</p>
</li>
<li><p>反转链表</p>
<p>  头插法</p>
</li>
<li><p>合并有序链表</p>
<p>  归并</p>
</li>
<li><p>寻找倒数第k个节点</p>
<p>  先后节点</p>
</li>
<li><p>旋转链表</p>
<p>  多次反转链表</p>
</li>
</ul>
<h2 id="array"><a href="#array" class="headerlink" title="array"></a>array</h2><p><code>array</code>是一种固定大小的数组，相对于传统的数组来说，提供了更加安全和方便的接口，它的长度在编译的时候就已经确定，所以不支持动态的调整数组的大小。</p>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>成员函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>容量相关</td>
<td><code>size()</code></td>
<td>返回数组中元素的个数。</td>
</tr>
<tr>
<td></td>
<td><code>max_size()</code></td>
<td>返回数组所能容纳的最大元素数量。</td>
</tr>
<tr>
<td></td>
<td><code>empty()</code></td>
<td>检查数组是否为空。</td>
</tr>
<tr>
<td>元素访问</td>
<td><code>operator[]</code></td>
<td>使用下标访问元素，不进行边界检查。</td>
</tr>
<tr>
<td></td>
<td><code>at(size_type n)</code></td>
<td>使用下标访问元素，进行边界检查。</td>
</tr>
<tr>
<td></td>
<td><code>front()</code></td>
<td>访问第一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>back()</code></td>
<td>访问最后一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>data()</code></td>
<td>返回指向数组首个元素的指针。</td>
</tr>
<tr>
<td>修改内容</td>
<td><code>fill(const T&amp; value)</code></td>
<td>用指定的值填充整个数组。</td>
</tr>
<tr>
<td></td>
<td><code>swap(array&amp; other)</code></td>
<td>交换两个数组的内容。</td>
</tr>
<tr>
<td>迭代器</td>
<td><code>begin()</code> / <code>cbegin()</code></td>
<td>返回指向数组首个元素的迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>end()</code> / <code>cend()</code></td>
<td>返回指向数组末尾元素之后位置的迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>rbegin()</code> / <code>crbegin()</code></td>
<td>返回指向数组最后一个元素的反向迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>rend()</code> / <code>crend()</code></td>
<td>返回指向数组第一个元素之前位置的反向迭代器。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><code>deque</code>是<code>STL</code>容器中的双端队列，是支持能够从头增加元素的一种容器，相比于<code>vector</code>在插入上来说，会更加灵活。<code>deque</code>的内部不是使用单一连续内存块来存储元素的，而是采用一个中央控制器来管理多个固定大小的数组（成为缓冲区或段）。每个缓冲区可能存储多个元素，中央控制器是一个动态数组，包含指向这些缓冲区的指针。这样的设计，能够使得在两端添加或者一处元素时无需移动其他元素。</p>
<p><code>deque</code>和<code>vector</code>都支持随机访问，但是相比于<code>vector</code>之下，<code>deque</code>对某一个元素的访问，效率相比之下会低一些，<code>deque</code>所支持的随机访问并不是通过首地址+偏移量来直接映射到内存地址空间的，而是会通过一个中央控制器的结构来计算出所要查询的元素所在的块以及在块中的偏移量。</p>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类别</th>
<th>成员函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>容量相关</td>
<td><code>size()</code></td>
<td>返回容器中元素的个数。</td>
</tr>
<tr>
<td></td>
<td><code>empty()</code></td>
<td>检查容器是否为空。</td>
</tr>
<tr>
<td></td>
<td><code>max_size()</code></td>
<td>返回容器所能容纳的最大元素数量。</td>
</tr>
<tr>
<td>修改内容</td>
<td><code>clear()</code></td>
<td>移除所有元素，容器大小变为 0。</td>
</tr>
<tr>
<td></td>
<td><code>insert(position, val)</code></td>
<td>在迭代器 <code>position</code> 指定的位置插入值为 <code>val</code> 的元素。</td>
</tr>
<tr>
<td></td>
<td><code>insert(position, n, val)</code></td>
<td>在迭代器 <code>position</code> 指定的位置插入 <code>n</code> 个值为 <code>val</code> 的元素。</td>
</tr>
<tr>
<td></td>
<td><code>insert(position, first, last)</code></td>
<td>在迭代器 <code>position</code> 指定的位置插入来自范围 <code>[first, last)</code> 的元素。</td>
</tr>
<tr>
<td></td>
<td><code>emplace(position, args...)</code></td>
<td>在迭代器 <code>position</code> 指定的位置就地构造元素。（C++11）</td>
</tr>
<tr>
<td></td>
<td><code>erase(position)</code> / <code>erase(first, last)</code></td>
<td>删除位于迭代器 <code>position</code> 或 <code>[first, last)</code> 范围内的元素。</td>
</tr>
<tr>
<td></td>
<td><code>push_back(val)</code></td>
<td>在容器尾部添加一个新元素。</td>
</tr>
<tr>
<td></td>
<td><code>emplace_back(args...)</code></td>
<td>在容器尾部就地构造一个新元素。（C++11）</td>
</tr>
<tr>
<td></td>
<td><code>pop_back()</code></td>
<td>移除容器尾部的最后一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>push_front(val)</code></td>
<td>在容器头部添加一个新元素。</td>
</tr>
<tr>
<td></td>
<td><code>emplace_front(args...)</code></td>
<td>在容器头部就地构造一个新元素。（C++11）</td>
</tr>
<tr>
<td></td>
<td><code>pop_front()</code></td>
<td>移除容器头部的第一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>resize(n)</code></td>
<td>改变容器中元素的数量为 <code>n</code>。</td>
</tr>
<tr>
<td></td>
<td><code>swap(deque)</code></td>
<td>与另一个同类型双端队列 <code>deque</code> 交换数据。</td>
</tr>
<tr>
<td>元素访问</td>
<td><code>front()</code></td>
<td>访问第一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>back()</code></td>
<td>访问最后一个元素。</td>
</tr>
<tr>
<td></td>
<td><code>operator[]</code></td>
<td>使用下标访问元素，不进行边界检查。</td>
</tr>
<tr>
<td></td>
<td><code>at()</code></td>
<td>使用下标访问元素，进行边界检查。</td>
</tr>
<tr>
<td>迭代器</td>
<td><code>begin()</code> / <code>cbegin()</code></td>
<td>返回指向容器开始的迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>end()</code> / <code>cend()</code></td>
<td>返回指向容器结束（最后元素的下一个位置）的迭代器。</td>
</tr>
<tr>
<td></td>
<td><code>rbegin()</code> / <code>crbegin()</code></td>
<td>返回反向迭代器的起始位置。</td>
</tr>
<tr>
<td></td>
<td><code>rend()</code> / <code>crend()</code></td>
<td>返回反向迭代器的结束位置。</td>
</tr>
</tbody>
</table>
</div>
<h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>前面我们讲了<code>deque</code>的相关用法，我们可以发现，这是一种双端都不受限制的容器，因为在容器的头部和尾部，我们都可以进行容器元素的插入和删除操作，而如果我们把容器的某一端的插入或者删除操作给予一定的限制，那么就可以衍生出另外两种常用的容器队列<code>queue</code>和栈<code>stack</code>，而在我们的<code>C++</code>容器中，<code>queue</code>和<code>stack</code>的底层默认便是基于<code>deque</code>来实现的。</p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><p><code>queue</code>是一个先进先出<code>FIFO</code>的数据结构，底层是基于<code>deque</code>来实现的，通常我们会限制<code>deque</code>一端的入队和另一端的出队，这样我们就能够实现一个队列的数据结构，通常用于按照顺序处理元素的场景。比较经典的就是在我们的广度优先算法中使用比较广泛，还有树的层序遍历。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(graph.size(), <span class="hljs-literal">false</span>)</span></span>;<br><br>    q.<span class="hljs-built_in">push</span>(start);<br>    visited[start] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Visited node: &quot;</span> &lt;&lt; node &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>                q.<span class="hljs-built_in">push</span>(neighbor);<br>                visited[neighbor] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 这里图的描述方式是邻接表的方式</span><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">bfs</span>(graph, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(value)</code></td>
<td>将元素添加到队列的末尾</td>
<td><code>q.push(1);</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>移除队列的第一个元素</td>
<td><code>q.pop();</code></td>
</tr>
<tr>
<td><code>front()</code></td>
<td>返回队列的第一个元素，但不删除</td>
<td><code>int front = q.front();</code></td>
</tr>
<tr>
<td><code>back()</code></td>
<td>返回队列的最后一个元素，但不删除</td>
<td><code>int back = q.back();</code></td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>检查队列是否为空</td>
<td><code>bool isEmpty = q.empty();</code></td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回队列中元素的个数</td>
<td><code>std::size_t size = q.size();</code></td>
</tr>
<tr>
<td><code>emplace(args...)</code></td>
<td>就地构造元素并添加到队列的末尾</td>
<td><code>q.emplace(2);</code></td>
</tr>
<tr>
<td><code>swap(queue)</code></td>
<td>交换两个队列的内容</td>
<td><code>q1.swap(q2);</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><p><code>stack</code>也是一种受限制的双端队列，我们会同时限制一端的入队和出队，这样就能够实现一个栈的性质。适用的场景有：表达式求值（后缀表达式）、括号匹配、深度优先遍历等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph, <span class="hljs-type">int</span> start)</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visited</span><span class="hljs-params">(graph.size(), <span class="hljs-literal">false</span>)</span></span>;<br><br>    s.<span class="hljs-built_in">push</span>(start);<br>    visited[start] = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> node = s.<span class="hljs-built_in">top</span>();<br>        s.<span class="hljs-built_in">pop</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Visited node: &quot;</span> &lt;&lt; node &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> neighbor : graph[node]) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[neighbor]) &#123;<br>                s.<span class="hljs-built_in">push</span>(neighbor);<br>                visited[neighbor] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; graph = &#123;<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>&#125;,<br>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs</span>(graph, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>push(value)</code></td>
<td>将元素添加到栈顶</td>
<td><code>s.push(1);</code></td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>移除栈顶的元素</td>
<td><code>s.pop();</code></td>
</tr>
<tr>
<td><code>top()</code></td>
<td>返回栈顶的元素，但不删除</td>
<td><code>int top = s.top();</code></td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>检查栈是否为空</td>
<td><code>bool isEmpty = s.empty();</code></td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回栈中元素的个数</td>
<td><code>std::size_t size = s.size();</code></td>
</tr>
<tr>
<td><code>emplace(args...)</code></td>
<td>就地构造元素并添加到栈顶</td>
<td><code>s.emplace(2);</code></td>
</tr>
<tr>
<td><code>swap(stack)</code></td>
<td>交换两个栈的内容</td>
<td><code>s1.swap(s2);</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p><a href="https://www.zdon.fun/2024/03/06/c-priority-queue/">参考：C++优先队列的用法</a></p>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器和顺序容器底层的实现方式存在一定的差异，关联容器通常底层的实现采用的数的结构，我们这里用到的是红黑树，而红黑树是一种相对平衡的二叉搜索树。</p>
<p><strong>红黑树的特点</strong></p>
<p>自平衡：红黑树通过颜色属性（红或黑）和旋转操作来保持树的平衡，确保树的高度约为 O(log n)。</p>
<p>节点颜色规则：</p>
<pre><code>每个节点是红色或黑色。

根节点是黑色。

叶子节点（NIL节点）是黑色。

红色节点的子节点必须是黑色（即红色节点不能连续）。

从任一节点到其每个叶子的路径都包含相同数量的黑色节点。
</code></pre><p>旋转操作：红黑树使用左旋和右旋操作来调整树的结构以保持平衡。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map</code>是<code>C++</code>当中的关联容器，可以将元素按照键值对的形式组织起来，在默认情况下，我们对一个<code>map</code>使用迭代器进行遍历的话，我们可以发现<code>map</code>中的<code>key</code>是按照递增的方式来输出的，这是因为对<code>map</code>的遍历过程实际上就是一个二叉搜索树的中序遍历的一个过程。</p>
<p>通常情况下，我们的<code>key</code>是唯一的，如果我们在已经存在<code>key</code>的情况之下，再次插入同样的<code>key</code>和<code>value</code>的话，只会对原始<code>key</code>所对应的<code>value</code>进行更新操作，如果我们想要存储同一个<code>key</code>的多个<code>value</code>值，我们可以使用<code>STL</code>中的另一个容器<code>mutilmap</code>。</p>
<p>在我们构造<code>map</code>时，默认会按照<code>key</code>的升序构造，同时，我们可以通过加入<code>greater</code>参数来让我们的<code>map</code>按照<code>key</code>的降序构造。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">std::map&lt;<span class="hljs-type">int</span>, std::string, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; m;<br><br><span class="hljs-comment">// 自定义比较函数，小于升序，大于降序</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CustomCompare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br><br>std::map&lt;<span class="hljs-type">int</span>, std::string, CustomCompare&gt; m;<br><br></code></pre></td></tr></table></figure>
<p>如果想要使用自定义的对象作为<code>map</code>的<code>key</code>，我们需要在对象中，对<code>&lt;</code>进行运算符重载，表示自定义的比较函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (x != other.x) <span class="hljs-keyword">return</span> x &lt; other.x;<br>        <span class="hljs-keyword">return</span> y &lt; other.y;<br>    &#125;<br><br>    <span class="hljs-comment">// 用于输出 Point 对象</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> Point&amp; point) &#123;<br>        os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; point.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; point.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::map&lt;Point, std::string&gt; pointMap;<br><br>    <span class="hljs-comment">// 插入键值对</span><br>    pointMap[<span class="hljs-built_in">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)] = <span class="hljs-string">&quot;Point 1&quot;</span>;<br>    pointMap[<span class="hljs-built_in">Point</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)] = <span class="hljs-string">&quot;Point 2&quot;</span>;<br>    pointMap[<span class="hljs-built_in">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)] = <span class="hljs-string">&quot;Point 3&quot;</span>;<br><br>    <span class="hljs-comment">// 遍历并输出 map 中的键值对</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : pointMap) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(&#123;key, value&#125;)</code></td>
<td>插入键值对</td>
<td><code>m.insert(&#123;1, &quot;one&quot;&#125;);</code></td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>移除指定位置的元素</td>
<td><code>m.erase(m.begin());</code></td>
</tr>
<tr>
<td><code>erase(key)</code></td>
<td>移除指定键的元素</td>
<td><code>m.erase(1);</code></td>
</tr>
<tr>
<td><code>find(key)</code></td>
<td>查找键，返回指向键值对的迭代器，不存在则返回 <code>end()</code></td>
<td><code>auto it = m.find(1);</code></td>
</tr>
<tr>
<td><code>operator[](key)</code></td>
<td>访问或插入指定键的元素</td>
<td><code>std::string value = m[1];</code></td>
</tr>
<tr>
<td><code>begin()</code> / <code>end()</code></td>
<td>返回指向第一个元素和最后一个元素之后位置的迭代器</td>
<td><code>for (auto it = m.begin(); it != m.end(); ++it)</code></td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
<td><code>size_t size = m.size();</code></td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>检查容器是否为空</td>
<td><code>bool isEmpty = m.empty();</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空所有元素</td>
<td><code>m.clear();</code></td>
</tr>
<tr>
<td><code>emplace(key, value)</code></td>
<td>插入键值对，如果键已存在则不插入</td>
<td><code>m.emplace(4, &quot;four&quot;);</code></td>
</tr>
<tr>
<td><code>count(key)</code></td>
<td>返回指定键的元素个数（0或1）</td>
<td><code>size_t count = m.count(2);</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><code>set</code>可以理解成<code>key</code>和<code>value</code>均相等的<code>map</code>。其余的性质和<code>map</code>都类似，只是在<code>map</code>中存储的是键值对，而在<code>set</code>中存储的是<code>key</code>。</p>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(value)</code></td>
<td>插入元素</td>
<td><code>s.insert(10);</code></td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>移除指定位置的元素</td>
<td><code>s.erase(s.begin());</code></td>
</tr>
<tr>
<td><code>erase(value)</code></td>
<td>移除指定值的元素</td>
<td><code>s.erase(10);</code></td>
</tr>
<tr>
<td><code>find(value)</code></td>
<td>查找元素，返回指向元素的迭代器，不存在则返回 <code>end()</code></td>
<td><code>auto it = s.find(10);</code></td>
</tr>
<tr>
<td><code>count(value)</code></td>
<td>返回元素的数量（<code>set</code> 中只可能为 0 或 1）</td>
<td><code>size_t count = s.count(10);</code></td>
</tr>
<tr>
<td><code>begin()</code> / <code>end()</code></td>
<td>返回指向第一个元素和最后一个元素之后位置的迭代器</td>
<td><code>for (auto it = s.begin(); it != s.end(); ++it)</code></td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
<td><code>size_t size = s.size();</code></td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>检查容器是否为空</td>
<td><code>bool isEmpty = s.empty();</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空所有元素  </td>
</tr>
</tbody>
</table>
</div>
<h2 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h2><p>从命名我们就可以看出，<code>unordered_map</code>是无序的，无序所指的是它的<code>key</code>，当我们需要遍历<code>unordered_map</code>的时候，输出的键值对的顺序是随机的。</p>
<p>在<code>unordered_map</code>的底层是用哈希表来完成的，所以我们在插入，以及查询哈希表中的元素可以在<code>O(1)</code>的时间复杂度以内完成，前提是在哈希冲突较少的情况下。</p>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(&#123;key, value&#125;)</code></td>
<td>插入键值对</td>
<td><code>um.insert(&#123;1, &quot;one&quot;&#125;);</code></td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>移除指定位置的元素</td>
<td><code>um.erase(um.begin());</code></td>
</tr>
<tr>
<td><code>erase(key)</code></td>
<td>移除指定键的元素</td>
<td><code>um.erase(1);</code></td>
</tr>
<tr>
<td><code>find(key)</code></td>
<td>查找键，返回指向键值对的迭代器，不存在则返回 <code>end()</code></td>
<td><code>auto it = um.find(1);</code></td>
</tr>
<tr>
<td><code>operator[](key)</code></td>
<td>访问或插入指定键的元素</td>
<td><code>std::string value = um[1];</code></td>
</tr>
<tr>
<td><code>begin()</code> / <code>end()</code></td>
<td>返回指向第一个元素和最后一个元素之后位置的迭代器</td>
<td><code>for (auto it = um.begin(); it != um.end(); ++it)</code></td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
<td><code>size_t size = um.size();</code></td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>检查容器是否为空</td>
<td><code>bool isEmpty = um.empty();</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空所有元素</td>
<td><code>um.clear();</code></td>
</tr>
<tr>
<td><code>emplace(key, value)</code></td>
<td>插入键值对，如果键已存在则不插入</td>
<td><code>um.emplace(4, &quot;four&quot;);</code></td>
</tr>
<tr>
<td><code>count(key)</code></td>
<td>返回指定键的元素个数（0或1）</td>
<td><code>size_t count = um.count(2);</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h2><p><code>unordered_set</code>是<code>C++</code>中的无序容器，它存储唯一的元素，并且以无序的方式进行组织。底层实现是基于哈希表，因此插入和查找元素的时间复杂度是常数级别的。</p>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(value)</code></td>
<td>插入元素</td>
<td><code>us.insert(10);</code></td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>移除指定位置的元素</td>
<td><code>us.erase(us.begin());</code></td>
</tr>
<tr>
<td><code>erase(value)</code></td>
<td>移除指定值的元素</td>
<td><code>us.erase(10);</code></td>
</tr>
<tr>
<td><code>find(value)</code></td>
<td>查找元素，返回指向元素的迭代器，不存在则返回 <code>end()</code></td>
<td><code>auto it = us.find(10);</code></td>
</tr>
<tr>
<td><code>count(value)</code></td>
<td>返回元素的数量（<code>unordered_set</code> 中只可能为 0 或 1）</td>
<td><code>size_t count = us.count(10);</code></td>
</tr>
<tr>
<td><code>begin()</code> / <code>end()</code></td>
<td>返回指向第一个元素和最后一个元素之后位置的迭代器</td>
<td><code>for (auto it = us.begin(); it != us.end(); ++it)</code></td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
<td><code>size_t size = us.size();</code></td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>检查容器是否为空</td>
<td><code>bool isEmpty = us.empty();</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空所有元素</td>
<td><code>us.clear();</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="unordered-set-1"><a href="#unordered-set-1" class="headerlink" title="unordered_set"></a>unordered_set</h2><p><code>unordered_set</code>是<code>C++</code>中的无序容器，它存储唯一的元素，并且以无序的方式进行组织。底层实现是基于哈希表，因此插入和查找元素的时间复杂度是常数级别的。</p>
<p><strong>常用的接口</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
<th>示例代码</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>insert(value)</code></td>
<td>插入元素</td>
<td><code>us.insert(10);</code></td>
</tr>
<tr>
<td><code>erase(iterator)</code></td>
<td>移除指定位置的元素</td>
<td><code>us.erase(us.begin());</code></td>
</tr>
<tr>
<td><code>erase(value)</code></td>
<td>移除指定值的元素</td>
<td><code>us.erase(10);</code></td>
</tr>
<tr>
<td><code>find(value)</code></td>
<td>查找元素，返回指向元素的迭代器，不存在则返回 <code>end()</code></td>
<td><code>auto it = us.find(10);</code></td>
</tr>
<tr>
<td><code>count(value)</code></td>
<td>返回元素的数量（<code>unordered_set</code> 中只可能为 0 或 1）</td>
<td><code>size_t count = us.count(10);</code></td>
</tr>
<tr>
<td><code>begin()</code> / <code>end()</code></td>
<td>返回指向第一个元素和最后一个元素之后位置的迭代器</td>
<td><code>for (auto it = us.begin(); it != us.end(); ++it)</code></td>
</tr>
<tr>
<td><code>size()</code></td>
<td>返回元素个数</td>
<td><code>size_t size = us.size();</code></td>
</tr>
<tr>
<td><code>empty()</code></td>
<td>检查容器是否为空</td>
<td><code>bool isEmpty = us.empty();</code></td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清空所有元素</td>
<td><code>us.clear();</code></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用GDB进行调试</title>
    <url>/2024/07/11/gdb-debug/</url>
    <content><![CDATA[<h1 id="如何使用GDB调试"><a href="#如何使用GDB调试" class="headerlink" title="如何使用GDB调试"></a>如何使用GDB调试</h1><p>GDB (全称为GNU Debuger) 是一款由 GNU 开源组织发布、基于 UNIX/LINUX 操作系统的命令行程序调试工具。对于一名 Linux 下工作的 C++ 程序员，GDB 是必不可少的工具。<br>Linux下工作的程序员都习惯用命令行开发，所以这种命令行调试工具并不会觉得难用；其次，基于 Linux 服务器等的无图形界面开发，使用 Vim+GDB 可以在任意一台电脑上直接调试，不用花时间安装复杂的 IDE 环境。</p>
<h2 id="GDB常见调试命令"><a href="#GDB常见调试命令" class="headerlink" title="GDB常见调试命令"></a>GDB常见调试命令</h2><p>1、启动GDB</p>
<blockquote>
<p>对于 C/C++ 程序调试，需要在编译前加入 -g 参数选项，表示加入一些调试信息。这样在编译后生成的可执行文件才能使用 GDB 进行调试。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">g++ -g main -o demo // 生成可执行文件<br><br>gdb demo // 启动GDB调试<br></code></pre></td></tr></table></figure>
<p>2、相关命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">// 查看接下来的10行<br>list<br><br>// 打断点<br><span class="hljs-built_in">break</span> n<br><span class="hljs-built_in">break</span> file:n<br><span class="hljs-built_in">break</span> func // 在函数入口<br><br>// 查看断点<br>info <span class="hljs-built_in">break</span><br><br>// 删除断点<br>delete    // 所有<br>delete n    // 删除第n个断点<br><span class="hljs-built_in">disable</span> n    // 关闭<br><span class="hljs-built_in">enable</span>    // 开启<br><br><br>// 运行控制指令<br>run  // 全速运行，遇到断点会停下，run 可以用 r 缩写替代<br>next // 单步调试，next 可以用 n 缩写替代<br>step // 单步调试，step 可以用 s 缩写替代<br><span class="hljs-built_in">continue</span> // 继续执行直到遇到下一个断点停下，没有断点直接结束，可以用 c 缩写替代<br><span class="hljs-keyword">until</span> n  // 直接跳转到指定行号程序，n 表示行号<br>finish   // 当程序运行在函数中时，直接执行完当前函数并打印函数返回信息<br><span class="hljs-built_in">kill</span>  // 直接结束当前进程，程序可以从头运行<br>quit  // 退出 GDB，quit 可以用 q 缩写替代<br><br>// 打印变量x信息<br><span class="hljs-built_in">print</span> x<br><br>// 显示当前堆栈帧的局部变量的名称和值<br>info locals<br>// 显示当前函数的参数<br>info args<br>// 显示所有全局和静态变量的名称和值，可能会比较多<br>info variables<br>// 查看某个特定类型的所有实例<br>info variables int/string<br>// 查看复杂表达式，数组结构体等<br><span class="hljs-built_in">print</span> myStruct.fileName<br><span class="hljs-built_in">print</span> myArray[3]<br></code></pre></td></tr></table></figure>
<h2 id="打印vector"><a href="#打印vector" class="headerlink" title="打印vector"></a>打印vector</h2><p>打印整个 vector：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">print</span> myVector<br></code></pre></td></tr></table></figure>
<p>打印特定的元素：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">print</span> myVector[0]<br></code></pre></td></tr></table></figure>
<p>手动打印<code>std::vector</code>的元素<code>std::vector</code>的数据通常是连续存储的，可以根据其内部表示来查看元素。以下是一个例子，使用指向开始和结束的指针（取决于<code>std::vector</code>在你的<code>STL</code>实现中的具体布局）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">// n小于size<br><span class="hljs-built_in">print</span> *myVector._M_impl._M_start@n<br></code></pre></td></tr></table></figure>
<p>这里，<code>_M_impl._M_start</code>是 GCC 的 <code>libstdc++</code> 实现细节，它可能因不同版本的 <code>STL</code> 或不同编译器而异。也就是说，如果使用的是别的库比如 LLVM’s libc++，那么内部成员名可能会有不同。</p>
<p>在上面的命令中：</p>
<ul>
<li>myVector 是 vector 变量的名称。</li>
<li>_M_impl._M_start 是 vector 内部的起始元素指针（对于 libstdc++）。</li>
<li>@ 操作符是 GDB 的一个功能，它允许按照数组的语法打印从某个指针开始的一系列对象。</li>
<li>myVector.size() 是 vector 的大小，告诉 GDB 应该打印多少个元素。</li>
</ul>
<p>如果不确定 vector 内部结构的话，你可以先打印出 vector 对象自身来探索它的内部结构：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">print</span> myVector<br></code></pre></td></tr></table></figure>
<p>然后根据显示的结构信息来适配上面的命令。</p>
<p><strong>注</strong>： 如果程序使用了优化编译选项（比如 <code>-O2</code>），编译器可能会省略掉一些调试信息或改变代码的布局。如果发现 <code>GDB</code> 无法获取 <code>vector</code> 的正确信息，需要在没有优化的情况下重新编译程序。</p>
<h2 id="字符串打印不全的问题"><a href="#字符串打印不全的问题" class="headerlink" title="字符串打印不全的问题"></a>字符串打印不全的问题</h2><p>在<code>GDB</code>中，我们如果尝试打印一个长字符串时，默认情况下，不会显示完整的字符串，而是在输出一定的长度以后用省略号<code>...</code>截断。</p>
<img src="/2024/07/11/gdb-debug/gdb_01.png" class="" title="gdb_01">
<p>如果我们想要显示打印出字符串的完整内容。我们需要修改<code>GDB</code>的打印设置</p>
<ul>
<li><code>set print elements 0</code></li>
</ul>
<p>这样我们就能看到完整的字符串了。</p>
<img src="/2024/07/11/gdb-debug/gdb_02.png" class="" title="gdb_02">]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>GDB</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习-基本语法</title>
    <url>/2024/07/10/go-base/</url>
    <content><![CDATA[<h1 id="Go语言学习-基本语法"><a href="#Go语言学习-基本语法" class="headerlink" title="Go语言学习-基本语法"></a>Go语言学习-基本语法</h1><h2 id="GO语言特性"><a href="#GO语言特性" class="headerlink" title="GO语言特性"></a>GO语言特性</h2><ul>
<li><p>并发编程</p>
<p>Go语言中引入了<code>goroutine</code>，通过调用<code>go</code>关键字，可以让函数以goroutine的方式进行运行，以协程为单位进行运行。</p>
<p>协程相比线程更加轻量级，也更节省系统资源。</p>
<p>goroutine内部采用管道<code>channel</code>进行消息传递，从而实现共享内存。</p>
</li>
<li><p>错误处理</p>
<p>函数通过返回错误类型<code>error</code>或者<code>bool</code>类型表明函数执行结果，通过判断返回值是否为<code>nil</code>。</p>
<p>引入了defer关键字用于标准的错误处理流程，提供内置函数<code>panic</code>，<code>recover</code>完成异常抛出和捕捉</p>
</li>
<li><p>垃圾回收</p>
<p>自带自动回收功能，不需要<code>delete</code>和<code>free</code>来释放内存</p>
</li>
<li><p>多返回值</p>
<p>支持多返回值，可以用下划线作为占用符丢掉不要的返回值</p>
</li>
<li><p>匿名函数</p>
<p>支持常规的匿名函数和闭包</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// hello.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">//导入fmt包，调用其中的Println()函数</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello，world！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li><p>常量</p>
<p>使用<code>const</code>声明，可以限定常量类型，也可以不指定类型（称为字面常量）</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> limit = <span class="hljs-number">512</span><br><span class="hljs-keyword">const</span> top <span class="hljs-type">uint16</span> = <span class="hljs-number">1421</span><br><span class="hljs-keyword">const</span> Pi <span class="hljs-type">float64</span> = <span class="hljs-number">3.1415926</span><br><span class="hljs-comment">// 多重赋值</span><br><span class="hljs-keyword">const</span> x,y <span class="hljs-type">int</span> = <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br><br><span class="hljs-comment">// 多个常量赋值</span><br><span class="hljs-keyword">const</span> (<br>	one = <span class="hljs-number">1</span><br>	two = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure>
<ul>
<li><p>iota</p>
<p><code>iota</code>是一个可以被编译器修改的常量，在<code>const</code>关键字出现时被重置为<code>0</code>，在下一个<code>const</code>出现之前，每出现一次<code>iota</code>，所代表的数字自动加1</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//a == 0</span><br>    b = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//b ==1</span><br>    c = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c == 2</span><br>)<br><br><span class="hljs-keyword">const</span> d = <span class="hljs-literal">iota</span> <span class="hljs-comment">//d==0,因为const的出现，iota被重置为0</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>变量</p>
<p>变量使用<code>var</code>进行声明，可以使用<code>:=</code>对变量之间进行初始化，Go编译器会自动推导出该变量的类型</p>
</li>
<li><p>整型</p>
<p>可以通过<code>unsafe.Sizeof</code>函数来查看字节长度</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>byte</code></td>
<td style="text-align:left">等同于 uint8，uint8的别名</td>
</tr>
<tr>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left">依赖于不同平台下的实现，可以是 int32 或者 int64</td>
</tr>
<tr>
<td style="text-align:left"><code>int8</code></td>
<td style="text-align:left">[-128, 127]</td>
</tr>
<tr>
<td style="text-align:left"><code>int16</code></td>
<td style="text-align:left">[-32768, 32767]</td>
</tr>
<tr>
<td style="text-align:left"><code>int32</code></td>
<td style="text-align:left">[-2147483648, 2147483647]</td>
</tr>
<tr>
<td style="text-align:left"><code>int64</code></td>
<td style="text-align:left">[-9223372036854775808, 9223372036854775807]</td>
</tr>
<tr>
<td style="text-align:left"><code>rune</code></td>
<td style="text-align:left">等同于 int32，代表Unicode字符类型</td>
</tr>
<tr>
<td style="text-align:left"><code>uint</code></td>
<td style="text-align:left">依赖于不同平台下的实现，可以是 uint32 或者 uint64</td>
</tr>
<tr>
<td style="text-align:left"><code>uint8</code></td>
<td style="text-align:left">[0, 255]</td>
</tr>
<tr>
<td style="text-align:left"><code>uint16</code></td>
<td style="text-align:left">[0, 65535]</td>
</tr>
<tr>
<td style="text-align:left"><code>uint32</code></td>
<td style="text-align:left">[0, 4294967295]</td>
</tr>
<tr>
<td style="text-align:left"><code>uint64</code></td>
<td style="text-align:left">[0, 18446744073709551615]</td>
</tr>
<tr>
<td style="text-align:left"><code>uintptr</code></td>
<td style="text-align:left">一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64）</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>浮点类型</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>float32</td>
<td>±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数</td>
</tr>
<tr>
<td>float64</td>
<td>±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数</td>
</tr>
<tr>
<td>complex32</td>
<td>复数，实部和虚部都是 float32</td>
</tr>
<tr>
<td>complex64</td>
<td>复数，实部和虚部都是 float64</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>布尔类型</p>
<p><code>true</code>和<code>false</code>：布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。</p>
</li>
<li><p>字符串</p>
<ul>
<li><p>字符串可以使用双引号<code>(&quot;&quot;)</code>或者反引号来创建。双引号用来创建可解析的字符串字面量，可解析的是指字符串中的一些符号可以被格式化为其他内容，如 <code>\n</code> 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。</p>
</li>
<li><p>支持切片操作：对字符串中字符依次访问，可以使用 <code>range</code> 操作符。获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。</p>
</li>
</ul>
<p>支持的操作</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s += t</code></td>
<td>将字符串 t 追加到 s 末尾</td>
</tr>
<tr>
<td><code>s + t</code></td>
<td>将字符串 s 和 t 级联</td>
</tr>
<tr>
<td><code>s[n]</code></td>
<td>从字符串 s 中索引位置为 n 处的原始字节</td>
</tr>
<tr>
<td><code>s[n:m]</code></td>
<td>从位置 n 到位置 <code>m-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>s[n:]</code></td>
<td>从位置 n 到位置 <code>len(s)-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>s[:m]</code></td>
<td>从位置 0 到位置 <code>m-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>len(s)</code></td>
<td>字符串 s 中的字节数</td>
</tr>
<tr>
<td><code>len([]rune(s))</code></td>
<td>字符串 s 中字符的个数，可以使用更快的方法 <code>utf8.RuneCountInString()</code></td>
</tr>
<tr>
<td><code>[]rune(s)</code></td>
<td>将字符串 s 转换为一个 unicode 值组成的串</td>
</tr>
<tr>
<td><code>string(chars)</code></td>
<td>chars 类型是 <code>[]rune</code> 或者 <code>[]int32</code>, 将之转换为字符串</td>
</tr>
<tr>
<td><code>[]byte(s)</code></td>
<td>无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节</td>
</tr>
</tbody>
</table>
</div>
<h2 id="顺序编程"><a href="#顺序编程" class="headerlink" title="顺序编程"></a>顺序编程</h2><ul>
<li><p>if</p>
<p><code>if</code>后面可以紧接一个表达式<code>optionalStatement1</code>，表达式会在进入<code>block</code>前执行，决定进入<code>block</code>分支的是布尔表达式<code>booleanExpression1</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> optionalStatement1; booleanExpression1 &#123;<br>    block1<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> optionalStatement2; booleanExpression2 &#123;<br>    block2<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    block3<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>for</p>
<p><code>for</code>循环可以遍历数组，切片，映射等类型，也可以用于无限循环</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// 无限循环</span><br>    block<br>&#125;<br><br><span class="hljs-keyword">for</span> booleanExpression &#123; <span class="hljs-comment">// while循环，在Go语言中没有while关键字</span><br><br>&#125;<br><br><span class="hljs-keyword">for</span> index, char := <span class="hljs-keyword">range</span> aString &#123; <span class="hljs-comment">// 迭代字符串</span><br><br>&#125;<br><br><span class="hljs-keyword">for</span> item := <span class="hljs-keyword">range</span> aChannel &#123; <span class="hljs-comment">// 迭代通道</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>goto</p>
<p><code>goto</code>可以实现跳转，在程序代码前定义一个标签以后可以使用goto跳转到标签</p>
</li>
<li><p>switch</p>
</li>
</ul>
<p><strong>类型处理</strong></p>
<ul>
<li><p>类型转换</p>
</li>
<li><p>类型断言</p>
<p>将空接口类型转化为我们所需要的类型，这个操作称为类型断言。（有点难懂）</p>
</li>
</ul>
<p><strong>defer</strong></p>
<ul>
<li>当函数执行到最后时，<code>defer</code>语句会按照逆序执行，最后该函数返回，<code>defer</code>会在<code>return</code>之后执行。</li>
</ul>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言学习-函数、方法、接口</title>
    <url>/2024/07/09/go-function/</url>
    <content><![CDATA[<h1 id="函数-function"><a href="#函数-function" class="headerlink" title="函数-function"></a>函数-function</h1><p><code>Go</code>语言中，函数的命名定义需要<code>func</code>来作为唯一标识，并且使用首字母大小写来区分，在当前文件夹下的某一个函数是否可以通过<code>import bag</code>的方式来对其他文件的可见性，如果是大写则说明可以导入，小写则只能在当前文件内可见。</p>
<p>函数通过四个属性来唯一确定函数签名-函数名、形参列表、返回值列表、函数体。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(parameter-list)</span></span> (result-list) &#123;<br>    body<br>&#125;<br></code></pre></td></tr></table></figure>
<p><em>多返回值</em></p>
<p>在<code>Go</code>中，一个函数可以返回多个值，并且函数的返回值必须要有变量来接收，如果我们不需要某一个返回值，通常我们会用<code>_</code>下划线来接收这个返回值，作为接收某一个返回值的占位符。</p>
<p>我们通常想要保留函数运行过程中的某一些局部变量的结果，或者想要拥有多个返回变量，比较常见的方法就是，定义一个全局变量，并把变量作为引用类型传入到函数内，这样的方式可以达到效果，但是会有参数列表冗余的现象，如果我们需要保留的局部变量的参数非常多，那么也需要定义多个参数来一一完成。</p>
<p>使用多返回值可以更清晰的表达结果，避免全局变量定义的冗余，以及引用传入的冗余，我们可以将局部变量返回，并在全局中定义接收。</p>
<p>使用多返回值的另一个好处就是错误的处理更加方便，通常我们会将错误作为函数的最后一个返回值。这允许调用者很容易地判断操作是否成功，而不必单独检查错误变量或异常。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span><span class="hljs-params">(dividend, divisor <span class="hljs-type">float64</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">if</span> divisor == <span class="hljs-number">0.0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>, errors.New(<span class="hljs-string">&quot;cannot divide by zero&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> dividend / divisor, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h2><p>在<code>Go</code>中，函数被看作第一类值（第一类值意思就是说明这一个值可以像基本数据类型一样使用），具体来说：被赋值给变量、作为参数传递给函数、作为函数的返回值、在运行时动态创建、被存储在数据结构中。</p>
<p>函数类型的零值是<code>nil</code>，调用值为<code>nil</code>的函数会引起<code>panic</code>错误，而且函数可以与<code>nil</code>进行比较。但是函数与函数之间时不可以比较的，也不能使用函数值作为<code>map</code>的<code>key</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">square</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> n * n &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">negative</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> -n &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">product</span><span class="hljs-params">(m, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> m * n &#125;<br><br>f := square<br>fmt.Println(f(<span class="hljs-number">3</span>)) <span class="hljs-comment">// &quot;9&quot;</span><br><br>f = negative<br>fmt.Println(f(<span class="hljs-number">3</span>))     <span class="hljs-comment">// &quot;-3&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, f) <span class="hljs-comment">// &quot;func(int) int&quot;</span><br><br>f = product <span class="hljs-comment">// compile error: can&#x27;t assign func(int, int) int to func(int) int</span><br></code></pre></td></tr></table></figure>
<p>函数值使得我们不仅仅可以通过数据来参数化函数，也可以通过行为。</p>
<blockquote>
<p><code>strings.Map()</code>是一个高阶函数，它允许你对字符串中的每个字符执行一个指定的映射操作。这个函数接受两个参数：第一个参数是一个映射函数，此映射函数会被应用到字符串中的每个字符上；第二个参数是要进行操作的字符串。映射函数需要接收一个rune类型的值，并返回一个rune类型的值。如果映射函数返回负值，则该字符会从结果字符串中被删除。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add1</span><span class="hljs-params">(r <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">rune</span> &#123; <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span> &#125;<br><br>fmt.Println(strings.Map(add1, <span class="hljs-string">&quot;HAL-9000&quot;</span>)) <span class="hljs-comment">// &quot;IBM.:111&quot;</span><br>fmt.Println(strings.Map(add1, <span class="hljs-string">&quot;VMS&quot;</span>))      <span class="hljs-comment">// &quot;WNT&quot;</span><br>fmt.Println(strings.Map(add1, <span class="hljs-string">&quot;Admix&quot;</span>))    <span class="hljs-comment">// &quot;Benjy&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>参数数量可变的函数称为可变参数函数。在<code>go</code>中一般通过<code>...</code>的形式来接收任意数量的参数，比如使用<code>vals ...int</code>接收任意数量的<code>int</code>类型参数。我们可以通过切片的方式来读取参数列表里面实际的值。在实际的运行过程中，调用者会隐式的创建一个数组，并将原始参数复制到数组当中，再把数组的一个切片作为参数传给被调用的函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(vals ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>        total += val<br>    &#125;<br>    <span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><ul>
<li><p>Defferred函数</p>
<p>  <code>defer</code>机制类似于延迟执行的感觉，在我们的代码当中，可能会因为打开某一些文件，但是由于打开失败或者一些其他的原因，导致我们的执行异常退出，或者提前退出，这个时候要确保能够让文件正常关闭，我们可以使用<code>defer</code>来在文件关闭语句前标记，这样子，即使异常退出，在函数返回前也会执行<code>defer</code>的语句，通常<code>defer</code>修饰的语句执行顺序和定义的顺序相反。</p>
</li>
<li><p>Panic异常</p>
<p>  <code>Go</code>的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起<code>panic</code>异常。</p>
<p>  一般来说，当<code>panic</code>异常发生时，程序会中断运行，并立即执行在该协程中的被延迟的<code>defer</code>函数，随后输出错误日志。通常会在发生严重错误的时候来使用。</p>
</li>
<li><p>Recover捕获异常</p>
<p>  在<code>Go</code>语言中，异常捕获是通过内置的<code>recover</code>函数实现的。当一个<code>goroutine</code>发生<code>panic</code>时，你可以使用<code>defer</code>机制来确保调用<code>recover</code>，这样就能拦截到<code>panic</code>引起的异常并进行处理。</p>
<p>  <code>recover</code>只有在<code>defer</code>延迟执行的函数中直接调用时才有效。如果<code>panic</code>被触发，<code>recover</code>会捕获到引发<code>panic</code>的值，并且恢复正常的程序执行流程，即不再继续向上传递<code>panic</code>，转而执行<code>recover</code>所在的<code>defer</code>之后的代码。如果没有发生<code>panic</code>，或者<code>recover</code>没有在适当的位置被调用，则<code>recover</code>返回<code>nil</code>。</p>
  <figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">potentiallyPanic</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;something went wrong&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">catchPanic</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">if</span> r := <span class="hljs-built_in">recover</span>(); r != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Recovered from panic:&quot;</span>, r)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 使用 defer 语句注册 catchPanic 函数</span><br>    <span class="hljs-comment">// 它将在 main 函数返回前最后执行</span><br>    <span class="hljs-keyword">defer</span> catchPanic()<br><br>    <span class="hljs-comment">// 这个函数可能会触发 panic</span><br>    potentiallyPanic()<br><br>    <span class="hljs-comment">// 这行代码不会被执行，因为上面的函数已经触发了 panic</span><br>    fmt.Println(<span class="hljs-string">&quot;This line will not be executed.&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="方法-way"><a href="#方法-way" class="headerlink" title="方法-way"></a>方法-way</h1><blockquote>
<p>在函数声明时，在函数的名字之前放上一个变量，这个函数就会变成一个方法，这一个附加的参数会将该函数附加到这种类型上，也就是说，我们为这一个类型定义了独占的方法。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geometry<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">float64</span> &#125;<br><br><span class="hljs-comment">// traditional function</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Distance</span><span class="hljs-params">(p, q Point)</span></span> <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br><br><span class="hljs-comment">// 同样的效果，但是我们把Distance函数定义在了Point类型的内部</span><br><span class="hljs-comment">// 因为在Point内部，我们可以直接的访问Point的内部成员</span><br><span class="hljs-comment">// 我们可以使用Point.Distance来调用这个方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br>    <span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>基于指针对象的方法</p>
<p>当我们调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免这种默认的拷贝，我们可以使用指针。在实际的运用中，我们一般会约定，如果<code>Point</code>这一个类有一个指针作为接收器的方法，那么所有的<code>Point</code>的方法都必须有一个指针接收器。</p>
<p>具体的使用方法就是，我们使用指针作为接收器，并且使用对象的引用来作为方法的调用者</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br>    p.X *= factor<br>    p.Y *= factor<br>&#125;<br><br><span class="hljs-comment">// 使用引用调用</span><br>r := &amp;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>r.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(*r) <span class="hljs-comment">// &quot;&#123;2, 4&#125;&quot;</span><br><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>pptr := &amp;p<br>pptr.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p) <span class="hljs-comment">// &quot;&#123;2, 4&#125;&quot;</span><br><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>(&amp;p).ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p) <span class="hljs-comment">// &quot;&#123;2, 4&#125;&quot;</span><br><br><span class="hljs-comment">// 引用的符号也可以省略</span><br><span class="hljs-comment">// 因为编译器会隐式的帮我们使用&amp;p去调用这个方法，不过这种简写方法只适用于变量（可以取到地址的变量）</span><br>p.ScaleBy(<span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 临时变量则无法编译完成</span><br>Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.ScaleBy(<span class="hljs-number">2</span>) <span class="hljs-comment">// compile error: can&#x27;t take address of Point literal</span><br><br></code></pre></td></tr></table></figure>
<h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口-interface"></a>接口-interface</h1><blockquote>
<p>接口类型是对其他类型行为的抽象和概括，因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。在<code>C++</code>中，通常会使用面向对象多态的特性通过定义抽象类的方式来完成.</p>
</blockquote>
<p>在<code>Go</code>中是使用接口类型来实现的，接口类型是一种抽象的类型，它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合，它只会表现出它自己的方法。我们只知道通过这个接口来做什么事情。</p>
<p>如果我们定义了一个接口，并在这个接口中定义了一些抽象的方法，如果我们有其他的结构体或者类型的数据，实现了这个接口中的所有抽象方法，那么接口和这个结构体就满足接口的合约，我们就可以使用接口来接收这个结构体，并调用对应的方法，就类似于<code>C++</code>中抽象类和子类的关系。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInterface <span class="hljs-keyword">interface</span> &#123;<br>    Method1(param1 <span class="hljs-type">int</span>) <span class="hljs-type">string</span><br>    Method2() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> ConcreteType <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ct ConcreteType)</span></span> Method1(param1 <span class="hljs-type">int</span>) <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-comment">// 实现逻辑...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ct ConcreteType)</span></span> Method2() <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 实现逻辑...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 具体调用</span><br><span class="hljs-keyword">var</span> myVar MyInterface = ConcreteType&#123;&#125;<br>result := myVar.Method1(<span class="hljs-number">123</span>)<br>err := myVar.Method2()<br><span class="hljs-comment">// 处理 result 和 err</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2024/06/26/design-model/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote>
<p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的代码编写经验。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
</blockquote>
<h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h2 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h2><blockquote>
<p>工厂模式是一种创建对象的方式，类似于利用统一工厂类去创建不同的对象，这样就能够让创建对象的过程和使用对象的过程进行分离。</p>
</blockquote>
<img src="/2024/06/26/design-model/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_01.png" class="" title="工厂模式_01">
<ul>
<li><p>简单工厂模式</p>
<p>  根据工厂类传入的参数来决定创建哪种类型的对象</p>
</li>
<li><p>工厂方法模式</p>
<p>  定义一个创建对象的接口，但由子类来决定实例化哪一个类，将对象的创建延迟到子类</p>
<p>  不同的产品类继承于同一个抽象产品基类，同时为每一个产品类分配一个单独的创建类，创建类继承于创建基类，创建基类中有一个用于接收产品基类返回值的抽象方法，所有的创建类会重新这个方法，并在这个方法中，创建对应的产品对象，返回给产品基类接收。</p>
<p>  在创建基类中，同时会定义一个接口方法，这个方法的实现会先通过抽象方法先创建出一个产品抽象类，并调用产品抽象类中的抽象方法，就能够达到统一调用子类方法的目的。</p>
<p>  在实际使用中，用户只需要知道创建抽象类以及抽象类中的方法即可，当我们需要使用某一个产品的时候，我们只需要通过使用创建基类的指针指向一个某一个产品的创建子类的对象，通过调用创建基类中的方法就可以完成对应的功能。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 产品基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Product</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result of the ConcreteProductA&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result of the ConcreteProductB&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建者基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Creator</span>() &#123;&#125;<br>    <span class="hljs-comment">// 工厂方法，用于创建产品对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product* <span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建者类的业务逻辑</span><br>    <span class="hljs-function">std::string <span class="hljs-title">SomeOperation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 调用工厂方法来创建一个产品对象</span><br>        <span class="hljs-function">std::unique_ptr&lt;Product&gt; <span class="hljs-title">product</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;FactoryMethod())</span></span>;<br>        <span class="hljs-comment">// 使用产品</span><br>        std::string result = <span class="hljs-string">&quot;Creator: The same creator&#x27;s code has just worked with &quot;</span> + product-&gt;<span class="hljs-built_in">Operation</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体创建者A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreatorA</span> : <span class="hljs-keyword">public</span> Creator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Product* <span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductA</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体创建者B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreatorB</span> : <span class="hljs-keyword">public</span> Creator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Product* <span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductB</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> Creator&amp; creator)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client: I&#x27;m not aware of the creator&#x27;s class, but it still works.\n&quot;</span><br>            &lt;&lt; creator.<span class="hljs-built_in">SomeOperation</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;Creator&gt; creator = std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteCreatorA&gt;();<br>    <span class="hljs-built_in">ClientCode</span>(*creator);<br><br>    std::cout &lt;&lt; std::endl;<br>    <br>    creator = std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteCreatorB&gt;();<br>    <span class="hljs-built_in">ClientCode</span>(*creator);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>抽象工厂模式</p>
  <img src="/2024/06/26/design-model/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_02.png" class="" title="工厂模式_02">
<p>  提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类</p>
<p>  我们可以看出来工厂方法模式只关注某一类产品的构建，但是我们可以通过对抽象产品的继承来丰富这一类产品的类型。如果我们有多类产品的话，那就需要用到抽象工厂了。</p>
<p>  因为我们有多类产品，所以我们会定义多个产品的抽象基类，这些产品基类会由多个产品子类来继承生成不同产品，在子类中会分别实现不同产品基类的抽象方法，如果我们需要在不同的产品类中进行通信的话，我们的抽象产品基类中应该还有一个能够将另一个产品基类作为形参传入的方法，在我们的具体产品中重写这一个方法。</p>
<p>  同样我们会有一个抽象工厂，抽象工厂中会有创建不同产品的方法，这些方法都是以抽象产品基类指针作为返回值接收。抽象工厂子类会实现这些方法，它们可以选择性的去创建不同的产品子类，只需要实现对应的抽象产品方法即可，也就是说一个工厂是有可能可以创建多类产品的，尤其是当这些产品需要进行交互的时候。</p>
<p>  下面的例子便是在具体工厂中实现多个产品的创建，当然我们只想让一个工厂对应某一类产品的话，我们只需要在对应的抽象方法中，返回<code>nullptr</code>就好了。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 抽象产品A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProductA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractProductA</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">UsefulFunctionA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 抽象产品B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProductB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractProductB</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">UsefulFunctionB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 抽象方法，示例产品B能够与产品A进行交互</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">AnotherUsefulFunctionB</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractProductA&amp; collaborator)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品A1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA1</span> : <span class="hljs-keyword">public</span> AbstractProductA &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">UsefulFunctionA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the product A1.&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品A2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA2</span> : <span class="hljs-keyword">public</span> AbstractProductA &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">UsefulFunctionA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the product A2.&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品B1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB1</span> : <span class="hljs-keyword">public</span> AbstractProductB &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">UsefulFunctionB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the product B1.&quot;</span>;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">AnotherUsefulFunctionB</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractProductA&amp; collaborator)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">const</span> std::string result = collaborator.<span class="hljs-built_in">UsefulFunctionA</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the B1 collaborating with ( &quot;</span> + result + <span class="hljs-string">&quot; )&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品B2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB2</span> : <span class="hljs-keyword">public</span> AbstractProductB &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">UsefulFunctionB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the product B2.&quot;</span>;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">AnotherUsefulFunctionB</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractProductA&amp; collaborator)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">const</span> std::string result = collaborator.<span class="hljs-built_in">UsefulFunctionA</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the B2 collaborating with ( &quot;</span> + result + <span class="hljs-string">&quot; )&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 抽象工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractFactory</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;AbstractProductA&gt; <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;AbstractProductB&gt; <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span> : <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::unique_ptr&lt;AbstractProductA&gt; <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteProductA1&gt;();<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;AbstractProductB&gt; <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteProductB1&gt;();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory2</span> : <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::unique_ptr&lt;AbstractProductA&gt; <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteProductA2&gt;();<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;AbstractProductB&gt; <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteProductB2&gt;();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractFactory&amp; factory)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> product_a = factory.<span class="hljs-built_in">CreateProductA</span>();<br>    <span class="hljs-keyword">auto</span> product_b = factory.<span class="hljs-built_in">CreateProductB</span>();<br>    std::cout &lt;&lt; product_b-&gt;<span class="hljs-built_in">UsefulFunctionB</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; product_b-&gt;<span class="hljs-built_in">AnotherUsefulFunctionB</span>(*product_a) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client: Testing client code with the first factory type:\n&quot;</span>;<br>    ConcreteFactory1 f1;<br>    <span class="hljs-built_in">ClientCode</span>(f1);<br><br>    std::cout &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client: Testing the same client code with the second factory type:\n&quot;</span>;<br>    ConcreteFactory2 f2;<br>    <span class="hljs-built_in">ClientCode</span>(f2);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h2><blockquote>
<p>单例模式是一种比较常见的设计模式，在应用中十分广泛，在使用过程中用于确保一个对象中只有一个实例，并且会为这个实例提供一个全局访问点。在我们实际应用中，经常会用于一些控制资源共享的场景中，比如日志记录。因为只存在一个实例，所以需要考虑到这个实例在多线程的情况下资源竞争的问题。</p>
</blockquote>
<img src="/2024/06/26/design-model/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F_01.png" class="" title="单例模式_01">
<p>在我们的单例模式实际应用中，通常会提供一个统一的静态全局访问方法，方法名一般叫做<code>getinstance()</code>，用于获取当前单例的实例对象，而我们会根据单例的创建时机将单例模式分为两种，懒汉式和饿汉式。</p>
<ul>
<li><p>懒汉式</p>
<p>  懒汉式单例模式，指的是在我的当前工作进程中，不一定程序启动以后，单例跟着也同样进行实例化，而是只有当我们需要用到这一个单例的时候才会对这个单例进行实例化，具体的实现过程就是把单例的实例化代码写入到<code>getinstance()</code>函数中，当我们第一次调用到<code>getinstance()</code>的时候，我们会实例化这一个单例。</p>
<p>  我们会把<code>instance</code>权限设置为私有，并且提供一个静态方法，用于创建并返回单例。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有静态指针变量，用于持有类的唯一实例</span><br>    <span class="hljs-type">static</span> LazySingleton* instance;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 受保护的构造函数，防止外部通过 new 创建实例</span><br>    <span class="hljs-built_in">LazySingleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 删除拷贝构造函数和赋值操作符</span><br>    <span class="hljs-built_in">LazySingleton</span>(<span class="hljs-type">const</span> LazySingleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    LazySingleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> LazySingleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 在类中提供公共的静态方法来获取实例</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> LazySingleton* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 检查是否为空</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LazySingleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>  我们可以看到在单线程的情况下，这样的代码是没有问题的，但是如果是多线程的环境下，如果我们有多个线程同时到达<code>GetInstance</code>这个函数，那么就存在有多次创建这个单例的风险，违背了我们单例模式的初衷。</p>
<p>  很显然，我们可以通过加锁来完成不同线程创建多个单例的风险规避。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-type">static</span> std::mutex mutex;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>; <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::mutex Singleton::mutex;<br></code></pre></td></tr></table></figure>
<p>  这样的实现方式我们可以很明显的看出来有一些小问题，就是需要处理多线程之间的同步问题，在上面的实现方式中，无论我的实例是否已经被创建，都需要获取到锁以后才能够进入到后面的代码当中，在实际应用中，我们只有在单例未被创建的时候完成同步就可以了，如果单例已经在进程当中，那我们直接返回这个单例就行。</p>
<p>  所以，我们有了另一种实现方式</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-type">static</span> std::mutex mutex;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 第一次检查，如果单例已经存在，不需要加锁直接返回单例</span><br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>; <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 第二次检查，只有当单例不存在的时候，才会确保只有一个线程创建了单例</span><br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::mutex Singleton::mutex;<br></code></pre></td></tr></table></figure>
</li>
<li><p>饿汉式</p>
<p>  可以看到，我们的主进程在初始化这个单例的时候，我们不像之前一样，把单例初始化为<code>nullptr</code>，而是切切实实的创建了这一个单例，而在我们的<code>GetInstance()</code>方法中会直接返回这一个单例，因为我们的单例已经不可能为空了。</p>
<p>  这样的方式能够避免多个单例的创建，因为创建指挥发生在主进程对类加载的时候，但是牺牲的代价是便是内存的耗费，并且我们不应该提供对这个单例销毁的方法，因为，我们销毁以后想要再次用到这个单例的话，就没有单例创建的入口了。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EagerSingleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 在定义变量的时候就初始化实例</span><br>    <span class="hljs-type">static</span> EagerSingleton instance;<br><br>    <span class="hljs-comment">// 私有构造函数，防止外部通过 new 创建实例</span><br>    <span class="hljs-built_in">EagerSingleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 删除拷贝构造函数和赋值操作符，防止拷贝和赋值</span><br>    <span class="hljs-built_in">EagerSingleton</span>(<span class="hljs-type">const</span> EagerSingleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    EagerSingleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> EagerSingleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例的引用</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> EagerSingleton&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">// 类静态成员变量，在程序开始时即完成初始化</span><br>EagerSingleton EagerSingleton::instance;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、适配器模式"><a href="#三、适配器模式" class="headerlink" title="三、适配器模式"></a>三、适配器模式</h2><blockquote>
<p>适配器可以充当两个不兼容接口之间的桥梁，通过一个中间件，将一个类的接口转换成客户期望的另一个接口，使得原本不能工作的类能够协同工作。</p>
</blockquote>
<img src="/2024/06/26/design-model/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F_01.png" class="" title="适配器模式-01">
<p>适配器模式一般有两种方式来实现，分别是对象适配器模式，和类适配器模式。在对象适配器模式中，适配器类会继承于目标类的接口，并拥有一个需要适配的类的引用，在适配器类中就能够通过引用来调用是需要适配的方法。类适配器模式则是用到的多继承思想，适配器类通过多继承的方式，同时拥有目标类和适配类的方法。</p>
<ul>
<li>对象适配器模式  <figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 目标接口（Target），客户端期望的接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Target: Default behavior.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 被适配的类（Adaptee），拥有一个特殊的请求方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpecificRequest</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Adaptee: Specific request.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 适配器类（Adapter），使 Adaptee 与 Target 接口兼容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> : <span class="hljs-keyword">public</span> Target &#123;<br><span class="hljs-keyword">private</span>:<br>    Adaptee* adaptee;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Adapter</span>(Adaptee* a) : <span class="hljs-built_in">adaptee</span>(a) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        adaptee-&gt;<span class="hljs-built_in">SpecificRequest</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Adaptee* adaptee = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Adaptee</span>();<br>    Target* target = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Adapter</span>(adaptee);<br>    <br>    target-&gt;<span class="hljs-built_in">Request</span>();<br><br>    <span class="hljs-keyword">delete</span> adaptee;<br>    <span class="hljs-keyword">delete</span> target;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、装饰器模式"><a href="#四、装饰器模式" class="headerlink" title="四、装饰器模式"></a>四、装饰器模式</h2><img src="/2024/06/26/design-model/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F_01.png" class="" title="装饰器模式-01">
<p>通常我们在需要在不改变某一个类的功能的前提下为这个类提供新的拓展功能和方法的时候，我们会考虑的一种方式是通过对象的继承，在子类中写一些新的方法，这样子就能够通过使用子类来达到拓展父类功能的目的。而使用继承的方式，我们通常在编译的时候就确定了子类的相关行为。与此同时，如果一个父类存在有多个可能的变化方向，那么我们就需要通过继承的方式实现每一种组合，这样子无疑会使得我们子类的数量呈指数型暴增。</p>
<p>在这样的背景下，我们有了装饰器模式的产生。装饰器可以独立存在，更加灵活，能够动态地扩展对象的功能并且可以通过组合的方式将多个装饰应用在对象上。</p>
<p>装饰器模式通常涉及以下几个角色：</p>
<ul>
<li>Component：定义一个对象接口，可以给这些对象动态地添加职责。</li>
<li>ConcreteComponent：定义了一个具体的对象，也可以给这个对象添加一些额外的职责。</li>
<li>Decorator：持有一个组件（Component）对象的实例，并定义一个与组件接口一致的接口。</li>
<li>ConcreteDecorator：具体的装饰类，实现了在组件的接口中定义的操作，并添加新的操作，以给组件对象增加额外的职责。</li>
</ul>
<p>我们会使用一个装饰器类继承于抽象基类，并在这个装饰器类中持有一个基类的指针对象，在实现基类的方法的时候，通过这一个指针来调用其他具体子类实体的方法。同时我们会有另一个类继承于这一个装饰器类，我们可以叫做拓展装饰器类，在我们的拓展装饰器类中，我们可以拓展具体子类的新功能。这个功能的拓展可以包裹在原始功能的前后，类似于附加一个行为层。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// &quot;Component&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// &quot;ConcreteComponent&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Shape: Circle&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Shape: Rectangle&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// &quot;Decorator&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeDecorator</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">protected</span>:<br>    Shape* decoratedShape;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ShapeDecorator</span>(Shape* shape) : <span class="hljs-built_in">decoratedShape</span>(shape) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        decoratedShape-&gt;<span class="hljs-built_in">draw</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ShapeDecorator</span>() &#123;<br>        <span class="hljs-keyword">delete</span> decoratedShape;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// &quot;ConcreteDecorator&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedShapeDecorator</span> : <span class="hljs-keyword">public</span> ShapeDecorator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RedShapeDecorator</span>(Shape* decoratedShape) : <span class="hljs-built_in">ShapeDecorator</span>(decoratedShape) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ShapeDecorator::<span class="hljs-built_in">draw</span>();<br>        <span class="hljs-built_in">setRedBorder</span>(decoratedShape);   <span class="hljs-comment">// 附加的行为</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setRedBorder</span><span class="hljs-params">(Shape* decoratedShape)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Border Color: Red&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Shape* circle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br>    Shape* redCircle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RedShapeDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>());<br>    Shape* redRectangle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RedShapeDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Rectangle</span>());<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Circle with normal border:&quot;</span> &lt;&lt; std::endl;<br>    circle-&gt;<span class="hljs-built_in">draw</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nCircle of red border:&quot;</span> &lt;&lt; std::endl;<br>    redCircle-&gt;<span class="hljs-built_in">draw</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nRectangle of red border:&quot;</span> &lt;&lt; std::endl;<br>    redRectangle-&gt;<span class="hljs-built_in">draw</span>();<br><br>    <span class="hljs-keyword">delete</span> circle;<br>    <span class="hljs-keyword">delete</span> redCircle;<br>    <span class="hljs-keyword">delete</span> redRectangle;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="五、享元模式"><a href="#五、享元模式" class="headerlink" title="五、享元模式"></a>五、享元模式</h2><blockquote>
<p>享元模式主要用于减少创建对象的数量，用于减少内存占用和提高性能。享元模式会尝试重用现有的同类对象，如果我们找到了这个对象，那么就会对这个对象进行返回，如果未找这个对象，才会重新申请一个新的对象。主要目的是支持大量的细粒度对象，这些对象中有相当部分的状态可以共享。通过共享，可以在有限的内存资源下支持大规模的对象数量。</p>
</blockquote>
<img src="/2024/06/26/design-model/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F_01.png" class="" title="享元模式-01">
<p>在我们的使用过程中，通常享元模式需要定义享元抽象类，抽象类中会有子类需要共享的方法和属性，并且通过子类继承抽象类，实现对应的抽象方法，我们的子类也会拥有属于子类的独有的属性和方法。</p>
<p>同时，我们会定义一个享元工厂，享元工厂负责创建和管理享元对象，管理的方式通常使用<code>HashMap</code>哈希表的映射来完成，如果需要创建某一个对象的<code>key</code>已经存在，则说明这个对象已经存在在内存当中，可以作为享元对象直接返回，当在哈希表中找不到<code>key</code>时，才会新建一个新的对象。</p>
<p>在我们的客户端只需要维护对享元对象的引用，并计算或存储享元对象的外部状态即可。外部状态指的是，客户端用于标识具体对象的一些标志。所以在使用的过程中，应该注意的是要明确区分内部状态和外部状态，实现状态分离，以免混淆。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 享元接口类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Character</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体享元类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCharacter</span> : <span class="hljs-keyword">public</span> Character &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> glyph; <span class="hljs-comment">// 内部状态：字符本身</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCharacter</span>(<span class="hljs-type">char</span> argGlyph) : <span class="hljs-built_in">glyph</span>(argGlyph) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying character: &quot;</span> &lt;&lt; glyph &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 享元工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterFactory</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::map&lt;<span class="hljs-type">char</span>, Character*&gt; characters; <span class="hljs-comment">// 缓存已创建的享元对象</span><br>    <br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">CharacterFactory</span>() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : characters) &#123;<br>            <span class="hljs-keyword">delete</span> pair.second;<br>        &#125;<br>        characters.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <br>    <span class="hljs-function">Character* <span class="hljs-title">getCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (characters.<span class="hljs-built_in">find</span>(key) == characters.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// 如果字符不存在，则创建一个新的ConcreteCharacter并加入映射中</span><br>            characters[key] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteCharacter</span>(key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> characters[key];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 客户端代码</span><br>    CharacterFactory factory;<br><br>    <span class="hljs-comment">// 创建几个字符对象</span><br>    Character* characterA = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    Character* characterB = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>    Character* characterA2 = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;A&#x27;</span>); <span class="hljs-comment">// 再次请求&#x27;A&#x27;，应该得到相同的实例</span><br><br>    <span class="hljs-comment">// 显示字符</span><br>    characterA-&gt;<span class="hljs-built_in">display</span>();<br>    characterB-&gt;<span class="hljs-built_in">display</span>();<br>    characterA2-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-comment">// 检查两个‘A’是否相同</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Are the two &#x27;A&#x27; instances the same? &quot;</span> &lt;&lt; (characterA == characterA2 ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 不需要手动删除字符对象，因为由CharacterFactory管理</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="六、责任链模式"><a href="#六、责任链模式" class="headerlink" title="六、责任链模式"></a>六、责任链模式</h2><blockquote>
<p>责任链模式为请求创建了一个接收者对象的链，它允许多个对象来处理一个请求，而无需发送者知道接收者的具体信息。请求在一系列接收者对象之间传递直到被处理，每一个接收者持有下一个接收者的引用，这样接收者就形成了一条链，并且每个链上的对象将决定自己能否处理请求或者应该将请求传递给链上的下一个对象。</p>
</blockquote>
<p>责任链模式主要解决的问题是解耦发送者和接收者，使得多个对象都有可能接收请求，而发送者不需要知道哪个对象会处理它。就好像我们的发送者只需要将需要处理的请求丢给<code>handle</code>责任链上，而无需在意最后的请求是谁处理的一样，这样可以简化对象之间的连接，达到解耦的目的。</p>
<p>我们会定义一个抽象处理类，在这个处理类中会拥有一个指向下一个处理类的指针，并使用接口完成责任链的构建，我们责任链上的不同任务会通过传入的不同参数来进行标识。</p>
<p>在我们的抽象处理类中，会有一个处理请求的抽象方法，这个方法是用于遍历责任链的，如果我们的子处理类无法处理当前的请求时，我们会调用下一个处理类来完成这个请求的处理。</p>
<p>使用这样的责任链方式，我们可以减少请求方和具体实现方的耦合，我们可以发现这样的设计模式能够很好的满足设计模式中的依赖倒置原则，请求方和实现方都依赖的是抽象接口而不各自依赖。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 抽象处理器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::shared_ptr&lt;Handler&gt; next_handler;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Handler</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(std::shared_ptr&lt;Handler&gt; handler)</span> </span>&#123;<br>        next_handler = handler;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (next_handler) &#123;<br>            next_handler-&gt;<span class="hljs-built_in">handleRequest</span>(request);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体处理器类A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandlerA</span> : <span class="hljs-keyword">public</span> Handler &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (request &lt; <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 可以处理小于10的请求</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Handler A is handling request: &quot;</span> &lt;&lt; request &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_handler) &#123;<br>            next_handler-&gt;<span class="hljs-built_in">handleRequest</span>(request);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体处理器类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandlerB</span> : <span class="hljs-keyword">public</span> Handler &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (request &gt;= <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 可以处理大于等于10的请求</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Handler B is handling request: &quot;</span> &lt;&lt; request &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_handler) &#123;<br>            next_handler-&gt;<span class="hljs-built_in">handleRequest</span>(request);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> handlerA = std::<span class="hljs-built_in">make_shared</span>&lt;ConcreteHandlerA&gt;();<br>    <span class="hljs-keyword">auto</span> handlerB = std::<span class="hljs-built_in">make_shared</span>&lt;ConcreteHandlerB&gt;();<br>    <br>    handlerA-&gt;<span class="hljs-built_in">setNext</span>(handlerB); <span class="hljs-comment">// 设置责任链</span><br>    <br>    <span class="hljs-comment">// 发出请求</span><br>    handlerA-&gt;<span class="hljs-built_in">handleRequest</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 将由HandlerA处理</span><br>    handlerA-&gt;<span class="hljs-built_in">handleRequest</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 将由HandlerB处理</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="七、代理模式"><a href="#七、代理模式" class="headerlink" title="七、代理模式"></a>七、代理模式</h2><blockquote>
<p>代理模式通过引入一个代理对象来控制原对象的访问。代理对象在客户端和目标对象之间充当中介，负责将客户端的请求转发给目标对象，同时可以在转发请求前后进行额外的处理，比如安全控制，延迟初始化，远程通信，记录日志等。</p>
</blockquote>
<p>代理模式实际上就是在客户端和实际服务对象之间建立一个中介层，用于在请求被送达给服务对象之前或之后执行某些操作</p>
<p>在我们的代理类中，会继承于抽象类，并拥有一个具体类的实例，如果我们想要在真实类的某一个接口的前后添加譬如日志之类的额外处理，我们可以在代理类中实现抽象类中的接口，并在这个接口的前后添加对应的功能。</p>
<ul>
<li><p>问题一、代理模式和适配器模式的区别</p>
<p>  代理模式，实现的是对另一个对象（原始被代理的对象）的控制访问，可以添加一些额外的功能，但是不应该改变原始对象的行为和功能。</p>
<p>  适配器模式，适用于连接两个不兼容的接口，涉及到两类对象，通常会由适配器继承于一个对象，并拥有另一个对象的实例，在使用适配器进行适配的时候，通过修改所继承的接口方法来调用到被适配对象的行为，即把原接口适配成另一个客户想要的接口。</p>
</li>
<li><p>问题二、代理模式和装饰器模式的区别</p>
<p>  代理模式主要用于控制对资源的访问，通常只有一个代理类，而装饰器模式旨在不改变对象的接口的情况下，为对象添加行为，可以使用多个装饰器来增强对象的功能。</p>
<p>  代理模式通常在编译时就确定了，它管理对象的生命周期并可以进行一些特定的任务，如懒加载、权限控制等；而装饰器可以在运行时递归地将装饰层嵌套起来，以此在不改变原始对象代码的基础上增强对象的行为。</p>
<p>  代理模式关注于对对象的控制，例如为远程对象提供本地代理的过程中可能会处理网络通信、线程同步等问题；装饰器模式关注于增加对象的新功能，强调的是扩展对象的行为。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 抽象主题类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Subject</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 真实主题类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> : <span class="hljs-keyword">public</span> Subject &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;RealSubject: Handling request.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> : <span class="hljs-keyword">public</span> Subject &#123;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;RealSubject&gt; real_subject;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkAccess</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 检查访问权限的逻辑</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Proxy: Checking access prior to firing a real request.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 假设访问权限得到了验证</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAccess</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 日志记录的逻辑</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Proxy: Logging the time of request.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Proxy</span>(std::shared_ptr&lt;RealSubject&gt; real_subject) : <span class="hljs-built_in">real_subject</span>(real_subject) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">checkAccess</span>()) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;real_subject-&gt;<span class="hljs-built_in">request</span>(); <span class="hljs-comment">// 调用真实主题的方法</span><br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">logAccess</span>(); <span class="hljs-comment">// 记录请求日志</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> real_subject = std::<span class="hljs-built_in">make_shared</span>&lt;RealSubject&gt;();<br>    <span class="hljs-function">Proxy <span class="hljs-title">proxy</span><span class="hljs-params">(real_subject)</span></span>;<br>    <br>    proxy.<span class="hljs-built_in">request</span>(); <span class="hljs-comment">// 客户端使用代理完成工作</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="八、观察者模式"><a href="#八、观察者模式" class="headerlink" title="八、观察者模式"></a>八、观察者模式</h2><blockquote>
<p>观察者模式定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知，并自动更新，主要用于分布式事件处理系统、消息发布/订阅机制，以及各种需要对象间解耦的场景。关键在于主题和观察者之间不直接进行通信，而是通过注册和通知机制进行交互。</p>
</blockquote>
<p>观察者模式通常包含几个核心角色</p>
<ul>
<li>主题：它是具有状态的对象，并维护这一个观察这列表。一般我们主题会提供添加、删除和通知观察者的方法</li>
<li>观察者：观察者是接收主题通知的对象。观察者会实现一个更新方法，当我们收到主题的通知时，会调用该方法进行更新操作</li>
<li>具体主题：具体主题时主题的具体实现类，会维护具体主题需要通知的观察者列表，并且在状态发生改变的时候通知观察者</li>
<li>具体观察者：具体观察者是观察者的具体实现类。不同的观察者可能会实现各自的更新方法，方法中会定义收到主题通知时要执行的具体操作</li>
</ul>
<p>在我们使用的时候，基本逻辑就是，主题维护一个观察者列表，我们需要关注这个主题的观察者通过主题的实例对象来进行注册，注册到对应的主题当中，在我们的主题中会通过实现<code>notify</code>的方法，主动的调用观察者的更新函数。</p>
<p>比较常见的场景就是<code>ros</code>的发布与订阅机制，订阅的节点通过订阅来将自己加入到具体的主题当中，当有主题到来的时候，就是状态触发的过程，就会通知各个订阅者进行相应的操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span>;<br><br><span class="hljs-comment">// Observer接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Observer</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Subject* subject)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// Subject接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::list&lt;Observer*&gt; observers; <span class="hljs-comment">// 观察者列表</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Subject</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 注册观察者</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer* obs)</span> </span>&#123;<br>        observers.<span class="hljs-built_in">push_back</span>(obs);<br>    &#125;<br><br>    <span class="hljs-comment">// 注销观察者</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer* obs)</span> </span>&#123;<br>        observers.<span class="hljs-built_in">remove</span>(obs);<br>    &#125;<br><br>    <span class="hljs-comment">// 通知所有注册的观察者</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; observer : observers) &#123;<br>            observer-&gt;<span class="hljs-built_in">update</span>(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取状态（必须由具体的主题实现）</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体的Subject实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> : <span class="hljs-keyword">public</span> Subject &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string state;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 设置新状态并通知观察者</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; newState)</span> </span>&#123;<br>        state = newState;<br>        <span class="hljs-built_in">notify</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 覆盖getState方法</span><br>    <span class="hljs-function">std::string <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体的Observer实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> : <span class="hljs-keyword">public</span> Observer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Subject* subject)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (subject) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Observer received a new state: &quot;</span> &lt;&lt; subject-&gt;<span class="hljs-built_in">getState</span>() &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建主题和观察者</span><br>    ConcreteSubject* concreteSubject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteSubject</span>();<br>    Observer* observer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteObserver</span>();<br>    Observer* observer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteObserver</span>();<br><br>    <span class="hljs-comment">// 注册观察者</span><br>    concreteSubject-&gt;<span class="hljs-built_in">attach</span>(observer1);<br>    concreteSubject-&gt;<span class="hljs-built_in">attach</span>(observer2);<br><br>    <span class="hljs-comment">// 改变状态并通知观察者</span><br>    concreteSubject-&gt;<span class="hljs-built_in">setState</span>(<span class="hljs-string">&quot;state1&quot;</span>);<br><br>    <span class="hljs-comment">// 注销一个观察者并再次改变状态</span><br>    concreteSubject-&gt;<span class="hljs-built_in">detach</span>(observer1);<br>    concreteSubject-&gt;<span class="hljs-built_in">setState</span>(<span class="hljs-string">&quot;state2&quot;</span>);<br><br>    <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-keyword">delete</span> observer1;<br>    <span class="hljs-keyword">delete</span> observer2;<br>    <span class="hljs-keyword">delete</span> concreteSubject;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="九、策略模式"><a href="#九、策略模式" class="headerlink" title="九、策略模式"></a>九、策略模式</h2><p>策略模式可以定义一系列的算法行为，并且把它们封装起来，提供给客户一定的自由度，能够使它们进行互相替换，策略模式允许算法独立于使用它们的客户端的变化。</p>
<img src="/2024/06/26/design-model/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F_01.png" class="" title="策略模式-01">
<p>在C++中我们会定义一个抽象策略基类，不同的策略会继承于这个抽象类，并重写基类中需要进行策略呼唤的方法。</p>
<p>在我们客户端需要使用策略的对象当中，会有一个抽象策略基类的指针，用于引用到子类的不同策略对象实例。通过不同的策略实例的调用就能够在我们客户端用到不同的方法了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// std::sort</span></span><br><br><span class="hljs-comment">// Strategy Interface</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortingStrategy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dataset)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SortingStrategy</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// Concrete Strategy A: Bubble Sort</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> : <span class="hljs-keyword">public</span> SortingStrategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dataset)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">bool</span> swapped = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (swapped) &#123;<br>            swapped = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; dataset.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span> (dataset[i - <span class="hljs-number">1</span>] &gt; dataset[i]) &#123;<br>                    std::<span class="hljs-built_in">swap</span>(dataset[i - <span class="hljs-number">1</span>], dataset[i]);<br>                    swapped = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Concrete Strategy B: Standard Library Sort</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StdSort</span> : <span class="hljs-keyword">public</span> SortingStrategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dataset)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::<span class="hljs-built_in">sort</span>(dataset.<span class="hljs-built_in">begin</span>(), dataset.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Context</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortedList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_items;<br>    SortingStrategy* m_strategy;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SortedList</span>(SortingStrategy* strategy) : <span class="hljs-built_in">m_strategy</span>(strategy) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_strategy</span><span class="hljs-params">(SortingStrategy* strategy)</span> </span>&#123;<br>        m_strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        m_items.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span> </span>&#123;<br>        m_strategy-&gt;<span class="hljs-built_in">sort</span>(m_items);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : m_items) &#123;<br>            std::cout &lt;&lt; item &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">SortedList</span>() &#123;<br>        <span class="hljs-keyword">delete</span> m_strategy;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Client Code</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; dataset = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// Use BubbleSort</span><br>    SortedList* bubble_sorted_list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SortedList</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">BubbleSort</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : dataset) &#123;<br>        bubble_sorted_list-&gt;<span class="hljs-built_in">add</span>(value);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bubble Sorted: &quot;</span>;<br>    bubble_sorted_list-&gt;<span class="hljs-built_in">sort</span>();<br>    <span class="hljs-keyword">delete</span> bubble_sorted_list;<br><br>    <span class="hljs-comment">// Use StdSort</span><br>    SortedList* std_sorted_list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SortedList</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StdSort</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : dataset) &#123;<br>        std_sorted_list-&gt;<span class="hljs-built_in">add</span>(value);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Std Sorted: &quot;</span>;<br>    std_sorted_list-&gt;<span class="hljs-built_in">sort</span>();<br>    <span class="hljs-keyword">delete</span> std_sorted_list;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考链接：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">菜鸟教程</a></p>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>UML</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>C++优先队列用法</title>
    <url>/2024/03/06/c-priority-queue/</url>
    <content><![CDATA[<h2 id="C-优先队列用法"><a href="#C-优先队列用法" class="headerlink" title="C++优先队列用法"></a>C++优先队列用法</h2><p>优先队列是C++中STL的派生容器，它仅考虑最高优先级元素，队列遵循FIFO策列，而优先队列根据优先级弹出元素，优先级最高的元素首先弹出。</p>
<p>函数原型：<code>priority_queue&lt;Type, Container, Functional&gt; m_queue;</code></p>
<p>Type：表示数据类型</p>
<p>Container：表示容器类型（必须是用数组实现的容器，比如vector，deque等）</p>
<p>Functional：表示比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 升序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><span class="hljs-comment">// 降序队列</span><br>priority_queue &lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, less&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><br><span class="hljs-comment">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为）</span><br></code></pre></td></tr></table></figure>
<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p><code>bool empty() const</code> ：返回值为true，说明队列为空</p>
<p><code>int size() const</code> ：返回优先队列中元素的数量</p>
<p><code>void pop()</code> ：删除队列顶部的元素，也即根节点</p>
<p><code>int top()</code> ：返回队列中的顶部元素，但不删除该元素</p>
<p><code>void push(int arg)</code>：将元素arg插入到队列之中</p>
<h3 id="使用仿函数重载，自定义function参数"><a href="#使用仿函数重载，自定义function参数" class="headerlink" title="使用仿函数重载，自定义function参数"></a>使用仿函数重载，自定义function参数</h3><p>小于是升序，大于是降序</p>
<blockquote>
<p>set集合，sort排序方法，也可以自定义仿函数进行比较</p>
<p><code>set&lt;int, compare&gt; my_set</code>，<code>sort(vec.begin(), vec.end(), compare)</code></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> size;<br>    <span class="hljs-type">int</span> price;<br>&#125;;<br><br><span class="hljs-comment">// 在类中重载，（）只能重载在类里面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmp</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 大于表示降序，小于表示升序</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Node &amp;a, <span class="hljs-type">const</span> Node &amp;b)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.size == b.size ? a.price &gt; b.price : a.size &lt; b.size;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    priority_queue&lt;Node, vector&lt;Node&gt;, Cmp&gt; priorityQueue;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        priorityQueue.<span class="hljs-built_in">push</span>(Node&#123;i, <span class="hljs-number">5</span> - i&#125;);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!priorityQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        Node top = priorityQueue.<span class="hljs-built_in">top</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;size:&quot;</span> &lt;&lt; top.size &lt;&lt; <span class="hljs-string">&quot; price:&quot;</span> &lt;&lt; top.price &lt;&lt; endl;<br>        priorityQueue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>C++多线程编程</title>
    <url>/2024/03/03/thread-pool/</url>
    <content><![CDATA[<h2 id="C-11多线程编程"><a href="#C-11多线程编程" class="headerlink" title="C++11多线程编程"></a>C++11多线程编程</h2><h3 id="C-11-Thread线程库的基本用法"><a href="#C-11-Thread线程库的基本用法" class="headerlink" title="C++11 Thread线程库的基本用法"></a>C++11 Thread线程库的基本用法</h3><blockquote>
<p>进程：运行中的程序，线程：进程中的进程</p>
<p>一个操作系统可以有多个进程，一个进程中可以有多个线程，线程的最大数量取决于电脑CPU的核数</p>
</blockquote>
<p>导入头文件thread</p>
<ul>
<li>创建线程    <code>thread th(function, arg)</code></li>
</ul>
<p>创建线程需要绑定一个函数，function表示已经定义的函数名，通过arg可以传入函数的参数，线程在std标准库当中</p>
<p>创建线程对函数加引用<code>&amp;</code>和不加引用的区别</p>
<p>当线程需要执行的函数中需要使用引用传递参数时，在主线程中传入变量值，程序将无法通过编译，需要使用<code>std::ref</code>来确保引用传递</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x)</span> </span>&#123;<br>    <span class="hljs-comment">// 现在x确实是主线程中x的引用</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 编译报错</span><br>    <span class="hljs-comment">// std::thread t(threadFunction, x)</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(threadFunction, std::ref(x))</span></span>; <span class="hljs-comment">// 使用std::ref来确保引用传递</span><br>    t.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-comment">// 现在主线程的x可能会被子线程修改</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>join</code>和<code>detach</code></li>
</ul>
<p>join：调用此接口，当前线程会一直阻塞，直到目标线程完成，如果目标线程十分耗时，主线程会一直阻塞。让主线程等待其他线程结束以后才结束。</p>
<p><code>detach</code>：让目标线程称为守护线程（daemon threads）。一旦detach之后，目标线程将独立执行，即便其对应的thread对象销毁也不影响线程的执行，并且，无法再与其通信</p>
<p>可以通过<code>joinable()</code>接口查询是否可以对接口进行join和detach</p>
<h3 id="互斥量解决多线程数据共享问题"><a href="#互斥量解决多线程数据共享问题" class="headerlink" title="互斥量解决多线程数据共享问题"></a>互斥量解决多线程数据共享问题</h3><p>当一个资源需要被多个线程进行使用并修改的时候，就会存在资源的冲突</p>
<p>下面的函数线程<code>t</code>和<code>t2</code>都需要对变量<code>a</code>进行1000000次的自增操作，因为线程的并行操作，所以两个线程在进行取a的值的时候，有可能获取到同样的值，再次写回时，原本需要+2最终只完成了+1，或者运行较快的线程的写入值会被运行较慢的线程覆盖，这就导致了结果会小于原来预期的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_function</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)<br>    &#123;<br>        a += <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(thread_function, std::ref(a))</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(thread_function, std::ref(a))</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    std::cout&lt;&lt;a&lt;&lt;std::endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2024/03/03/thread-pool/image-20240303195554869.png" class="" title="image-20240303195554869">
<p>这个情况就需要两个线程对a进行互斥使用，用到<code>mutex</code></p>
<p>在需要对资源<code>a</code>进行访问的前后，分别进行加锁和解锁，确保这一段临界区只由一个线程访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-comment">// 互斥信号量</span><br>std::mutex m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_function</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">// 加锁</span><br>        m.<span class="hljs-built_in">lock</span>();<br>        a += <span class="hljs-number">1</span>;<br>        m.<span class="hljs-built_in">unlock</span>();<br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(thread_function, std::ref(a))</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(thread_function, std::ref(a))</span></span>;<br><br>    t.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br><br>    std::cout&lt;&lt;a&lt;&lt;std::endl;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2024/03/03/thread-pool/image-20240303200213188.png" class="" title="image-20240303200213188">
<h3 id="lock-guard与unique-lock"><a href="#lock-guard与unique-lock" class="headerlink" title="lock_guard与unique_lock"></a>lock_guard与unique_lock</h3><ul>
<li>lock_guard</li>
</ul>
<p>lock_guard是一种互斥量封装类，用于保护共享数据，防止多个线程同时访问统一资源而导致数据竞争问题</p>
<p>当构造函数被调用时，该互斥量会被自动锁定</p>
<p>当析构函数被调用时，该互斥量会自动解锁</p>
<p>该对象不能复制或移动，只能在局部作用域中使用</p>
<p>使用到的就是RAII思想</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">std::mutex m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_function</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lg</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-comment">// m.lock();</span><br>        a += <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 不需要对锁释放，当作用域结束自动释放</span><br>        <span class="hljs-comment">// m.unlock();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>unique_lock，构造函数会自动加锁，传入<code>std::defer_lock</code>后会延迟加锁</li>
</ul>
<p>unique_lock是一个互斥量封装类，用于在多线程中对互斥量进行加锁和解锁操作，特点是，可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等</p>
<p><code>lock()</code>：尝试对互斥量进行加锁，如果当前互斥量被其他线程持有则会阻塞</p>
<p><code>try_lock()</code>L：尝试对互斥量进行加锁，如果被占有则返回false</p>
<p><code>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code>：尝试加锁，如果被占有，则超时以后会释放</p>
<h3 id="std-call-once使用场景"><a href="#std-call-once使用场景" class="headerlink" title="std::call_once使用场景"></a>std::call_once使用场景</h3><p>单例设计模式是一种常见的设计模式，用于确保某个类只能创建一个实例，由于单例实例是全局唯一的，因此在多线程环境中使用单例模式时，需要考虑线程安全的问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Log</span>() &#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Log</span>(<span class="hljs-type">const</span> Log&amp; log) = <span class="hljs-keyword">delete</span>;<br>    Log&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Log&amp; log) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> Log&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">static</span> Log * log = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(!log)&#123;<br>            log = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Log</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> log;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintLog</span><span class="hljs-params">(std::string msg)</span></span>&#123;<br>        std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在多线程的情况下，如果都需要使用到同一个单例，当多个线程同时获取log时，如果此时log都为空，单例就会被多次初始化，违背了单例模式的设计初衷</p>
<p><code>call_once</code>可以确保某个函数指挥被调用一次</p>
<p>call_once只能在线程中使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 原型</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Callable, <span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_once</span><span class="hljs-params">(std::once_flag&amp;flag, Callable&amp;&amp; func, Args&amp;&amp;...args)</span></span>;<br></code></pre></td></tr></table></figure>
<p>对单例模式的修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Log</span>() &#123;&#125;;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 声明一个变量</span><br>    <span class="hljs-type">static</span> std::once_flag once;<br>    <span class="hljs-built_in">Log</span>(<span class="hljs-type">const</span> Log&amp; log) = <span class="hljs-keyword">delete</span>;<br>    Log&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Log&amp; log) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">static</span> Log&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-type">static</span> Log * log = <span class="hljs-literal">nullptr</span>;<br>        <br>        <span class="hljs-comment">// 单次调用</span><br>        std::<span class="hljs-built_in">call_once</span>(once, init);<br>        <span class="hljs-keyword">return</span> log;<br>    &#125;<br>    <span class="hljs-comment">// 封装一个初始化的函数</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!log)&#123;<br>            log = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Log</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintLog</span><span class="hljs-params">(std::string msg)</span></span>&#123;<br>        std::cout &lt;&lt; msg &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="condition-variable使用场景"><a href="#condition-variable使用场景" class="headerlink" title="condition_variable使用场景"></a>condition_variable使用场景</h3><p>使用步骤如下</p>
<ul>
<li><p>创建一个std::condition_variable对象</p>
</li>
<li><p>创建一个互斥锁std::mutex，用来保护共享资源的访问</p>
</li>
<li><p>在需要等待条件变量的地方</p>
<p>使用std::unique_lock&lt; std::mutex &gt;对象锁定互斥锁并调用std::condition_variable::wait_for()或std::condition_variable::wait_until()函数等待条件变量</p>
</li>
<li><p>在其他线程中需要通知等待的线程时，调用std::condition_variable::notify_one()或者std::condition_variable::notify_all()函数通知等待的线程</p>
</li>
</ul>
<p>生产者消费者模型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br>std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>std::condition_variable cv;<br>std::mutex m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Producer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">ul</span><span class="hljs-params">(m)</span></span>;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        cv.<span class="hljs-built_in">notify_one</span>();<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Produced: &quot;</span>&lt;&lt;i&lt;&lt;std::endl;<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">microseconds</span>(<span class="hljs-number">10000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Consumer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">ul</span><span class="hljs-params">(m)</span></span>;<br>        cv.<span class="hljs-built_in">wait</span>(ul, []&#123;<span class="hljs-keyword">return</span> !q.<span class="hljs-built_in">empty</span>();&#125;);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;Consumed: &quot;</span>&lt;&lt;q.<span class="hljs-built_in">front</span>()&lt;&lt;std::endl;<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(Producer)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t2</span><span class="hljs-params">(Consumer)</span></span>;<br><br>    t1.<span class="hljs-built_in">join</span>();<br>    t2.<span class="hljs-built_in">join</span>();<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2024/03/03/thread-pool/image-20240303211229196.png" class="" title="image-20240303211229196">
<h3 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h3><p>维护一个线程数组：可以初始化线程的个数</p>
<p>维护一个任务队列：当前正在进行的任务</p>
<p>线程数组负责从队列取任务，生产者负责从任务队列里加任务（需要提供加任务的接口）</p>
<img src="/2024/03/03/thread-pool/image-20240303214601818.png" class="" title="image-20240303214601818">
<p>构造函数中指定起始线程的个数，初始化线程，每一个线程都在循环的在任务队列里取任务并完成，给用户提供一个接口，不断的往任务队列中添加任务，并且每次添加任务过后会通知一个维护的线程去完成任务</p>
<p>每一次访问tasks和stop变量的时候，这是临界区，都需要进行加锁</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::thread&gt; threads;<br>    std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;<br>    std::condition_variable cv;<br>    std::mutex m;<br>    <span class="hljs-type">bool</span> stop;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，构造一共大小为n的线程池</span><br>    <span class="hljs-comment">// 每一个线程执行的函数是检查tasks是否为空，或者stop是否为true</span><br>    <span class="hljs-comment">// 从tasks中取出任务执行，取任务的时候，和访问stop的时候都需要加锁</span><br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> n) : <span class="hljs-built_in">stop</span>(<span class="hljs-literal">false</span>)&#123;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i )&#123;<br>            threads.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>]&#123;<br>                <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                    std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">ul</span>(m);<br>                    cv.<span class="hljs-built_in">wait</span>(ul, [<span class="hljs-keyword">this</span>]&#123;<br>                        <span class="hljs-keyword">return</span> stop || !tasks.<span class="hljs-built_in">empty</span>();<br>                        &#125;);<br><br>                    <span class="hljs-keyword">if</span>( stop &amp;&amp; tasks.<span class="hljs-built_in">empty</span>() )&#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br><br>                    <span class="hljs-comment">// 使用右值引用，避免拷贝</span><br>                    std::function&lt;<span class="hljs-built_in">void</span>()&gt; <span class="hljs-built_in">task</span>(std::<span class="hljs-built_in">move</span>(tasks.<span class="hljs-built_in">front</span>()));<br>                    tasks.<span class="hljs-built_in">pop</span>();<br>                    ul.<span class="hljs-built_in">unlock</span>();<br>                    <span class="hljs-built_in">task</span>();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数，将stop置为true，然后notify_all</span><br>    <span class="hljs-comment">// 然后join所有的线程</span><br>    ~<span class="hljs-built_in">ThreadPool</span>()&#123;<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">ul</span><span class="hljs-params">(m)</span></span>;<br>            stop = <span class="hljs-literal">true</span>;<br>        &#125;<br>        cv.<span class="hljs-built_in">notify_all</span>();<br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span>&amp; t : threads )&#123;<br>            t.<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加任务，将任务放入tasks中，然后notify_one</span><br>    <span class="hljs-comment">// 用到模板以及多个变量的传参，可以使用通用型函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> F, <span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function">    <span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span>&#123;<br>        <span class="hljs-comment">// 使用std::bind将传入的函数和参数绑定</span><br>        <span class="hljs-comment">// 因为传入的是万能引用，使用forward可以让参数自动选择是右值还是左值引用</span><br>        std::function&lt;<span class="hljs-type">void</span>()&gt; task = std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">ul</span><span class="hljs-params">(m)</span></span>;<br>            tasks.<span class="hljs-built_in">emplace</span>(std::<span class="hljs-built_in">move</span>(task));<br>        &#125;<br>        <span class="hljs-comment">// 通知一个线程执行任务</span><br>        cv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-function">ThreadPool <span class="hljs-title">tp</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i )&#123;<br>        tp.<span class="hljs-built_in">enqueue</span>([i]&#123;<br>            <span class="hljs-comment">// 用printf而不是cout，避免输出混乱</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d is working\n&quot;</span>, i);<br>            std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread %d is done\n&quot;</span>, i);<br>        &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>使用cout输出</li>
</ul>
<p>cout的单个输出是线程安全的，这种线程安全是针对在操作系统层面，即每一次<code>&lt;&lt;</code>的调用都是原子的，但是多个<code>&lt;&lt;</code>进行串联输出的时候，整个表达式并不是原子的，因此在串联输出的过程中，会被其他输出线程打断</p>
<img src="/2024/03/03/thread-pool/image-20240303224717307.png" class="" title="image-20240303224717307">
<ul>
<li>使用printf输出</li>
</ul>
<blockquote>
<p>printf(“Thread %d is working\n”, i);</p>
</blockquote>
<p>使用printf输出则是将串联的输出转化为单一的输出，因此单条语句不会产生混乱，但是多个线程输出还是会产生混乱。</p>
<img src="/2024/03/03/thread-pool/image-20240303224732958.png" class="" title="image-20240303224732958">
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>多线程</tag>
        <tag>并行</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++中gcc/g++的参数详解</title>
    <url>/2024/03/02/gcc-parameters/</url>
    <content><![CDATA[<h2 id="C-C-中gcc-g-的参数详解"><a href="#C-C-中gcc-g-的参数详解" class="headerlink" title="C/C++中gcc/g++的参数详解"></a>C/C++中gcc/g++的参数详解</h2><blockquote>
<p>参考链接：<a href="https://www.runoob.com/w3cnote/gcc-parameter-detail.html">https://www.runoob.com/w3cnote/gcc-parameter-detail.html</a></p>
</blockquote>
<p>GCC（GNU Compiler Collection）和G++分别是GNU（自由和开放源码的操作系统）的C和C++编译器。在执行编译的过程中，总共需要执行4步</p>
<ul>
<li>预处理：预处理器（cpp：C Preprocessor）根据以字符<code>#</code>开头的命令，修改原始的C程序，即将头文件作为当前文件的内容插入到程序文本当中。得到另一个C程序，生成的文件为<code>.i</code>文件</li>
<li>编译：编译器（ccl）将预处理后的文本文件文件<code>.i</code>翻译成文本文件<code>.s</code>文件，即汇编语言</li>
<li>汇编：汇编器（as）将汇编语言翻译成能够供机器识别的机器指令，并保存在<code>.o</code>目标文件中，这是二进制文件</li>
<li>链接：链接器负责链接目标代码，生成可执行文件，如：main中调用的一个函数，则会把那个函数进行链接</li>
</ul>
<h3 id="基本编译参数"><a href="#基本编译参数" class="headerlink" title="基本编译参数"></a>基本编译参数</h3><ul>
<li><code>-o &lt;file&gt;</code>: 指定输出的可执行文件名。如果不使用该参数，默认的输出文件名为<code>a.out</code>。</li>
<li><code>-c</code>: 只编译并生成目标文件（<code>.o</code>文件），不进行链接。</li>
<li><code>-E</code>: 只进行预处理，不进行编译、汇编和链接。</li>
<li><code>-S</code>: 只进行预处理和编译，不进行汇编和链接，生成汇编代码。</li>
<li><code>-x  language</code>: 设置文件所使用的语言，对后缀名无效</li>
<li><code>-pipe</code>: 使用管道代替编译中的临时文件</li>
<li><code>include file</code>: 包含某个文件代码</li>
<li><code>imacros file</code>: 将file文件的宏，拓展到gcc/g++的输入文件，宏定义本身不出现在输入文件中</li>
<li><code>Dmacro</code>: 定义宏</li>
<li><code>-C</code>: 预处理时，不删除注释信息</li>
</ul>
<h3 id="调试和优化信息"><a href="#调试和优化信息" class="headerlink" title="调试和优化信息"></a>调试和优化信息</h3><ul>
<li><code>-g</code>: 生成调试信息。可以用GDB等调试器调试程序。</li>
<li><code>-O&lt;level&gt;</code>: 设置优化级别。<code>&lt;level&gt;</code>可以是0、1、2、3，其中<code>-O0</code>表示不进行优化，<code>-O2</code>和<code>-O3</code>表示更高级别的优化。</li>
<li><code>-Og</code>: 优化生成的代码，但不会干扰调试。</li>
</ul>
<h3 id="警告控制"><a href="#警告控制" class="headerlink" title="警告控制"></a>警告控制</h3><ul>
<li><code>-Wall</code>: 打开几乎所有的警告。</li>
<li><code>-Wextra</code>: 打开额外的警告。</li>
<li><code>-Werror</code>: 把所有的警告当作错误。</li>
</ul>
<h3 id="链接库和路径"><a href="#链接库和路径" class="headerlink" title="链接库和路径"></a>链接库和路径</h3><ul>
<li><code>-l&lt;library&gt;</code>: 链接一个库。例如，使用<code>-lm</code>来链接数学库<code>libm.so</code>。</li>
<li><code>-L&lt;directory&gt;</code>: 添加库文件搜索的目录。</li>
<li><p><code>-I&lt;directory&gt;</code>: 添加头文件搜索的目录。</p>
</li>
<li><p><code>-static</code>: 使用静态链接，不使用动态链接库。编译出来的东西，一般都很大。</p>
</li>
<li><code>-fPIC</code>: 生成位置无关代码，通常用于创建共享库。</li>
<li><code>-share</code>: 尽量使用动态库，生成的文件会较小，但需要系统有动态库。</li>
</ul>
<h3 id="预处理器选项"><a href="#预处理器选项" class="headerlink" title="预处理器选项"></a>预处理器选项</h3><ul>
<li><code>-D&lt;macro&gt;</code>: 定义宏。例如，<code>-DDEBUG</code>会定义宏<code>DEBUG</code>。</li>
<li><code>-U&lt;macro&gt;</code>: 取消宏的定义。</li>
</ul>
<h3 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-ansi</td>
<td style="text-align:left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td>
</tr>
<tr>
<td style="text-align:left">-c</td>
<td style="text-align:left">只编译并生成目标文件。</td>
</tr>
<tr>
<td style="text-align:left">-DMACRO</td>
<td style="text-align:left">以字符串”1”定义 MACRO 宏。</td>
</tr>
<tr>
<td style="text-align:left">-DMACRO=DEFN</td>
<td style="text-align:left">以字符串”DEFN”定义 MACRO 宏。</td>
</tr>
<tr>
<td style="text-align:left">-E</td>
<td style="text-align:left">只运行 C 预编译器。</td>
</tr>
<tr>
<td style="text-align:left">-g</td>
<td style="text-align:left">生成调试信息。GNU 调试器可利用该信息。</td>
</tr>
<tr>
<td style="text-align:left">-IDIRECTORY</td>
<td style="text-align:left">指定额外的头文件搜索路径DIRECTORY。</td>
</tr>
<tr>
<td style="text-align:left">-LDIRECTORY</td>
<td style="text-align:left">指定额外的函数库搜索路径DIRECTORY。</td>
</tr>
<tr>
<td style="text-align:left">-lLIBRARY</td>
<td style="text-align:left">连接时搜索指定的函数库LIBRARY。</td>
</tr>
<tr>
<td style="text-align:left">-m486</td>
<td style="text-align:left">针对 486 进行代码优化。</td>
</tr>
<tr>
<td style="text-align:left">-o FILE</td>
<td style="text-align:left">生成指定的输出文件。用在生成可执行文件时。</td>
</tr>
<tr>
<td style="text-align:left">-O0</td>
<td style="text-align:left">不进行优化处理。</td>
</tr>
<tr>
<td style="text-align:left">-O 或 -O1</td>
<td style="text-align:left">优化生成代码。</td>
</tr>
<tr>
<td style="text-align:left">-O2</td>
<td style="text-align:left">进一步优化。</td>
</tr>
<tr>
<td style="text-align:left">-O3</td>
<td style="text-align:left">比 -O2 更进一步优化，包括 inline 函数。</td>
</tr>
<tr>
<td style="text-align:left">-shared</td>
<td style="text-align:left">生成共享目标文件。通常用在建立共享库时。</td>
</tr>
<tr>
<td style="text-align:left">-static</td>
<td style="text-align:left">禁止使用共享连接。</td>
</tr>
<tr>
<td style="text-align:left">-UMACRO</td>
<td style="text-align:left">取消对 MACRO 宏的定义。</td>
</tr>
<tr>
<td style="text-align:left">-w</td>
<td style="text-align:left">不生成任何警告信息。</td>
</tr>
<tr>
<td style="text-align:left">-Wall</td>
<td style="text-align:left">生成所有警告信息。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编译</tag>
        <tag>GCC</tag>
        <tag>G++</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的排序算法</title>
    <url>/2024/02/21/sort-algrithon/</url>
    <content><![CDATA[<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><blockquote>
<p>输入：整数数组nums</p>
<p>输出： 按照升序排序</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 函数接口</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>思想：每次选择数组当前数组中最小的元素，放置到数组当前未选定的最前的位置</p>
<p>时间复杂度：n^2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; ++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+<span class="hljs-number">1</span>; j &lt; n; ++j)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                std::<span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>思想：</p>
<p>每次比较相邻的元素，如果前面的元素大于后面的元素，则进行交换</p>
<p>当某一轮没有进行交换时，说明数组已经有序</p>
<p>时间复杂度：n^2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 冒泡排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 每一次最大的元素都能够沉到最下面</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n-i<span class="hljs-number">-1</span>; ++j)&#123;<br>            <span class="hljs-keyword">if</span>(nums[j] &gt; nums[j+<span class="hljs-number">1</span>])&#123;<br>                std::<span class="hljs-built_in">swap</span>(nums[j], nums[j+<span class="hljs-number">1</span>]);<br>                flag = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>思想：</p>
<p>从前往后选择元素，插入到前面已经排序好的数组元素当中</p>
<p>始终保证当前元素前半部分都是有序的，直到所有元素遍历完</p>
<p>时间复杂度：n^2</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 插入排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span>; --j)&#123;<br>            <span class="hljs-comment">// 注意比较的是相邻的元素，而不是num[i]</span><br>            <span class="hljs-keyword">if</span>(nums[j+<span class="hljs-number">1</span>] &gt;= nums[j])&#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                std::<span class="hljs-built_in">swap</span>(nums[j+<span class="hljs-number">1</span>], nums[j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>思想：分治法</p>
<p>将长度为n的数组分为两个长度为n/2的数组</p>
<p>继续分为长度为n/4的数组，最后分为长度为1的数组</p>
<p>分别对长度为1的两两数组进行合并</p>
<p>对长度为2的两两数组进行合并</p>
<p>长度为4的两两数组进行合并</p>
<p>最后对长度为n/2的数组进行合并得到的就是长度为n的有序数组</p>
<p><strong>因为合并过程中依赖的小序列都是有序的，通过选择最小元素很容易合并</strong></p>
<p>时间复杂度：nlog(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n1 = mid - left + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> n2 = right - mid;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">L</span><span class="hljs-params">(n1)</span>, <span class="hljs-title">R</span><span class="hljs-params">(n2)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++)<br>        L[i] = nums[left + i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n2; j++)<br>        R[j] = nums[mid + <span class="hljs-number">1</span> + j];<br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = left;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;<br>        <span class="hljs-keyword">if</span> (L[i] &lt;= R[j]) &#123;<br>            nums[k] = L[i];<br>            i++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums[k] = R[j];<br>            j++;<br>        &#125;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (i &lt; n1) &#123;<br>        nums[k] = L[i];<br>        i++;<br>        k++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span> (j &lt; n2) &#123;<br>        nums[k] = R[j];<br>        j++;<br>        k++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">mergeSort</span>(nums, left, mid);<br>        <span class="hljs-built_in">mergeSort</span>(nums, mid + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-built_in">merge</span>(nums, left, mid, right);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>思想：分治法，快排要注意要从right开始</p>
<p>选择一个主元</p>
<p>将小于主元的元素放在左边</p>
<p>将大于主元的元素放在右边</p>
<p>主元的位置则可以确定</p>
<p>分别对主元左边的数组和右边的数组再次进行快速排序</p>
<p>时间复杂度：nlog(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partion</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-type">int</span> value = nums[left];<br>    <span class="hljs-type">int</span> idx = left;<br>    <span class="hljs-comment">// left += 1; left不用+1，相等的情况已经考虑了</span><br>    <br>    <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[right] &gt;= value)right--;<br>        nums[idx] = nums[right];<br>        idx = right;<br>        <span class="hljs-keyword">while</span>(left &lt; right &amp;&amp; nums[left] &lt;= value)left++;<br>        nums[idx] = nums[left];<br>        idx = left;<br>    &#125;<br>    nums[idx] = value;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(left &gt;= right)<span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-type">int</span> mid = <span class="hljs-built_in">partion</span>(nums, left, right);<br>    <span class="hljs-built_in">quicksort</span>(nums, left, mid - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">quicksort</span>(nums, mid+<span class="hljs-number">1</span>, right);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">quicksort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>思想：</p>
<p>将数组看成一棵完全二叉树，按照数组中的元素建立大顶堆</p>
<p>交换堆顶元素和当前最末端元素，此时最大的元素到了数组尾部，锁定位置</p>
<p>对当前堆进行更新</p>
<p>时间复杂度：nlg(n)</p>
<blockquote>
<p>建堆时间为lg(n)</p>
<p>取出元素为1，更新堆为lg(n)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-type">int</span> largest = i;  <span class="hljs-comment">// 初始化最大值为当前节点</span><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 左孩子节点的索引为 2*i + 1</span><br>    <span class="hljs-type">int</span> right = <span class="hljs-number">2</span> * i + <span class="hljs-number">2</span>;  <span class="hljs-comment">// 右孩子节点的索引为 2*i + 2</span><br><br>    <span class="hljs-comment">// 如果左孩子节点比当前节点大</span><br>    <span class="hljs-keyword">if</span> (left &lt; n &amp;&amp; nums[left] &gt; nums[largest])<br>        largest = left;<br><br>    <span class="hljs-comment">// 如果右孩子节点比当前最大值大</span><br>    <span class="hljs-keyword">if</span> (right &lt; n &amp;&amp; nums[right] &gt; nums[largest])<br>        largest = right;<br><br>    <span class="hljs-comment">// 如果最大值不是当前节点</span><br>    <span class="hljs-keyword">if</span> (largest != i) &#123;<br>        <span class="hljs-comment">// 交换当前节点和最大值节点的值</span><br>        <span class="hljs-built_in">swap</span>(nums[i], nums[largest]);<br><br>        <span class="hljs-comment">// 递归地对受影响的子树进行堆化</span><br>        <span class="hljs-built_in">heapify</span>(nums, n, largest);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make_heap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 构建堆（重新排列数组）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-built_in">heapify</span>(nums, n, i);<br>&#125;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">make_heap</span>(nums);<br><br>    <span class="hljs-comment">// 逐个从堆中提取元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 将当前根节点移动到末尾</span><br>        <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[i]);<br><br>        <span class="hljs-comment">// 对减小后的堆进行堆化</span><br>        <span class="hljs-built_in">heapify</span>(nums, i, <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>思想：</p>
<p>使用一定的间隔（数组长度的一半）对数组进行分组，然后对每个分组进行插入排序</p>
<p>随着排序的进行，间隔逐步减小，直到间隔为1，最终完成排序</p>
<p>时间复杂度：n^1.3</p>
<p>设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = arr.<span class="hljs-built_in">size</span>();<br><br>    <span class="hljs-comment">// 初始化间隔gap为数组长度的一半，然后逐步缩小间隔直至为1</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = n / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-comment">// 对每个间隔进行插入排序</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> temp = arr[i];<br>            <span class="hljs-type">int</span> j;<br><br>            <span class="hljs-comment">// 将arr[i]插入到正确的位置</span><br>            <span class="hljs-keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;<br>                arr[j] = arr[j - gap];<br>            &#125;<br>            arr[j] = temp;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-built_in">shellSort</span>(nums);<br>    <span class="hljs-keyword">return</span> nums;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>时间复杂度：n+k，k为当前数组中的最大值</p>
<blockquote>
<p>如果有负数还需要进行另外处理</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">countingSort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到数组中的最大值</span><br>    <span class="hljs-type">int</span> max_num = *std::<span class="hljs-built_in">max_element</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">// 创建计数数组，并初始化为0</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">count</span><span class="hljs-params">(max_num + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-comment">// 统计每个元素出现的次数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        count[num]++;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据计数数组重建排序后的数组</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedArray</span><span class="hljs-params">(nums.size())</span></span>;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= max_num; ++i) &#123;<br>        <span class="hljs-keyword">while</span> (count[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            sortedArray[index++] = i;<br>            count[i]--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sortedArray;<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">countingSort</span>(nums);<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
        <tag>选择排序</tag>
        <tag>冒泡排序</tag>
        <tag>插入排序</tag>
        <tag>归并排序</tag>
        <tag>快速排序</tag>
        <tag>堆排序</tag>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>CMU15445数据库学习笔记01-04</title>
    <url>/2024/02/10/15445-study-notes-01-04/</url>
    <content><![CDATA[<h2 id="01-Relational-Model-amp-Relational-Algebra"><a href="#01-Relational-Model-amp-Relational-Algebra" class="headerlink" title="01-Relational Model &amp; Relational Algebra"></a>01-Relational Model &amp; Relational Algebra</h2><h3 id="数据库基本概念"><a href="#数据库基本概念" class="headerlink" title="数据库基本概念"></a>数据库基本概念</h3><p>数据库管理系统：允许应用在数据库中存储、操作、分析数据信息的一种软件。通常的数据库管理系统（DBMS）支持通过一些数据模型（data model）定义、创建、查询、更新以及数据库的管理工作</p>
<p>数据模型（data model）： 将存储的概念的高级抽象在数据库中，是数据库中描述数据的一种概念集合，能够表明数据的形状、属性等。</p>
<ul>
<li>关系型数据模型：关系型数据库</li>
<li>非关系型模型Nosql：key/value、Graph、Document/Object</li>
<li>矩阵/向量/列表</li>
<li>分层、网络</li>
</ul>
<p>模式（schema）：是一个逻辑概念，用于组织数据库中的对象。模式中的对象通常包括表、索引、数据类型、序列、视图、存储过程、主键、外键等。</p>
<h3 id="关系型模型（Relational-Model）"><a href="#关系型模型（Relational-Model）" class="headerlink" title="关系型模型（Relational Model）"></a>关系型模型（Relational Model）</h3><p>定义了一个数据库抽象层，用于如何替换表示关系以避免数据库维护的开销。</p>
<ul>
<li>三大原则<ul>
<li>存储数据库的简单数据结构</li>
<li>数据库的存储由数据库管理系统来实现，无需用户定义数据的存储形式，例如tree等</li>
<li>允许数据使用高级语言，数据库管理系统产生最优的执行策略</li>
</ul>
</li>
</ul>
<p>关系（table、relation）：包含代表实体属性关系的一种无序集合</p>
<p>元组（tuple）：关系中的属性值表现的集合，值也叫做域（domain）</p>
<p>主键（primary key）：识别唯一元组的方法，是一组关键的属性</p>
<p>外键（foreign key）：允许定义一个关系中的数据如何与另一个关系相关，外键作为一个映射表（交叉引用表）</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li><p>SELECT</p>
<p>从一个关系中通过某些过滤信息选择出元组的子集，条件通常写在where 后面</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240102163927925.png" class="" title="image-20240102163927925">
</li>
<li><p>PROJECTION（投影）</p>
<p>使用数据库中的元组重新生成一个关系，只包含某一些特殊的属性。</p>
<p>把原来的表映射成一个新的表</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240102201317281.png" class="" title="image-20240102201317281">
</li>
<li><p>UNION（联合关系）</p>
<p>UNION ALL：不去重</p>
<p>UNION：去重</p>
<p>联合不同的数据库，但是数据库具有完全相同的属性。</p>
<p>默认情况下并集允许重复性</p>
</li>
<li><p>INTERSECT（交集关系）</p>
<p>两个数据库关系的交集，相同的元组集合</p>
</li>
<li><p>DIFFERENCE（取补集）</p>
<p>语法：EXCEPT</p>
</li>
<li><p>PRODUCT（笛卡尔积）</p>
<p>语法CROSS JOIN</p>
</li>
<li><p>JOIN</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240103093506806.png" class="" title="image-20240103093506806">
</li>
</ul>
<h2 id="02-Modern-SQL"><a href="#02-Modern-SQL" class="headerlink" title="02-Modern SQL"></a>02-Modern SQL</h2><h3 id="AGGREGATES"><a href="#AGGREGATES" class="headerlink" title="AGGREGATES"></a>AGGREGATES</h3><blockquote>
<p>聚合（aggregations）：类似一个在查询中获取一组元组的函数</p>
<p>AVG、MIN、MAX、SUM、COUNT</p>
</blockquote>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240104092359606.png" class="" title="image-20240104092359606">
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student(<br>	sid <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>	<span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>	<span class="hljs-keyword">login</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>	age <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>	gpa <span class="hljs-type">FLOAT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span><br>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> student (sid, <span class="hljs-type">name</span>, <span class="hljs-keyword">login</span>, age, gpa) <span class="hljs-keyword">VALUES</span><br>(<span class="hljs-number">53666</span>, &quot;Kanye&quot;, &quot;kanye@cs&quot;, <span class="hljs-number">44</span>, <span class="hljs-number">4.0</span>),<br>(<span class="hljs-number">53688</span>, &quot;Bieber&quot;, &quot;jbieber@cs&quot;, <span class="hljs-number">27</span>, <span class="hljs-number">3.9</span>),<br>(<span class="hljs-number">53655</span>, &quot;Tupac&quot;, &quot;shakur@cs&quot;, <span class="hljs-number">25</span>, <span class="hljs-number">3.5</span>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> enrolled(<br>	sid <br>)<br></code></pre></td></tr></table></figure>
<ul>
<li>获取到student表中的注册统计数</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> COUNT(<span class="hljs-keyword">login</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br>// 大多数数据库都对count（*）有优化<br><span class="hljs-keyword">SELECT</span> COUNT(*) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> COUNT(<span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> cnt <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>多聚合，多个属性的聚合</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> AVG(gpa), COUNT(sid) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>DISTINCT</p>
<p>COUNT、SUM、AVG支持DISTINCT，表示只会统计不同的元素，去重</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> COUNTA(<span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">login</span>) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>GROUP BY</p>
<p>按照group by后面的元组进行select操作</p>
</li>
</ul>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">// 按照cid的分组来计算gpa的平均值，并聚合cid和平均值两列元素<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(s.gpa), <span class="hljs-built_in">e</span>.cid<br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> <span class="hljs-built_in">e</span>, student <span class="hljs-keyword">AS</span> s<br><span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">e</span>.sid = s.sid<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">e</span>.cid;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>HAVING</p>
<p>在完成group by以后还需要再进行一些筛选，可以使用having</p>
</li>
</ul>
<h3 id="STRING-OPERATIONS（字符串操作）"><a href="#STRING-OPERATIONS（字符串操作）" class="headerlink" title="STRING OPERATIONS（字符串操作）"></a>STRING OPERATIONS（字符串操作）</h3><ul>
<li><p>模糊查询</p>
<blockquote>
<p>数据库中没有搜索引擎，少用右模糊查询或者全模糊查询，百分号尽量不放在前面，在索引过程当中遵循最左匹配原则</p>
</blockquote>
<p>%：代表一个或多个字符</p>
<p>_：代表单个字符</p>
</li>
<li><p>SUBSTRING</p>
<p>字符串切片操作</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">// 对<span class="hljs-type">name</span>这一列中的字符串进行切片操作<br><span class="hljs-keyword">SELECT</span> SUBSTRING(<span class="hljs-type">name</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>) <span class="hljs-keyword">AS</span> abbrv_name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> sid = <span class="hljs-number">53688</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>UPPER：大写</p>
</li>
<li><p>LOWER：小写</p>
</li>
<li><p>CONCAT</p>
<p>连接操作，将字符串拼接起来</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> = CONCAT(LOWER(<span class="hljs-type">name</span>), <span class="hljs-string">&#x27;@cs&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="OUTPUT-REDIRECTION（输出重定向）"><a href="#OUTPUT-REDIRECTION（输出重定向）" class="headerlink" title="OUTPUT REDIRECTION（输出重定向）"></a>OUTPUT REDIRECTION（输出重定向）</h3><p>将一个查询的结果集建成一个新的表，要求重定向的表是没有被定义的表，同时</p>
<ul>
<li>CREATE TABLE</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 使用查询建一张表格<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> CourseIds(<br>	<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> cid <span class="hljs-keyword">FROM</span> enrolled<br>);<br></code></pre></td></tr></table></figure>
<ul>
<li><p>ORDER BY <cloumn*> [ASC|DESC]</p>
<p>按照某一列或者多列进行增序或者降序</p>
</li>
</ul>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"># <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span>: 根据第一列进行排序<br><span class="hljs-keyword">SELECT</span> sid, grade <span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">WHERE</span> cid = <span class="hljs-string">&#x27;15-721&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade<br></code></pre></td></tr></table></figure>
<ul>
<li><p>LIMIT &lt; count &gt; [offset]</p>
<p>输出count行，从第offset个开始</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 从满足条件的第<span class="hljs-number">10</span>个开始查找<span class="hljs-number">20</span>个学生<br><span class="hljs-keyword">SELECT</span> sid, <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">login</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span><br><span class="hljs-keyword">LIMIT</span> <span class="hljs-number">20</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<h3 id="NESTED-QUERIES（嵌套查询）"><a href="#NESTED-QUERIES（嵌套查询）" class="headerlink" title="NESTED QUERIES（嵌套查询）"></a>NESTED QUERIES（嵌套查询）</h3><p>将一个查询或多个查询嵌入到另一个查询当中</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240104193223551.png" class="" title="image-20240104193223551">
<p>对子嵌套的关系进行操作</p>
<ul>
<li>ALL：所有的行必须满足子查询中的表达式</li>
<li>ANY：至少一行必须在子查询中匹配</li>
<li>IN：等价于=ANY</li>
<li>EXISTS：只要内部查询产生一个输出记录就返回</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student<br><span class="hljs-keyword">WHERE</span> sid = <span class="hljs-keyword">ANY</span>(<br><span class="hljs-keyword">SELECT</span> sid <span class="hljs-keyword">FROM</span> enrolled<br><span class="hljs-keyword">WHERE</span> cid = <span class="hljs-string">&#x27;15-445&#x27;</span><br>);<br></code></pre></td></tr></table></figure>
<h3 id="WINDOW-FUNCTIONS（窗口函数）"><a href="#WINDOW-FUNCTIONS（窗口函数）" class="headerlink" title="WINDOW FUNCTIONS（窗口函数）"></a>WINDOW FUNCTIONS（窗口函数）</h3><p>类似于聚合，但不仅仅是将元组折叠成单个聚合，而是以一种增量的方式计算聚合</p>
<ul>
<li><p>SELECT … FUNC-NAME(…) OVER(…) FROM table</p>
<p>使用窗口函数FUNC-NAME，按照OVER的方式对查询的col进行聚合</p>
</li>
<li><p>窗口函数种类</p>
<ul>
<li>ROW_NUMBER() ：每一行的行号</li>
<li>RANK() ：位置</li>
<li>二者的区别在于，rank可以并列，但是row_number是唯一的</li>
</ul>
</li>
<li><p>PARTITION BY  cid：按照cid分组，可以写在over中的条件里面</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"># 先将enrolled表按照cid分组，并按照grade排序<br># 再找出每一门课当中的第二名，ranking中第<span class="hljs-number">2</span>高成绩的数据<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> (<br><span class="hljs-keyword">SELECT</span> *, RANK() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cid<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">ASC</span>) <span class="hljs-keyword">AS</span> rank<br><span class="hljs-keyword">FROM</span> enrolled) <span class="hljs-keyword">AS</span> ranking<br><span class="hljs-keyword">WHERE</span> ranking.rank = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>CTE（COMMON TABLE EXPRESSIONS）</p>
<p>通用表达式：只在sql语句内部起作用的临时语句</p>
<p>RECURSIVE：递归调用，不是所有的sql都能够使用递归</p>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">WITH</span> cteName (col1, col2) <span class="hljs-keyword">AS</span> (<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br>)<br><span class="hljs-keyword">SELECT</span> col1 + col2 <span class="hljs-keyword">FROM</span> cteName<br><br><span class="hljs-keyword">WITH</span> cteSource (maxId) <span class="hljs-keyword">AS</span> (<br><span class="hljs-keyword">SELECT</span> MAX(sid) <span class="hljs-keyword">FROM</span> enrolled<br>)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> <span class="hljs-keyword">FROM</span> student, cteSource<br><span class="hljs-keyword">WHERE</span> student.sid = cteSource.maxId<br><br># CTE递归的调用，很少用，可读性差<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> cteSource (counter) <span class="hljs-keyword">AS</span> (<br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>)<br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br>(<span class="hljs-keyword">SELECT</span> counter + <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> cteSource<br><span class="hljs-keyword">WHERE</span> counter &lt; <span class="hljs-number">10</span>)<br>)<br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> cteSource<br></code></pre></td></tr></table></figure>
<ul>
<li>CTE可以递归调用自身</li>
</ul>
<h2 id="03-Database-Storage-1"><a href="#03-Database-Storage-1" class="headerlink" title="03-Database Storage 1"></a>03-Database Storage 1</h2><h3 id="基于磁盘的架构"><a href="#基于磁盘的架构" class="headerlink" title="基于磁盘的架构"></a>基于磁盘的架构</h3><blockquote>
<p> 数据库管理系统（DBMS）假设数据库的主要存储位置位于非易失性磁盘上。DBMS 的各个组件负责管理在非易失性存储和易失性存储之间的数据移动。</p>
</blockquote>
<ul>
<li><p>数据库系统的设计目标</p>
<blockquote>
<p>数据库系统做的操作有点类似于虚拟内存，如下图</p>
</blockquote>
<p>1、系统可以管理超过内存可使用的总内存的数据</p>
<p>2、由于读写内存十分昂贵，需要尽可能避免数据大量的读写内存造成的性能损耗</p>
<p>3、尽可能使用顺序存储的方式提高效率</p>
</li>
<li><p>为什么不适用操作系统？操作系统的虚拟内存可以进行相关操作</p>
<blockquote>
<p>数据库管理系统使用内存映射存储文件的内容到程序的地址空间</p>
<p>操作系统负责文件页面的命中与否，数据库管理系统不需要考虑</p>
</blockquote>
</li>
</ul>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240105160547664.png" class="" title="image-20240105160547664">
<ul>
<li><p>内存映射会遇到的问题（MEMORY MAPPED I/O PROBLEMS）</p>
<ul>
<li><p>事务安全Transaction Safety</p>
</li>
<li><p>I/O阻塞</p>
<p>数据库系统不知道内存中有哪些页面，所以在取数据如果发生错误，操作系统会阻塞线程</p>
</li>
<li><p>错误处理</p>
</li>
<li><p>性能问题</p>
</li>
</ul>
</li>
</ul>
<p>结论：数据库管理系统不使用MMAP内存映射</p>
<ul>
<li><p>数据库进行管理</p>
<p>问题1、数据库系统如何表示磁盘上的文件数据</p>
<p>问题2、如何管理内存以从磁盘中来回移动这些页面的数据，数据的读入与写回</p>
</li>
</ul>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><blockquote>
<p>数据库系统会使用数据库独有的文件格式在磁盘上存储一个或者多个文件</p>
<p>操作系统并无法知晓文件的内容</p>
</blockquote>
<ul>
<li><p>存储管理器</p>
<p>用于维护数据库文件，进行页面调度提升性能，利用局部性原则，组织一系列的页面文件读写</p>
</li>
<li><p>数据页面</p>
<blockquote>
<p>页面被锁定为固定大小的数据块，可以包含任何内容，不可以包含混合的数据</p>
</blockquote>
<p>硬件页面：存储设备可以保证它原子写出的最小数据或数据块大小，默认大小4KB</p>
<p>操作系统页面：通常4KB</p>
<p>数据库页面：512B-16KB</p>
<ul>
<li>硬件页面是存储设备能够保证正确写入的最大块大小</li>
<li>使用更大的页面可以减少IO，运用到局部性原理，但是不能够确保更大的页面读写是原子的，需要使用一些操作来确保数据不会丢失</li>
</ul>
</li>
<li><p>堆文件heap file</p>
<p>按照随机顺序存储的无序页面的集合</p>
<p>包含有获取、创建、写入、删除页面，以及迭代功能</p>
<p>数据库管理系统维护一张特殊的表格用于定位数据库文件中的页面，也可以称为目录</p>
</li>
</ul>
<h3 id="页面Page"><a href="#页面Page" class="headerlink" title="页面Page"></a>页面Page</h3><ul>
<li><p>页面标头</p>
<p>页面大小</p>
<p>校验和：检查是否有数据损坏</p>
<p>数据库管理系统版本：升级系统会更新</p>
<p>事务可见性：用于进行权限管理</p>
<p>压缩信息、备份</p>
</li>
<li><p>内部组织形式</p>
<ul>
<li><p>面向元组tuple的存储方式</p>
<ul>
<li>方式1</li>
</ul>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240110074224104.png" class="" title="image-20240110074224104">
<p>删除其中一个tuple需要进行线性的移动</p>
<p>无法对可变长度的属性进行存储</p>
<ul>
<li>方式二、开槽页面slot</li>
</ul>
<p>在页面开头存入槽数组，将元组映射到页面的实际位置</p>
<p>槽页面是从尾端按照顺序存储</p>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240110074349028.png" class="" title="image-20240110074349028">
</li>
</ul>
</li>
<li><p>Record IDS</p>
<blockquote>
<p>每一个元组都有一个唯一的记录ID号</p>
</blockquote>
<p>大部分格式为：页面ID+偏移量，可以使用ctid来获取（数据库中不能有列名为ctid的列） </p>
<ul>
<li>每个元组都有元数据，元组头部：可见性信息（元组是否删除）、使用位图表示元组中的空值</li>
</ul>
</li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">#在数据库中可以对碎片整理，会填补前面因为元组删除而空余的slot<br><span class="hljs-keyword">VACUUM</span> <span class="hljs-keyword">FULL</span> <span class="hljs-keyword">table</span>;<br></code></pre></td></tr></table></figure>
<h2 id="04-Database-Storage-2"><a href="#04-Database-Storage-2" class="headerlink" title="04-Database Storage 2"></a>04-Database Storage 2</h2><h3 id="基于日志的架构"><a href="#基于日志的架构" class="headerlink" title="基于日志的架构"></a>基于日志的架构</h3><blockquote>
<p>数据库管理系统存包含改变元组的日志记录（PUT、DELETE）</p>
<p>每一条日志记录包含元组独特的ID</p>
<p>PUT：包含元组修改后的内容</p>
<p>DELETE：将元组标记为删除</p>
</blockquote>
<p>数据库管理系统在内存页面中存储对元组操作的一些记录，例如修改某一个元组，删除某一个元组，当页面存满以后，记录会被永久保存，并切换到下一个页面，这样的好处可以磁盘IO更少，便于写入</p>
<p>读入的时候，会需要向前不断追溯到最新的记录，读入很慢，在数据库管理系统中会维护一张index的表，映射到元组id的最新记录</p>
<ul>
<li><p>日志压缩</p>
<p>因为日志是随着数据库的操作而进行持续增长的，数据库管理系统会定期的压缩页面以减少空间浪费</p>
<p>通过将多个页面合并（找到记录的最新版本），移除掉不必要的记录</p>
<ul>
<li><p>通用压缩（Universal Compation）</p>
<p>查看两个连续的排序文件，将其组合在一起，随后删除旧的文件</p>
</li>
<li><p>层级压缩（Level Compation）</p>
<p>类似于2048，层级较低的过多以后，整合压缩成更大的高层文件</p>
</li>
</ul>
</li>
<li><p>基于日志的架构有什么缺点</p>
<ul>
<li><p>对写功能的放大</p>
<p>如果需要更新某一个元组，会在查询的过程中压缩，会和压缩过后的页面一起写回，写就被放大了</p>
</li>
<li><p>压缩代价较大</p>
</li>
</ul>
</li>
</ul>
<h3 id="元组的存储"><a href="#元组的存储" class="headerlink" title="元组的存储"></a>元组的存储</h3><p>4类基本数据类型：整型，浮点（FLOAT/REAL，NUMERIC/DECIMAL），varchar，time</p>
<ul>
<li>高精度的数据<ul>
<li>Postgres，最终结果使用字符串的别名来表示，需要实现不同数据的拼接，很影响性能</li>
</ul>
</li>
</ul>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240112101151040.png" class="" title="image-20240112101151040">
<ul>
<li><p>大数据：例如大小超过一个页面的数据</p>
<p>使用其它的页面存储这些更大的页</p>
</li>
</ul>
<img src="/2024/02/10/15445-study-notes-01-04/image-20240112102928169.png" class="" title="image-20240112102928169">
<ul>
<li><p>外部资源数据</p>
<p>一些数据库系统允许存储外部文件的数据，对于这些外部文件，数据库系统无法做到持续性保护以及业务的保护，无法保证外部文件不被修改</p>
</li>
<li><p>系统目录</p>
<p>数据库系统维护数据库的一些表格</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>CMU15445</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库-MySQL</title>
    <url>/2024/02/10/database-mysql/</url>
    <content><![CDATA[<h2 id="数据库-Mysql"><a href="#数据库-Mysql" class="headerlink" title="数据库-Mysql"></a>数据库-Mysql</h2><blockquote>
<p>Mysql数据库的关键词：事务、存储引擎、索引、SQL优化、<strong>锁、日志、主从复制、读写分离、分库分表</strong></p>
</blockquote>
<h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><h3 id="1、Mysql概述"><a href="#1、Mysql概述" class="headerlink" title="1、Mysql概述"></a>1、Mysql概述</h3><p>关系型数据库：建立在关系模型基础上，由多张互连接的二维表组成的数据库</p>
<p>特点：使用表存储数据，便于维护；使用sql语句操作，使用方便</p>
<p><strong>MySQL数据模型</strong></p>
<blockquote>
<p>1、客户端通过与数据库管理系统进行连接</p>
<p>2、使用sql语句通过数据库管理系统对指定的数据库进行增删改查</p>
<p>3、一个数据库模型中可以对多个数据库进行管理，一个数据库中可以拥有多个表</p>
</blockquote>
<p>// TODO数据库模型的图</p>
<h3 id="2、SQL"><a href="#2、SQL" class="headerlink" title="2、SQL"></a>2、SQL</h3><p><strong>SQL分类</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>全称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>DDL</td>
<td>Data Definition Language</td>
<td>数据库定义语句，定义数据库对象，数据库，表，字段等</td>
</tr>
<tr>
<td>DML</td>
<td>Data Manipulation Language</td>
<td>数据库操作语句，用于对数据库表中的数据进行增增删改</td>
</tr>
<tr>
<td>DQL</td>
<td>Data Query Language</td>
<td>数据库查询语句，查询数据库表中的记录</td>
</tr>
<tr>
<td>DCL</td>
<td>Data Control Language</td>
<td>数据库控制语句，创建数据库用户，控制数据库的访问权限</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><p><strong>数据库层次</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询所有数据库表格<br>SHOW DATABASES;<br># 查询当前所在的数据库<br>SELECT DATABASE();<br># 创建数据库，方括号可以省略<br>CREATE DATABASE [IF NOT EXISTS] 数据库名 [COLLATE 排序规则]<br># 删除数据库<br>DROP DATABASE [IF EXISTS] 数据库名<br># 使用数据库，切换到数据库当中<br>USE 数据库名<br></code></pre></td></tr></table></figure>
<p>​        表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看所有表<br>SHOW TABLES;<br># 查询表结构<br>DESC 表名<br># 查询指定表的建表语句<br>SHOW CREATE TABLE 表名;<br></code></pre></td></tr></table></figure>
<p>​        MySQL中的数据类型</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>微小整数，有符号或无符号（UNSIGNED）</td>
<td>1 字节</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>小整数，有符号或无符号</td>
<td>2 字节</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>中等整数，有符号或无符号</td>
<td>3 字节</td>
</tr>
<tr>
<td>INT 或 INTEGER</td>
<td>整数，有符号或无符号</td>
<td>4 字节</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数，有符号或无符号</td>
<td>8 字节</td>
</tr>
<tr>
<td>FLOAT(M,D)</td>
<td>单精度浮点数，M 是总位数，D 是小数位数</td>
<td>4 字节</td>
</tr>
<tr>
<td>DOUBLE(M,D)</td>
<td>双精度浮点数，M 是总位数，D 是小数位数</td>
<td>8 字节</td>
</tr>
<tr>
<td>DECIMAL(M,D)</td>
<td>定点数，M 是总位数，D 是小数位数</td>
<td>取决于 M 和 D</td>
</tr>
<tr>
<td>DATE</td>
<td>日期 YYYY-MM-DD</td>
<td>3 字节</td>
</tr>
<tr>
<td>TIME</td>
<td>时间 HH:MM:SS</td>
<td>3 字节</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期和时间</td>
<td>8 字节</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>时间戳</td>
<td>4 字节</td>
</tr>
<tr>
<td>CHAR(N)</td>
<td><strong>定长</strong>字符串，最大长度为 N</td>
<td>最大 255 字节</td>
</tr>
<tr>
<td>VARCHAR(N)</td>
<td><strong>变长</strong>字符串，最大长度为 N</td>
<td>最大 65,535 字节</td>
</tr>
<tr>
<td>TEXT</td>
<td>变长文本，最大长度为 65,535 字节</td>
<td>最大 65,535 字节</td>
</tr>
<tr>
<td>BLOB</td>
<td>二进制大对象，最大长度为 65,535 字节</td>
<td>最大 65,535 字节</td>
</tr>
<tr>
<td>ENUM</td>
<td>枚举类型</td>
<td>1 或 2 字节，取决于成员数量</td>
</tr>
<tr>
<td>SET</td>
<td>集合类型</td>
<td>1、2、3、4 或 8 字节，取决于成员数量</td>
</tr>
</tbody>
</table>
</div>
<p>创建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE member(<br>    number INT COMMENT &#x27;编号&#x27;,<br>    id CHAR(10) COMMENT &#x27;员工工号&#x27;,<br>    name VARCHAR(10) COMMENT &#x27;员工姓名&#x27;,<br>    gender CHAR(4) COMMENT &#x27;员工性别&#x27;,<br>    age INT UNSIGNED COMMENT &#x27;年龄&#x27;,<br>    id_number CHAR(18) COMMENT &#x27;身份证号&#x27;,<br>    time DATE COMMENT &#x27;入职时间&#x27;<br>)<br></code></pre></td></tr></table></figure>
<p><strong>表结构的修改</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 添加字段<br>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束];<br><br># 修改字段和字段类型<br>ALTER TABLE 表明 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束]<br><br># 删除字段<br>ALTER TABLE 表名 DROP 字段名;<br><br># 修改表名<br>ALTER TABLE 表名 RENAME TO 新表名;<br><br># 删除表<br>DROP TABLE [IF EXSITS] 表名;<br># 删除指定表并重新创建该表，清空数据<br>TRUNCATE TABLE 表名;<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="DML（数据操作语言）"><a href="#DML（数据操作语言）" class="headerlink" title="DML（数据操作语言）"></a>DML（数据操作语言）</h4></li>
</ul>
<p><strong>添加数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 给指定字段添加数据<br>INSERT INTO 表名(字段名1, 字段名2, ...) VALUES (值1, 值2, ...);<br><br># 给全部字段添加数据<br>INSERT INTO 表名 VALUES(值1, 值2, ...);<br></code></pre></td></tr></table></figure>
<p><strong>修改数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 修改数据<br>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ...[WHERE 条件];<br></code></pre></td></tr></table></figure>
<p><strong>删除数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 删除数据<br>DELETE FROM 表名 [WHERE 条件];<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h4><blockquote>
<p>数据库查询语言，用来查询数据库中的表的记录</p>
<p>SELECT后面加上\G可以将某一行转化为一列查看</p>
</blockquote>
</li>
</ul>
<p><strong>语法结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT<br>	字段列表<br>FROM<br>	表名列表<br>WHERE<br>	条件列表(条件查询)<br>GROUP BY<br>	分组字段列表(分组查询)<br>HAVING<br>	分组后条件列表<br>ORDER BY<br>	排序字段列表<br>LIMIT<br>	分页参数<br></code></pre></td></tr></table></figure>
<p><strong>基本查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段1 [AS 别名]，字段2 [AS 别名]， FROM 表名;<br><br># 去重<br>SELECT DISTINCT 字段列表 FROM 表名;<br></code></pre></td></tr></table></figure>
<p><strong>条件查询</strong></p>
<p>条件运算符</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">比较运算符</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;&gt;或!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">BETWEEN … AND …</td>
<td style="text-align:center">在某个范围之内</td>
</tr>
<tr>
<td style="text-align:center">IN(…)</td>
<td style="text-align:center">在in之后的列表中的值，多选一</td>
</tr>
<tr>
<td style="text-align:center">LIKE 占位符</td>
<td style="text-align:center">模糊匹配(_匹配单个字符，%匹配任意个字符)</td>
</tr>
<tr>
<td style="text-align:center">IS NULL</td>
<td style="text-align:center">是NULL</td>
</tr>
</tbody>
</table>
</div>
<p><strong>聚和函数</strong></p>
<blockquote>
<p>将一列数据作为一个整体，进行纵向计算。</p>
</blockquote>
<p>所有的null值不参与聚合函数的计算</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count</td>
<td style="text-align:center">统计数量</td>
</tr>
<tr>
<td style="text-align:center">max</td>
<td style="text-align:center">最大值</td>
</tr>
<tr>
<td style="text-align:center">min</td>
<td style="text-align:center">最小值</td>
</tr>
<tr>
<td style="text-align:center">avg</td>
<td style="text-align:center">平均值</td>
</tr>
<tr>
<td style="text-align:center">sum</td>
<td style="text-align:center">求和</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 聚合函数(字段列表) FROM 表名;<br></code></pre></td></tr></table></figure>
<p><strong>分组查询</strong></p>
<blockquote>
<p>在where中不可以使用聚合函数，在having中可以使用聚合函数</p>
<p>分组之前过滤用where，分组之后过滤条件用having</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段列表	FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];<br></code></pre></td></tr></table></figure>
<p>执行顺序：where &gt; 聚合函数 &gt; having</p>
<p><strong>排序查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2<br></code></pre></td></tr></table></figure>
<p>排序方式： ASC升序（默认），DESC降序</p>
<p><strong>分页查询</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;<br></code></pre></td></tr></table></figure>
<p>显示从起始索引开始的记录数条的查询结果</p>
<p><strong>DQL执行顺序</strong></p>
<p>FROM &gt; WHERE &gt; GROUP BY &gt; SELECT &gt; ORDER BY &gt; LIMIT</p>
<ul>
<li><h4 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h4></li>
</ul>
<blockquote>
<p>数据控制语句，用来管理数据库用户，控制数据库访问权限</p>
</blockquote>
<p><strong>DCL用户管理</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询用户<br>USE mysql;<br>SELECT * FROM user;<br><br># 创建用户，主机名换成&quot;%&quot;表示可以在任意主机访问数据库<br>CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;<br><br># 修改用户密码<br>ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;<br><br># 删除用户<br>DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></td></tr></table></figure>
<p><strong>权限控制</strong></p>
<p>常用权限</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">权限</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ALL, ALL PRIVILEGES</td>
<td style="text-align:center">所有权限</td>
</tr>
<tr>
<td style="text-align:center">SELECT</td>
<td style="text-align:center">查询数据</td>
</tr>
<tr>
<td style="text-align:center">INSERT</td>
<td style="text-align:center">插入数据</td>
</tr>
<tr>
<td style="text-align:center">UPDATE</td>
<td style="text-align:center">修改数据</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">删除数据</td>
</tr>
<tr>
<td style="text-align:center">ALTER</td>
<td style="text-align:center">修改表</td>
</tr>
<tr>
<td style="text-align:center">DROP</td>
<td style="text-align:center">删除数据库/表/视图</td>
</tr>
<tr>
<td style="text-align:center">CREATE</td>
<td style="text-align:center">创建数据库/表</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询权限<br>SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br># 授予权限<br>GRANT 权限列表 ON 数据库名.表名(*.*所有表) TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br># 撤销权限<br>REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></td></tr></table></figure>
<h3 id="3、函数"><a href="#3、函数" class="headerlink" title="3、函数"></a>3、函数</h3><ul>
<li><strong>字符串函数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CONCAT(S1,S2, … Sn)</td>
<td style="text-align:center">字符串拼接，将S1-Sn拼接成一个字符串</td>
</tr>
<tr>
<td style="text-align:center">LOWER(str)</td>
<td style="text-align:center">将字符串str全部转为小写</td>
</tr>
<tr>
<td style="text-align:center">UPPER(str)</td>
<td style="text-align:center">将字符串全部转为大写</td>
</tr>
<tr>
<td style="text-align:center">LPAD(str, n, pad)</td>
<td style="text-align:center">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>
</tr>
<tr>
<td style="text-align:center">RPAD(str, n,  pad)</td>
<td style="text-align:center">右填充</td>
</tr>
<tr>
<td style="text-align:center">TRIM(str)</td>
<td style="text-align:center">去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td style="text-align:center">SUBSTRING(str, start, len)</td>
<td style="text-align:center">返回从字符串str从start起的len长度的字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">SELECT 函数;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>数值函数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CEIL(x)</td>
<td style="text-align:center">向上取整</td>
</tr>
<tr>
<td style="text-align:center">FLOOR(x)</td>
<td style="text-align:center">向下取整</td>
</tr>
<tr>
<td style="text-align:center">MOD(x, y)</td>
<td style="text-align:center">返回x/y的模</td>
</tr>
<tr>
<td style="text-align:center">RAND()</td>
<td style="text-align:center">返回0~1内的随机数</td>
</tr>
<tr>
<td style="text-align:center">ROUND(x, y)</td>
<td style="text-align:center">求参数x的四舍五入的值，保留y位小数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>日期函数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">CURDATE()</td>
<td style="text-align:center">返回当前日期</td>
</tr>
<tr>
<td style="text-align:center">CURTIME()</td>
<td style="text-align:center">返回当前时间</td>
</tr>
<tr>
<td style="text-align:center">NOW()</td>
<td style="text-align:center">返回当前日期和时间</td>
</tr>
<tr>
<td style="text-align:center">YEAR(date)</td>
<td style="text-align:center">获取指定date的年份</td>
</tr>
<tr>
<td style="text-align:center">MONTH(date)</td>
<td style="text-align:center">获取指定date的月份</td>
</tr>
<tr>
<td style="text-align:center">DAY(date)</td>
<td style="text-align:center">获取指定date的日期</td>
</tr>
<tr>
<td style="text-align:center">DATE_ADD(date, INTERVAL expr type)</td>
<td style="text-align:center">返回上一个日期加上时间间隔expr以后的时间值，type(year,month,day)指定年月天</td>
</tr>
<tr>
<td style="text-align:center">DATEDIFF(date1, date2)</td>
<td style="text-align:center">返回起始时间date1和结束时间date2之间的天数，第一个时间减去第二个时间</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>流程函数</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IF(value, t. f)</td>
<td style="text-align:center">如果value为true，返回t，否则返回f</td>
</tr>
<tr>
<td style="text-align:center">IFNULL(value1, value2)</td>
<td style="text-align:center">如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td style="text-align:center">CASE WHEN [val] THEN [res1] … ELSE [ default ] END</td>
<td style="text-align:center">如果val1为true，返回res1，…否则返回default默认值</td>
</tr>
<tr>
<td style="text-align:center">CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td>
<td style="text-align:center">如果expr的值等于val1，返回res1，…否则返回default默认值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4、约束"><a href="#4、约束" class="headerlink" title="4、约束"></a>4、约束</h3><p>作用于表中字段上的规则，用于限制存储在表中的数据</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">约束</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">非空约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">唯一约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">主键约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">默认约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">检查约束</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">外键约束</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h3 id="5、多表查询"><a href="#5、多表查询" class="headerlink" title="5、多表查询"></a>5、多表查询</h3><ul>
<li><p><strong>多表关系</strong></p>
<p>一对多：在多的一方建立外键，指向一的一方的主键</p>
</li>
</ul>
<p>​        多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方的主键</p>
<p>​        一对一：用于做单表拆分，基础字段放在一张表，详情字段放在另一张表。在任意一方加入外键，关联另一方的主键，并设置外键为唯一（UNIQUE）</p>
<ul>
<li><p><strong>多表查询</strong></p>
<ul>
<li><p>内连接</p>
<blockquote>
<p>相当于查询A、B交集部分数据</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 隐式内连接<br>SELECT 字段列表 FROM 表1，表2 WHERE 条件...;<br><br># 显示内连接<br>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>外连接</p>
<blockquote>
<p>左外连接：查询左表所有数据，以及两张表交集部分数据，将左表的数据和右表的部分数据连接起来</p>
<p>右外连接：查询右表所有数据，以及两张表交集部分数据</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 左外连接，表1所有数据以及和表2交集部分的数据<br>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;<br><br># 右外连接，表2所有数据以及和表1交集部分的数据<br>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>自连接</p>
<blockquote>
<p>自连接：当前表与自身的连接查询，自连接必须使用表别名</p>
</blockquote>
</li>
<li><p>联合查询-union，union all</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 把多次查询的结果合并起来，形成一个新的查询结果集<br># ALL去掉以后会对结果进行去重<br>SELECT 字段列表 表A<br>UNION [ALL]<br>SELECT 字段列表 表B;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>子查询</strong></p>
<ul>
<li><p>标量子查询，子查询返回一个标量</p>
</li>
<li><p>列子查询，子查询返回一列</p>
<p>| 操作符 |                 描述                 |<br>| :——: | :—————————————————: |<br>|   IN   |     在指定的集合范围之内，多选一     |<br>| NOT IN |          不在指定的范围之内          |<br>|  ANY   | 子查询返回列表中，有任意一个满足即可 |<br>|  SOME  |              与ANY等同               |<br>|  ALL   |   子查询返回列表的所有值都必须满足   |</p>
</li>
<li><p>行子查询，子查询返回的结果是一行</p>
<p>此时column1可以使用(column1， column2)聚合成多个参数</p>
<p>操作符：=、&lt;&gt;、IN、NOT IN</p>
</li>
<li><p>表子查询，子查询的返回结果是一个表，可以和行子查询加上列子查询的操作符使用，表可以放到from后面</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 对于子查询，可以将问题拆解成多个不同的查询步骤<br>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);<br></code></pre></td></tr></table></figure>
<h3 id="6、事务"><a href="#6、事务" class="headerlink" title="6、事务"></a>6、事务</h3><blockquote>
<p>一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么<strong>同时成功，要么同时失败</strong></p>
<p>默认Mysql的事务是自动提交的，当执行一条DML语句，Mysql会立即隐式的提交事务</p>
</blockquote>
<ul>
<li><strong>事务操作</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看/设置事务提交方式<br>SELECT @@autocommit;<br># 事务设置为手动提交<br>SET @@autocommit = 0;<br><br># 提交事务<br>COMMIT;<br><br># 回滚事务<br>ROLLBACK;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 不修改事务的提交方式操作事务<br># 开启事务<br>START TRANSACTION 或 BEGIN;<br><br># 提交事务<br>COMMIT;<br><br># 回滚事务<br>ROLLBACK;<br></code></pre></td></tr></table></figure>
<ul>
<li><p><strong>事务四大特性</strong></p>
<ul>
<li>原子性(Atomicity)：事务时不可分割的最小操作单元，要么全部成功，要么全部失败</li>
<li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态</li>
<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>
<li>持久性(Durability)：事务一旦提交或者回滚，它对数据库中的数据改变就是永久的</li>
</ul>
</li>
<li><p><strong>并发事务问题</strong></p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">问题</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">脏读</td>
<td style="text-align:center">一个事务读到另一个事务还没有提交的数据</td>
</tr>
<tr>
<td style="text-align:center">不可重复读</td>
<td style="text-align:center">一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读</td>
</tr>
<tr>
<td style="text-align:center">幻读</td>
<td style="text-align:center">一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这一行数据已经存在</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><strong>事务隔离级别</strong></p>
<blockquote>
<p>读未提交、读已提交、可重复读、串行化</p>
<p>√表示会出现这个问题，×表示不会出现这个问题</p>
</blockquote>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read uncommitted</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Read committed</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Repeatable Read</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Serializable</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看事务的隔离级别<br>SELECT @@TRANSACTION_ISOLATION;<br><br># 设置事务隔离级别<br>SET [SESSION(只对当前窗口有效)|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;<br></code></pre></td></tr></table></figure>
<p>  事务的隔离界别越高，数据越安全，但是性能越低</p>
<h2 id="数据库进阶"><a href="#数据库进阶" class="headerlink" title="数据库进阶"></a>数据库进阶</h2><h3 id="1、存储引擎"><a href="#1、存储引擎" class="headerlink" title="1、存储引擎"></a>1、存储引擎</h3><ul>
<li><p>Mysql体系结构 </p>
<p>连接层：完成一些类似于连接处理、授权认证及相关的安全方案</p>
<p>服务层：主要完成大多数的核心服务功能</p>
<p>引擎层：负责mysql中数据的存储和提取，服务器通过API和存储引擎进行通信</p>
<p>存储层：将数据存储在文件系统之上，并完成与存储引擎的交互</p>
<img src="/2024/02/10/database-mysql/Mysql.png" class="" title="Mysql">
</li>
<li><p>存储引擎</p>
<blockquote>
<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎时基于表的，而不是基于库的。一个数据库的不同的表可以选择不同的存储引擎</p>
<p>Mysql默认InnoDB</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询支持的存储引擎<br>show engines;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>InnoDB</p>
<ul>
<li>DML操作遵循ACID模型，支持事务</li>
<li>行级锁，提高并发访问性能</li>
<li>支持外键，保证事务的完整性和正确性</li>
</ul>
<p>文件：每个表对应一个.ibd文件，代表表空间文件，可以通过命令<code>idb2sdi 文件名</code>查看表结构json文件格式</p>
<img src="/2024/02/10/database-mysql/image-20240216162915509.png" class="" title="image-20240216162915509">
</li>
<li><p>MyISAM</p>
<ul>
<li>不支持事务，不支持外键</li>
<li>支持表锁、不支持行锁</li>
<li>访问速度快</li>
</ul>
<p>文件.MYD（数据），.MYI（索引），.sdi（表结构）</p>
</li>
<li><p>Memory</p>
<ul>
<li>表数据存储在内存当中，收到硬件问题或断电影响只能作为临时表或者缓存使用</li>
<li>内存存放</li>
<li>hash索引（默认）</li>
</ul>
</li>
</ul>
<img src="/2024/02/10/database-mysql/image-20240216163439353.png" class="" title="image-20240216163439353">
<ul>
<li><p>存储引擎选择</p>
<p>InnoDB：如果对事务的完整性有比较高的要求，在并发情况下要求事务的一致性，数据操作除了插入和查询意外，还包括很多的更新、删除操作，InnoDB引擎比较合适</p>
<p>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性和并发现要求不是很高。<strong>这个场景被Nosql数据库MongoDB替代了</strong></p>
<p>MEMORY：将所有数据保存在内存当中，访问速度快，通常用于临时表以及缓存。MEMORY对表的大小有限制，太大的表无法缓存在内存中。<strong>这个场景被Redis替代了</strong></p>
</li>
</ul>
<h3 id="2、索引"><a href="#2、索引" class="headerlink" title="2、索引"></a>2、索引</h3><ul>
<li><p><strong>索引概述</strong></p>
<ul>
<li>索引的结构</li>
</ul>
</li>
<li><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a><strong>索引分类</strong></h4></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主键索引</td>
<td style="text-align:center">针对于表中主键创建的索引</td>
<td style="text-align:center">默认自动创建，只能有一个</td>
<td style="text-align:center">PRIMARY</td>
</tr>
<tr>
<td style="text-align:center">唯一索引</td>
<td style="text-align:center">避免同一个表中某数据列中的值重复</td>
<td style="text-align:center">可以有多个</td>
<td style="text-align:center">UNIQUE</td>
</tr>
<tr>
<td style="text-align:center">常规索引</td>
<td style="text-align:center">快速定位特定数据</td>
<td style="text-align:center">可以有多个</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">全文索引</td>
<td style="text-align:center">全文索引查找的是文本中通过的关键词</td>
<td style="text-align:center">可以有多个</td>
<td style="text-align:center">FULLTEXT</td>
</tr>
</tbody>
</table>
</div>
<p>按照索引的存储形式分类</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">特点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">聚集索引</td>
<td style="text-align:center">将数据存储与索引放到了一块</td>
<td style="text-align:center">必须有，而且只有一个</td>
</tr>
<tr>
<td style="text-align:center">二级索引</td>
<td style="text-align:center">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>
<td style="text-align:center">可以存在多个</td>
</tr>
</tbody>
</table>
</div>
<img src="/2024/02/10/database-mysql/image-20240218203730285.png" class="" title="image-20240218203730285">
<ul>
<li><h4 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a><strong>索引语法</strong></h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 创建索引<br># 一个索引可以关联多行，如果关联多行称为联合索引<br>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name, )<br><br># 查看索引<br>SHOW INDEX FROM table_name;<br><br># 删除索引<br>DROP INDEX index_name ON table_name;<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a><strong>SQL性能分析</strong></h4><blockquote>
<p>使用于select的优化</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># SQL执行频率，查看当前数据库语句的访问频率<br>SHOW [session|global] STATUS<br># Com七个下划线，模糊匹配<br>SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;<br></code></pre></td></tr></table></figure>
<p><strong>SQL语句的频率</strong></p>
<img src="/2024/02/10/database-mysql/image-20240218204502697.png" class="" title="image-20240218204502697">
<p><strong>慢查询日志</strong></p>
<blockquote>
<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10)的所有SQL语句的日志</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看是否开启，日志文件默认在/var/lib/mysql里面<br>SHOW VARIABLES LIKE &#x27;slow_query_log&#x27;;<br><br># 修改/etc/my.cnf中配置开启，配置时间<br>slow_query_log=1   <br>long_query_time=2<br></code></pre></td></tr></table></figure>
<p><strong>profile详情</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看是否支持prifile<br>SELECT @@have_profiling;<br><br># 设置为开<br>SET profiling=1;<br><br># 查看profile<br>SHOW PROFILES;<br></code></pre></td></tr></table></figure>
<p>执行完SQL语句以后，通过以下指令查看执行耗时情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看每一条SQL耗时基本情况<br>SHOW PROFILES;<br><br># 查看指定query_id的SQL语句各个阶段的耗时情况<br>SHOW PROFILE FOR QUERY query_id;<br><br># 查看指定SQL语句的CPU使用情况<br>SHOW PROFILE CPU FOR QUERY query_id;<br></code></pre></td></tr></table></figure>
<p><strong>explain执行计划</strong></p>
<blockquote>
<p>EXPLAIN或者DESC命令获取Mysql如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT SQL语句;<br></code></pre></td></tr></table></figure>
<img src="/2024/02/10/database-mysql/image-20240218211138993.png" class="" title="image-20240218211138993">
<p>表头的含义：</p>
<img src="/2024/02/10/database-mysql/image-20240218212814126.png" class="" title="image-20240218212814126">
<img src="/2024/02/10/database-mysql/image-20240218212115878.png" class="" title="image-20240218212115878">
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">type<br>const	以主键或以唯一的列作为索引扫描<br>ref		非唯一的值作为查询索引<br>index	用了索引，但是会对整个索引进行遍历<br>all		全表扫描<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a><strong>索引使用</strong></h4></li>
</ul>
<p><strong>联合索引</strong></p>
<p>使用要遵循<strong>最左前缀法则</strong>：查询<strong>从索引的最左列开始</strong>，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>
<p><strong>范围查询</strong>：联合索引中出现范围查询（&gt;,&lt;)，范围查询右侧的列索引失效。但是使用大于等于和小于等于索引并不会失效。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># student有联合索引(id,name,age)<br># 1、索引都可以使用<br>select * from student where id = 1 and name = &quot;Lili&quot; and age = 20;<br><br># 2、索引name，age失效<br>select * from student where id = 1 and age = 20;<br><br># 范围查询<br># name和age索引均失效<br>select * from student where id &gt; 1 and name = &quot;Lili&quot; and age = 20;<br></code></pre></td></tr></table></figure>
<p><strong>索引失效</strong></p>
<p>索引列操作：不要在索引上进行列操作，否则索引会失效</p>
<p>字符串类型：不加单引号索引会失效</p>
<p>模糊查询：<strong>头部进行模糊匹配(%%某某)</strong>，索引会失效，尾部进行模糊匹配（某某%%），索引不会失效。</p>
<p>or连接的条件：如果or前面的条件列有索引，后面的条件没有索引，所涉及的索引都不会引用到，只有两侧都有索引的时候，才有效</p>
<p>数据分布影响：如果索引比全表扫描更慢，则不使用索引，查询的数据大于一半，走全表不走索引。</p>
<p><strong>SQL提示</strong></p>
<blockquote>
<p>在sql语句中加入一些认为的提示来达到优化操作的目的</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># use index指定使用哪个索引<br>explain select * from table use index(idxname) ...<br><br># ignore index<br># force index 同上<br></code></pre></td></tr></table></figure>
<p><strong>覆盖索引</strong></p>
<p>尽量使用覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到，减少使用select *</p>
<p>using index condition：查找使用了索引，但是需要回表查询数据</p>
<p>using where, using index：查询使用了索引，但是不需要回表</p>
<img src="/2024/02/10/database-mysql/image-20240218221642388.png" class="" title="image-20240218221642388">
<p>前两条不需要回表，后一条需要回表</p>
<p><strong>前缀索引</strong></p>
<blockquote>
<p>将字符串的前缀提取出来，创建索引，可以节约索引空间</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># n表示取column_name列的前n个数据<br>CREATE INDEX idx_XXX ON table_name(column_name(n));<br><br># 计算前缀长度的选择性，越接近1越好<br>SELECT COUNT(DISTINCT substring(email, 1, 5)) / COUNT(*) FROM table_name;<br></code></pre></td></tr></table></figure>
<p><strong>单列索引和联合索引选择</strong></p>
<p>如果涉及到多个查询条件，推荐使用联合索引，联合索引会更少的回表查询</p>
<h4 id="Quetion"><a href="#Quetion" class="headerlink" title="Quetion"></a>Quetion</h4><img src="/2024/02/10/database-mysql/image-20240218221919863.png" class="" title="image-20240218221919863">
<p>建立id主键，username，password联合索引</p>
<ul>
<li><h4 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a><strong>索引设计原则</strong></h4></li>
</ul>
<img src="/2024/02/10/database-mysql/image-20240218224016746.png" class="" title="image-20240218224016746">
<h3 id="3、SQL优化"><a href="#3、SQL优化" class="headerlink" title="3、SQL优化"></a>3、SQL优化</h3><ul>
<li><h4 id="插入数据insert优化"><a href="#插入数据insert优化" class="headerlink" title="插入数据insert优化"></a><strong>插入数据</strong>insert优化</h4><p>批量插入而不是单条插入：批量插入只需要建立一次连接即可</p>
<p>建议手动提交事务：不需要每一次插入时自动开启和关闭事务，而是将所有insert执行结束以后统一关闭</p>
<p><strong>建议主键顺序插入</strong></p>
<p>大批量插入数据：使用Mysql数据库提供的load指令进行插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 如何使用load<br># 1、连接服务器时加上参数--local-infile<br>mysql --local-infile -u root -p<br><br># 2、设置全局参数local_infile为1<br>set global local_infile = 1;<br><br># 3、执行load指令将数据加载表结构中<br>load data local infile &#x27;文件名&#x27; into table &#x27;表名&#x27; fields teminated by &#x27;分割符&#x27; lines terminated by &#x27;行分隔符\n&#x27;;<br></code></pre></td></tr></table></figure>
</li>
<li><h4 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a><strong>主键优化</strong></h4></li>
</ul>
<blockquote>
<p>InnoDB中表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表。</p>
</blockquote>
<p>页大小为16kb，每个页至少包含两行数据</p>
<p>主键乱序插入可能会出现页分裂现象，执行删除操作会出现页合并现象</p>
<p>主键设计原则：</p>
<p>​    满足业务需求的情况下，尽量降低主键的长度</p>
<p>​    插入时尽量按照主键顺序插入，选择自增主键</p>
<p>​    尽量不要使用无序的自然主键</p>
<p>​    业务操作，避免对主键的修改</p>
<ul>
<li><strong>order by优化</strong></li>
</ul>
<p>排序方式</p>
<p>Using filesort：先找到数据再进行排序</p>
<p>Using index：通过有序索引直接返回，不需要额外排序</p>
<p>默认会对索引进行升序排序</p>
<ul>
<li><strong>limit优化</strong></li>
</ul>
<p>对于数据量大的，优化思路为使用覆盖索引+子查询</p>
<ul>
<li><p>count</p>
<p>count(*)优于count(1)&gt;count(主键)&gt;count(字段)</p>
</li>
<li><h4 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a><strong>update优化</strong></h4></li>
</ul>
<p>对需要更新的字段尽可能建立索引，这样如果处于多个事务情况下，只会使用行锁，如果没有建立索引，行锁会升级为表锁，无法进行并行</p>
<h3 id="4、视图-存储过程-触发器"><a href="#4、视图-存储过程-触发器" class="headerlink" title="4、视图/存储过程/触发器"></a>4、视图/存储过程/触发器</h3><blockquote>
<p>Mysql数据库当中的存储对象</p>
</blockquote>
<ul>
<li><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4></li>
</ul>
<blockquote>
<p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>
</blockquote>
<p>操作视图中的数据就和操作数据库表一样，可以将视图理解为一张不被存储的虚拟表。</p>
<p>视图当中的数据并不存在，如果往视图里面插入数据，数据将存在基表当中，如果不想给用户表的权限，可以给用户一个视图。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 创建视图<br>CREATE [OR REPLACE] VIEW 视图名称(列名列表) AS SELECT语句 [WITH CASCADED|LOCAL CHECk OPTION];<br><br># 查询视图<br># 查看创建视图语句<br>SHOW CREATE VIEW 视图名称;<br># 查看视图数据<br>SELECT * FROM 视图名称...;<br><br># 修改视图<br># 方式一、使用创建的语句，用REPLACE替换掉<br>CREATE[OR REPLACE]...<br># 方式二<br>ALTER VIEW 视图名称(列表名称) AS SELECT ...;<br><br># 删除视图<br>DROP VIEW IF EXISTS 视图名称<br></code></pre></td></tr></table></figure>
<p><strong>视图当中的检查选项</strong></p>
<p><strong>CASCADED（向下级联）</strong></p>
<p>当使用WITH CHECK OPTION子句创建视图时，Mysql会通过视图检查正在更改的每个行。进行校验，所插入的数据是否满足SELECT语句。</p>
<p>Mysql中还可以为视图再创建新的视图，新的视图如果有option选项会影响到之前的视图</p>
<p><strong>LOCAL（不向下级联，只是检查有option的条件）</strong></p>
<p><strong>视图的更新和作用</strong></p>
<p>要使视图可以更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下中任何一项，则该视图不可更新：</p>
<p>聚合函数、DISTINCT、GROUP BY、HAVING、UNION或者UNION ALL</p>
<p>作用：1、可以简化用户对数据的理解，简化用户操作。2、控制用户对表的查看权限。3、数据独立，屏蔽真实表结构。4、可以简化多表联查的操作。</p>
<ul>
<li><h4 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h4></li>
</ul>
<blockquote>
<p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输</p>
<p>思想上就是数据库SQL语言层面的代码封装与重用，下一次如果执行相同的业务直接调用存储过程</p>
</blockquote>
<p><strong>特点</strong>    好像跟函数有点像</p>
<p>封装、复用</p>
<p>可以接收参数，也可以返回数据</p>
<p>作用：减少网络交互，提升效率</p>
<blockquote>
<p>在命令行中，执行创建存储过程的sql时，需要通过关键字<code>delimiter</code>指定SQL语句的结束符</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 创建<br># 参数列表为IN/OUT/INOUT 参数名，分别表示参数输入，输出，输入和输出参数<br>CREATE PROCEDURE 存储过程名称([参数列表])<br>BEGIN<br>	--SQL语句，可以是多条<br>END;<br><br># 调用<br>CALL 名称([参数列表]);<br><br># 查看<br># 方法一，查看系统的数据库表，xxx为数据库名<br>SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = &#x27;XXX&#x27;;<br># 方法二，使用show查看创建过程<br>SHOW CREATE PROCEDURE 存储过程名称;<br><br># 删除<br>DROP PROCEDURE [IF EXISTS] 存储过程名称;<br><br># 定义结束符为$$<br>delimiter $$<br></code></pre></td></tr></table></figure>
<p><strong>系统变量</strong>（全局GLOBAL，会话SESSION）</p>
<p>重启以后系统参数会恢复为默认值</p>
<p>永久修改系统参数需要修改/etc/my.cnf中配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查看所有系统变量<br>SHOW [SESSION|GLOBAL] VARIABLES;<br>SHOW VARIABLES LIKE &#x27;..&#x27;;<br># 查看指定变量<br>SELECT @@[SESSION|GLOBAL].系统变量名<br><br># 设置系统变量，默认为SESSION级别<br>SET [SESSION|GLOBAL] 变量名=值;<br>SET @@[SESSION|GLOBAL].系统变量名 = 值;<br></code></pre></td></tr></table></figure>
<p><strong>用户自定义变量</strong></p>
<blockquote>
<p>作用域为当前连接</p>
<p>变量无需声明，如果拿到的是没有声明的变量，则会获得NULL</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 赋值，可以同时赋值多个变量，用逗号隔开<br>SET @var_name = expr;<br>SET @var_name := expr;<br><br># SELECT赋值<br>SELECT @var_name := expr;<br># 将sql查询的结果赋值给变量<br>SELECT 字段名 INTO @var_name FROM 表名;<br><br># 使用<br>SELECT @var_name;<br></code></pre></td></tr></table></figure>
<p><strong>局部变量</strong></p>
<blockquote>
<p>在局部生效，需要DECLARE声明，作用域在BEGIN…END块内</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 声明<br>DECLARE 变量名 变量类型(数据库数据的类型) [DEFAULT 默认值]<br><br># 赋值<br>SET 变量名 = 值;<br>SET 变量名 := 值;<br>SELECT 字段名 INTO @var_name FROM 表名;<br></code></pre></td></tr></table></figure>
<p><strong>存储过程相关语法</strong></p>
<blockquote>
<p>逻辑语言都在存储过程中定义，可以使用传入的参数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># IF 条件判断<br>IF 条件1 THEN<br>	...<br>ELSEIF 条件2 THEN<br>	...<br>ELSE<br>	...<br>END IF;<br><br># CASE 条件选择，WHEN后面可以有多种选择<br># 语法一<br>CASE case_value<br>	WHEN when_value1 THEN ...<br>	WHEN when_value2 THEN ...<br>	ELSE ...<br>END CASE;<br># 语法二<br>CASE <br>	WHEN 表达式真 THEN ...<br>	ELSE ...<br>END CASE;<br><br># WHILE循环<br>WHILE 条件 DO<br>	SQL逻辑<br>END WHILE：<br><br># REPEAT循环，当满足条件时，退出循环<br>REPEAT<br>	SQL逻辑...<br>	UNTIL 条件<br>END REPEAT;<br><br># LOOP循环<br># LOOP实现的是简单循环<br># LEAVE：配合循环使用，退出循环，作用类似于break<br># ITERATE：必须在循环中使用，作用类似于CONTINUE<br>[begin_label:] LOOP<br>	SQL逻辑<br>	<br>END LOOP[end_label]<br><br># 退出循环<br>LEAVE label;<br># 跳过本次进入下一次循环<br>ITERATE label;<br></code></pre></td></tr></table></figure>
<p><strong>游标Cursor</strong></p>
<p>游标（Cursor）是一种用于在存储过程或函数中遍历结果集的机制。游标允许逐行访问结果集，并在每行上执行相应的操作</p>
<p>通常情况下，当执行一个查询语句时，MySQL 会返回一个结果集，该结果集包含了查询返回的所有行。以使用游标来逐行处理这个结果集，而不是一次性获取所有结果。这在处理大量数据或需要逐行处理结果的情况下非常有用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 声明游标、打开游标、获取下一行、关闭游标<br>DELIMITER //<br><br>CREATE PROCEDURE process_users()<br>BEGIN<br>    DECLARE done INT DEFAULT FALSE;<br>    DECLARE user_id INT;<br>    DECLARE user_name VARCHAR(255);<br><br>    -- 声明游标<br>    DECLARE user_cursor CURSOR FOR <br>        SELECT id, name FROM users;<br><br>    -- 打开游标<br>    OPEN user_cursor;<br><br>    -- 循环遍历结果集<br>    read_loop: LOOP<br>        -- 获取下一行数据<br>        FETCH user_cursor INTO user_id, user_name;<br>        IF done THEN<br>            LEAVE read_loop;<br>        END IF;<br>        <br>        -- 处理当前行数据<br>        -- 这里可以执行相应的操作，如输出到日志或进行其他逻辑处理<br>        SELECT CONCAT(&#x27;User ID: &#x27;, user_id, &#x27;, User Name: &#x27;, user_name);<br><br>    END LOOP;<br><br>    -- 关闭游标<br>    CLOSE user_cursor;<br><br>END //<br><br>DELIMITER ;<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h4></li>
</ul>
<blockquote>
<p>有返回值的存储过程，存储函数的参数只能时IN类型’</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 语法结构<br>CREATE FUNCTION 存储函数名称([参数列表])<br>RETURNS type [characteristic...]<br>BEGIN<br>	--SQL语句<br>	RETURN ...;<br>END;<br><br>characteristics存储参数的特性<br>DETERMINISTIC : 相同的输入参数总是产生相同的结果<br>NO SQL : 不包含SQL语句<br>READS SQL DATA : 包含读取数据的语句，但不包含写入数据的语句<br></code></pre></td></tr></table></figure>
<ul>
<li><h4 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h4></li>
</ul>
<blockquote>
<p>在insert/update/delete之前或者之后，触发并执行触发器中定义的SQL语句集合。</p>
<p>使用别名OLD和NEW来引用触发器中发生变化的记录内容</p>
<p>触发器只支持行级触发，不支持语句级别触发：如果一个UPDATE语句影响了5行，则触发器会被出发5次</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">触发器类型</th>
<th style="text-align:center">NEW和OLD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">INSERT型触发器</td>
<td style="text-align:center">NEW表示将要或者已经新增的数据</td>
</tr>
<tr>
<td style="text-align:center">UPDATE型触发器</td>
<td style="text-align:center">OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</td>
</tr>
<tr>
<td style="text-align:center">DELETE型触发器</td>
<td style="text-align:center">OLD表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 创建触发器<br>CREATE TRIGGER trigger_name<br>BEFORE/AFTER(在之前还是之后) INSERT/UPDATE/DELETE(触发器类型)<br>ON tbl_name FOR EACH ROW --行级触发器<br>BEGIN<br>	trigger_stmt; # 触发器逻辑<br>END;<br><br># 查看<br>SHOW TRIGGERS;<br><br># 删除，数据库中的触发器<br>DROP TRIGGER [schema_name.]trigger_name;<br></code></pre></td></tr></table></figure>
<h3 id="5、锁"><a href="#5、锁" class="headerlink" title="5、锁"></a>5、锁</h3><blockquote>
<p>锁是计算机协调多个进程或线程并发访问某一资源的机制，用于保证数据的一致性和有效性。</p>
</blockquote>
<ul>
<li>全局锁</li>
</ul>
<p>对整个数据库进行加锁，加锁以后整个实例就处于只读状态，后续的DML的写语句，DDL语句以及更新操作的事务提交语句都会被阻塞</p>
<p>做数据库的全库逻辑备份的时候，会对所有的表进行锁定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 为表加全局锁<br>FLUSH TABLES WITH READ LOCK;<br><br># 备份数据库<br>musqldump -uroot -p1234 数据库&gt;文件名<br><br># 释放全局锁<br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure>
<ul>
<li>表级锁</li>
</ul>
<p>每次操作会锁住整张表，发生锁冲突的概率最高，并发度最低</p>
<p><strong>表锁</strong></p>
<blockquote>
<p>表共享读锁：对于所有客户端的连接都只能读，不能写</p>
<p>表独占写锁：对于获取锁资源的客户端可以写，其他客户端不能进行读也不能执行写会被阻塞</p>
</blockquote>
<p>语法</p>
<p>1、加锁：lock tables 表名… read/write</p>
<p>2、释放锁：unlock tables /  客户端断开连接</p>
<p><strong>元数据锁</strong>（meta data lock）</p>
<blockquote>
<p>MDL加锁过程是系统自动控制的，无需显示使用，在访问一张表的时候会自动加上</p>
<p>元数据锁就是对表结构进行加锁</p>
</blockquote>
<p>当对一张表进行增删改查的时候，自动会加上MDL读锁，当对表结构进行变更时，会自动加上MDL写锁</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">对应SQL</th>
<th style="text-align:center">锁类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">lock table xx read/write</td>
<td style="text-align:center">SHARED_READ_ONLY/SHARED_NO_READ_WRITE</td>
</tr>
<tr>
<td style="text-align:center">select、select .. lock in share mode</td>
<td style="text-align:center">SHARED_READ</td>
</tr>
<tr>
<td style="text-align:center">insert、update、delet、sekect…from update</td>
<td style="text-align:center">SHARED_WRITE</td>
</tr>
<tr>
<td style="text-align:center">alter table…</td>
<td style="text-align:center">EXCLUSIVVE</td>
</tr>
</tbody>
</table>
</div>
<p><strong>意向锁</strong></p>
<img src="/2024/02/10/database-mysql/image-20240222075448991.png" class="" title="image-20240222075448991">
<img src="/2024/02/10/database-mysql/image-20240222075706155.png" class="" title="image-20240222075706155">
<ul>
<li>行级锁</li>
</ul>
<blockquote>
<p>应用在InnoDB存储引擎当中</p>
</blockquote>
<p>InnoDB的数据时基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</p>
<p><strong>行锁</strong></p>
<p>锁定单个行记录的锁，防止其他事务对此进行update和delete，在RC、RR隔离级别都支持</p>
<p>1、共享锁（S）：允许一个事务去读取一行，阻止其他事务获得相同数据集的排它锁，其他事务能读不能写</p>
<p>2、排它锁（X）：允许获取排它锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排它锁，其他事务不能写也不能读</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">SQL</th>
<th style="text-align:center">行锁类型</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">INSERT</td>
<td style="text-align:center">排它锁</td>
<td style="text-align:center">自动加锁</td>
</tr>
<tr>
<td style="text-align:center">UPDATE</td>
<td style="text-align:center">排它锁</td>
<td style="text-align:center">自动加锁</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">排它锁</td>
<td style="text-align:center">自动加锁</td>
</tr>
<tr>
<td style="text-align:center">SELECT</td>
<td style="text-align:center">不加任何锁</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SELECT … LOCK IN SHARE MODE</td>
<td style="text-align:center">共享锁</td>
<td style="text-align:center">手动加锁</td>
</tr>
<tr>
<td style="text-align:center">SELECT … FOR UPDATE</td>
<td style="text-align:center">排它锁</td>
<td style="text-align:center">手动</td>
</tr>
</tbody>
</table>
</div>
<p><strong>间隙锁</strong></p>
<p>锁定索引记录间隙，确保索引记录间隙不变，防止其他事务在这个间隙执行insert，产生幻读，在RR级别下支持</p>
<p><strong>临建锁</strong>（next-key）</p>
<p>同时锁住行记录也锁住间隙</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># 查询数据库中的锁<br>select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;<br></code></pre></td></tr></table></figure>
<h3 id="6、InnoDB引擎"><a href="#6、InnoDB引擎" class="headerlink" title="6、InnoDB引擎"></a>6、InnoDB引擎</h3><ul>
<li><h4 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a><strong>逻辑存储结构</strong></h4></li>
</ul>
<p>表空间（ibd文件）：一个mysql实例可以对应多个表空间，用于存储记录、索引等数据</p>
<p>段：分为数据段、索引段、回滚段，InnoDB是索引组织表，数据段就是B+书的叶子节点，索引段即是B+书的非叶子节点，段用来管理多个区</p>
<p>区：表空间的单元结构，每个区的大小为1M，一个区中一共有64个连续的页</p>
<p>页：页大小16kB，是InnoDB存储引擎磁盘管理的最小单元，保证页的连续性，会申请4-5个区</p>
<img src="/2024/02/10/database-mysql/image-20240223204149464.png" class="" title="image-20240223204149464">
<ul>
<li><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4></li>
</ul>
<img src="/2024/02/10/database-mysql/innodb-architecture-8-0.png" class="" title="innodb-architecture-8-0">
<p><strong>内存结构</strong></p>
<blockquote>
<p>磁盘结构存储的是一些表空间和表数据文件，包括日志表空间，系统表空间，撤销表空间，重做表空间等等</p>
</blockquote>
<p>buffer pool缓存池</p>
<p>缓冲区是内存中的一个区域，可以缓冲存储磁盘上经常要操作的数据，利用局部性原理减少磁盘IO，加快处理速度</p>
<p>缓冲池以page页为单位，底层采用链表数据结构管理page</p>
<p>change buffer更改缓存，<strong>针对非唯一二级索引页</strong></p>
<p>当需要对数据进行变更，即执行DML语句时，如果buffer pool中不存在当前数据page，不会直接操作磁盘，会先将数据变更缓存在change buffer在未来数据被读取的时候，再将数据合并恢复到buffer pool中</p>
<p>Adaptive Hash Index自适应哈希索引</p>
<p>log buffer日志缓存区</p>
<p><strong>后台线程</strong></p>
<blockquote>
<p>作用：将InnoDB缓冲区当中的数据在合适的时间写入到磁盘当中</p>
</blockquote>
<p>1、Master Thread</p>
<p>核心后台线程，负责调度其他线程，将缓冲池中的数据异步刷新到磁盘当中，保持数据的一致性</p>
<p>2、IO Thread</p>
<p>采用的是AIO（异步非阻塞IO）来处理IO请求</p>
<p>4个读线程、4个写线程、1个日志线程、1个插入缓存线程（写缓冲区刷新到磁盘）</p>
<p>3、Purge Thread</p>
<p>回收事务已经提交的undo log，在事务提交之后，undo log可能不用了，就用它来回收</p>
<p>4、Page Cheaner Thread</p>
<p>协助Master Thread刷新脏页到磁盘的线程</p>
<ul>
<li><h4 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h4></li>
</ul>
<p>事务的原子性、一致性和持久性是通过日志文件来保证的，包括redo.log和undo.log</p>
<p>事务的隔离性是通过锁+MVCC（多版本并发控制）来进行保证的</p>
<p><strong>redo log</strong>事务的持久性（事务提交后数据的改变是永久的）</p>
<p>重做日志，记录事务提交时数据页的物理修改，用来实现事务的持久性(事务一旦提交，对数据的改变时持久的）</p>
<p>当系统在执行Mysql的DML语句时，会先从数据库缓存中查找是否有对应的页面，如果在缓存当中则对数据进行修改，这种在缓冲中修改后但还未写入磁盘的数据页，叫做脏页，后通过后台进程写入到磁盘当中，如果在写入的过程中发生异常，就会出现持久性消失的现象</p>
<p>redo log会把数据页的变化记录到redo log当中，当事务提交时，会把redo log刷新到磁盘当中，可以通过log对数据进行恢复，如果redo log刷新页失败，则事务执行也就失败，不影响一致性</p>
<p><strong>undo log</strong>事务的原子性（事务是最小操作单位，要么全部成功，要么全部失败）</p>
<p>回滚日志，用于记录数据被修改前的信息，提供回滚和MVCC。当执行DML语句时，会记录数据变化前的数据长什么样，在回滚日志中，记录的时执行sql的反向操作，逆操作</p>
<p>undo log存放在段当中，回滚段</p>
<ul>
<li><h4 id="MVCC多版本并发控制"><a href="#MVCC多版本并发控制" class="headerlink" title="MVCC多版本并发控制"></a>MVCC多版本并发控制</h4></li>
</ul>
<blockquote>
<p>Mutil-Version Concurrency Control，多版本并发控制。维护一个数据的多个版本，使得读写此操作没有冲突。依赖于数据库记录中的三个隐式字段、undo log日志、readView</p>
</blockquote>
<p><strong>相关概念</strong></p>
<p>当前读：读取的时记录的最新版本。因为Mysql的默认隔离界别是RR（repeatable read）可重复读，所以当另一个事务对数据进行修改时，当前事务读到的数据就不是当前最新的版本。要想读到最新版本，可以通过select .. lock in share mode,select .. for update来完成</p>
<p>快照读：正常的select（不加锁）就是快照读，读取的是数据的可见版本</p>
<p>Read Committed：每一次select 都会生成一个快照读</p>
<p>Repeatable Read：开始事务后第一个select才是产生快照读的地方，后面的select都是查询快照</p>
<p>Serializable：快照读会退化为当前读</p>
<p><strong>记录当中的隐藏字段</strong></p>
<p>DB_TRX_ID：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</p>
<p>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本，用于配合undo log<br>DB_ROW_ID：隐藏主键，表结构没有主键，则会自动生成隐藏字段</p>
<p><strong>undo log日志</strong></p>
<p>如果使用insert的时候产生的日志只在回滚的时候需要，在事务提交后，可以立即删除</p>
<p>如果使用的是update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读的时候也需要，不会立即被删除</p>
<img src="/2024/02/10/database-mysql/image-20240224160500080.png" class="" title="image-20240224160500080">
<p><strong>ReadView</strong></p>
<p>读视图：快照读SQL执行时MVCC提取数据的一句，记录并维护系统当前活跃的事务id</p>
<p>字段，通过对比当前事务的id：trx_id和下面的id进行对比来实现版本访问控制</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">m_ids</td>
<td style="text-align:center">当前活跃的事务ID集合</td>
</tr>
<tr>
<td style="text-align:center">min_trx_id</td>
<td style="text-align:center">最小活跃事务ID</td>
</tr>
<tr>
<td style="text-align:center">max_trx_id</td>
<td style="text-align:center">预分配事务ID，当前最大事务ID+1</td>
</tr>
<tr>
<td style="text-align:center">creator_trx_id</td>
<td style="text-align:center">ReadView创建者的事务ID</td>
</tr>
</tbody>
</table>
</div>
<img src="/2024/02/10/database-mysql/image-20240224161313751.png" class="" title="image-20240224161313751">
<p><strong>Read Commited</strong>读提交下的规则</p>
<blockquote>
<p>事务中每一次执行快照读时都会生成ReadView</p>
</blockquote>
<img src="/2024/02/10/database-mysql/image-20240224162152111.png" class="" title="image-20240224162152111">
<p>通过上面四条规则可以找到最新已经提交的事务版本</p>
<p><strong>Repeatable Read</strong>可重复读的情况</p>
<blockquote>
<p>仅在事务中第一次执行快照读的时候生成ReadView，后续会复用该ReadView</p>
</blockquote>
<img src="/2024/02/10/database-mysql/image-20240224162359110.png" class="" title="image-20240224162359110">
<p>隔离性：保证事务不在外部并发操作影响下独立完成，通过MVCC+锁来保证</p>
<p>一致性：事务完成时，所有数据都保持一致，通过日志实现</p>
<img src="/2024/02/10/database-mysql/image-20240224162626695.png" class="" title="image-20240224162626695">
<h3 id="7、MySQL管理"><a href="#7、MySQL管理" class="headerlink" title="7、MySQL管理"></a>7、MySQL管理</h3><ul>
<li>系统数据库</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据库</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mysql</td>
<td style="text-align:center">存储Mysql服务器正常运行所需要的各种信息（用户、权限等）</td>
</tr>
<tr>
<td style="text-align:center">information_schema</td>
<td style="text-align:center">提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型以及访问权限</td>
</tr>
<tr>
<td style="text-align:center">performance_schema</td>
<td style="text-align:center">为Mysql服务器运行时状态提供了一个底层监控功能，用于收集数据库服务器性能参数</td>
</tr>
<tr>
<td style="text-align:center">sys</td>
<td style="text-align:center">方便开发人员进行性能调优和诊断的视图</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>常用工具</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs mysql"># mysql [option] [database]<br>mysql<br>	-u, --user=		 # 指定用户名<br>    -p, --password=		# 指定密码<br>    -h, --host=		# 指定服务器ip或域名<br>    -p, --port=		# 指定端口号<br>    -e, --execute=	# 执行sql语句并推出<br></code></pre></td></tr></table></figure>
<p>mysqladmin</p>
<p>​    执行管理操作的客户端程序</p>
<p>​    —help查看帮助文档</p>
<p>mysqlbinlog</p>
<p>​    如果查看一些二进制文本的数据，使用这个可以进行数据查看</p>
<p>mysqlshow</p>
<p>​    客户端对象查找工具，可以用于查找存在哪些数据库、数据库中的表、表中的列或者索引</p>
<p>​    —count 显示数据库及表的统计信息</p>
<p>​    -i 显示指定数据库或指定表的状态信息</p>
<p><strong>mysqldump</strong></p>
<p>​    用于备份数据库或在不同数据库之间进行数据迁移</p>
<p><strong>mysqlimport/source</strong></p>
<p>​    用于数据的导入工具</p>
<h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><p>1、InnoDB数据页中的数据存储</p>
<p>2、B+树是如何进行查询的</p>
<p>3、MySql单表最大限制，为什么</p>
<p>4、索引失效有哪些</p>
<p>5、count（*）和count（1）哪个性能好一些</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Database</tag>
        <tag>Mysql</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间的通信方式</title>
    <url>/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>每个进程的用户地址空间是独立的，一般情况之下，不同的进程是<strong>无法</strong>通过进程间各自的地址空间来进行互相访问，但是不同的进程所拥有的内核空间是共享的，因此如果不同进程之间需要进行通信必须要通过内核。</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道通信分为匿名管道和命名管道，通过名字可以区分，匿名管道是无法获取和控制的管道，命名管道是通过用户可以自己建立的管道。</p>
<p>管道智能进行半双工的通信，即数据传输是单向的，如果想要实现互相通信，就需要创建两个管道。</p>
<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><ul>
<li>在linux中的<code>|</code>竖线就是一个管道，将管道符前的操作的输出作为管道符后的操作的输入</li>
</ul>
<p>一个匿名管道的创建会使用到下面的系统调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure>
<p>表示创建了一个匿名管道并返回了两个文件描述符，一个是管道读取端的描述符<code>fd[0]</code>，另一个是管道写入端的描述符<code>fd[1]</code>，<strong>匿名管道是特殊的文件，只存在于内存当中，不存在于文件系统中</strong></p>
<p>管道实际上就是内核中的一串缓存，进程通过文件描述符来对这一串缓存进行读写操作</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130223824673.png" class="" title="image-20240130223824673">
<p><strong>如果说需要实现多个进程之间的通信</strong>，可以使用<code>fork</code>操作来创建子进程，创建子进程时，子进程会同时复制父进程的文件描述符，两个进程便可以通过各自的文件描述符来进行跨进程之间的通信。</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130224638178.png" class="" title="image-20240130224638178">
<p>通过对文件描述符的开放和关闭，可以控制父进程和子进程之间的读写操作。</p>
<ul>
<li>如：父进程关闭读取的 fd[0]，只保留写入的 fd[1]；子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>
<li>便可以实现从父进程向子进程的数据写入</li>
</ul>
<p>实现多个进程之间匿名管道的通信另一种方式就是fork两个子进程，关闭父进程的文件描述符，开启子进程的<code>fd</code>，实现子进程之间的通信。</p>
<p>可以看出来，匿名管道的通信范围仅限于父子关系的进程。因为管道没有实体，没有管道文件，只能通过复制父进程的fd来使用文件描述符。</p>
<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><ul>
<li>在linux中可以通过<code>mkfifo</code>命令来创建并指定管道名字</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> myPipe<br></code></pre></td></tr></table></figure>
<p>因为命名管道，提前创建了一个类型为管道的设备文件，在进程中只要使用到这个设备，便可以互相通信。</p>
<p><strong>管道的通信方式，效率较低，不适合进程间的频繁交换数据</strong></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><blockquote>
<p>在管道通信的缺点下，消息队列可以解决进程间频繁交换数据的问题。</p>
</blockquote>
<p>消息队列是保护在内核中的消息列表，如果进程之间需要进行通信，只需要将消息放在对应的消息队列中便可以正常返回，无需阻塞等待，等到另一个进程需要的时候去消息队列中去读取便可以。</p>
<p>如果消息队列没有释放或者没有关闭操作系统，消息队列会一直存在，而匿名管道则是随着进程的生命周期的结束而销毁。</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>解决频繁交换数据的问题</p>
<p>两个进程之间就像发邮件一样可以你来我往进行沟通</p>
</li>
<li><p>进程发送消息后无需阻塞等待消息的接收</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>不适合比较大的数据传输</p>
<p>消息队列中的消息体是由结构化的数据结构来组织的，有最大长度的限制。</p>
</li>
<li><p>消息队列的通信过程中，存在用户态与内核态之间的数据拷贝开销</p>
</li>
</ul>
</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存用到的是现代操作系统中的内存管理的<strong>虚拟内存技术</strong>，每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。</p>
<p><strong>共享内存的机制：拿出一块虚拟地址空间，映射到相同的物理内存中。</strong>不同的进程可以使用各自的虚拟地址访问到这一片相同的物理内存。</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130232827259.png" class="" title="image-20240130232827259">
<ul>
<li><p>优点</p>
<ul>
<li>解决了消息队列中不适合大的数据的通信</li>
<li>不同进程之间无需进行频繁的用户态和内核态的转换，因为进程都是在自己的用户地址空间中来进行操作</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>对共享内存的读写问题</p>
<p>因为共享内存存储的信息一旦发生改变对于不同的进程都是可见的，所以会涉及到读写一致性的问题</p>
</li>
<li><p>共享内存也变为了临界资源，存在进程进程之间的竞争</p>
<p>需要保护机制，使得共享资源在任意时刻只能被一个进程访问。</p>
</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote>
<p>信号量可以提供对临界资源的保护</p>
</blockquote>
<p>信号量是一个整型的计数器，可以用于实现进程间的互斥以及同步，不是用于缓存进程间通信的数据。</p>
<p>信号量的大小表示为资源的数量，对信号量的操作方式有两种原子操作</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>通过PV操作可以控制进程对资源的互斥访问以及控制进程的同步顺序，<strong>涉及到操作系统的知识</strong></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><blockquote>
<p>在进程工作异常情况下，需要通过信号来通知进程</p>
</blockquote>
<p>信号是进程间通信机制中的唯一的异步通信方式，因为可以在任何时候发送信号到某一进程，一旦有信号产生，用户就可以进行对信号处理。</p>
<ul>
<li><p>信号的处理方式</p>
<ul>
<li>执行默认操作： 例如linux中的SIGTERM 信号，就是终止进程的意思</li>
<li>捕捉信号：可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数</li>
<li>忽略信号：当不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。</li>
</ul>
</li>
<li><p><code>SIGKILL</code> 和 <code>SEGSTOP</code>无法被捕捉和忽略。</p>
</li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket通信实现的是在不同主机之间的通信，分为两种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式</p>
<blockquote>
<p>基于 TCP 协议的通信方式需要客户和服务器之间建立TCP连接，进行三次握手。</p>
</blockquote>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234627976.png" class="" title="image-20240130234627976">
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<blockquote>
<p>基于UDP的Socket通信</p>
</blockquote>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234754230.png" class="" title="image-20240130234754230">
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>
<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>
<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程通信</tag>
      </tags>
  </entry>
  <entry>
    <title>C++使用zlib库来压缩文件</title>
    <url>/2024/01/26/C-%E4%BD%BF%E7%94%A8zlib%E5%BA%93%E6%9D%A5%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="C-使用zlib库来压缩文件"><a href="#C-使用zlib库来压缩文件" class="headerlink" title="C++使用zlib库来压缩文件"></a>C++使用zlib库来压缩文件</h2><p>zlib压缩库提供内存压缩和解压缩功能，包括对未压缩的完整性检查数据，提供支持的压缩方法为：deflation，默认使用压缩数据格式为zlib格式。</p>
<p>zlib库支持读取和写入gzip(.gz)格式的文件，zlib格式旨在紧凑且快速，可用于内存和通信渠道。gzip格式设计用于文件系统上的单文件压缩，比zlib具有更大的头部以维护目录信息，并且使用与zlib不同且更慢的检查方法。</p>
<p>该库不安装任何信号处理程序。解码器检查压缩数据的一致性，因此即使在输入损坏的情况下，库也不应崩溃。</p>
<h3 id="数据流结构"><a href="#数据流结构" class="headerlink" title="数据流结构"></a>数据流结构</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span>pf (*alloc_func)(<span class="hljs-built_in">void</span>pf opaque, uInt items, uInt size);<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span>   (*free_func)(<span class="hljs-built_in">void</span>pf opaque, <span class="hljs-built_in">void</span>pf address);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);</code>这个函数指针通常用于内存分配，允许用户自定义的内存分配函数</li>
<li><code>typedef void   (*free_func)(voidpf opaque, voidpf address);</code>这个函数指针通常用于内存释放，允许用户自定义的内存释放函数</li>
</ul>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">ZEXTERN <span class="hljs-type">int</span> ZEXPORT <span class="hljs-title">deflateInit</span><span class="hljs-params">(z_streamp strm, <span class="hljs-type">int</span> level)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>level</code>表示压缩级别，要么为<code>Z_DEFAULT_COMPRESSION</code>，要么介于0-9之间，1表示最佳速度，9表示最佳压缩，0表示没有压缩，<code>Z_DEFAULT_COMPRESSION</code>默认在6级别。</li>
<li><code>deflateInit</code> 返回 <code>Z_OK</code> 如果成功，则返回 <code>Z_MEM_ERROR</code> 如果没有 足够的内存，<code>Z_STREAM_ERROR</code> <code>level</code> 不是有效的压缩级别，<code>Z_VERSION_ERROR</code> <em>zlib</em> 库版本 （<code>zlib_version</code>） 不兼容 替换为调用方 （<code>ZLIB_VERSION</code>） 假定的版本。如果没有错误消息，<code>则 msg</code> 设置为 null。<code>deflateInit</code> 不 执行任何压缩：这将由 <code>deflate（）</code> 完成。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">ZEXTERN <span class="hljs-type">int</span> ZEXPORT <span class="hljs-title">deflate</span><span class="hljs-params">(z_streamp strm, <span class="hljs-type">int</span> flush)</span></span>;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>zlib</tag>
      </tags>
  </entry>
  <entry>
    <title>平方根倒数算法</title>
    <url>/2024/01/24/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="平方根倒数算法"><a href="#平方根倒数算法" class="headerlink" title="平方根倒数算法"></a>平方根倒数算法</h3><script type="math/tex; mode=display">
1/\sqrt{x}</script><h4 id="求一个数的平方根倒数"><a href="#求一个数的平方根倒数" class="headerlink" title="求一个数的平方根倒数"></a>求一个数的平方根倒数</h4><p>对于计算机来说求一个数的平方根一般有两种方式，二分法和牛顿迭代法</p>
<ul>
<li><p>二分法</p>
<p>EXP表示精度，从0-num不断开始计算mid的平方，直到left&gt;right，此时返回right的值即为所求的平方根，其中注意边界条件：</p>
<p>当mid <em> mid = num时，此时left需要加上EXP，往后的循环中mid </em> mid 都会大于num，所以right还会不停减小，直到right &lt; left，返回right，这时right已经在精度范围内</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;<br>    <span class="hljs-type">double</span> left = <span class="hljs-number">0</span>, right = num;<br> <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">double</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br> <br>        <span class="hljs-keyword">if</span> (mid * mid &lt;= num)<br>            left = mid + EXP;<br>        <span class="hljs-keyword">else</span><br>            right = mid - EXP;<br>    &#125;   <br> <br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>牛顿迭代法</p>
<p>牛顿迭代法是将原来的求开方问题转化为数学函数问题，即假设<code>x * x = n</code>，求n的开方转化为<code>x * x - n = 0</code>的解，即<code>y = x * x - n</code>与x轴的交点</p>
<p>代码中last表示上一次的切线与x轴的交点的x坐标，初始值为num，ret表示x = last时的切线与x轴的交点，不断迭代，直到ret - last小于精度，即达到精度返回ret。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == num)<br>        <span class="hljs-keyword">return</span> num;<br> <br>    <span class="hljs-type">double</span> last = num, ret = num;<br> <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        last = <span class="hljs-number">0.5</span> * (ret + num / ret);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(ret - last) &lt; EXP)<br>            <span class="hljs-keyword">break</span>;<br>        ret = last;<br>    &#125;   <br> <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>计算完平方根过后，再计算其倒数，也是一个对计算机来说并不是很友好的运算</p>
<h4 id="快速平方根倒数计算推导"><a href="#快速平方根倒数计算推导" class="headerlink" title="快速平方根倒数计算推导"></a>快速平方根倒数计算推导</h4><p>快速平方根算法是利用了计算机存储浮点数的特性并和牛顿迭代法来共同完成的，也是一个近似计算。对于牛顿迭代法，其精髓是如果能够找到一个接近于解的初始值，是有可能通过一次迭代或者较少次数的迭代达到比较高的近似解，而快速平方根算法旨在于找到一个较为近似的初始值。具体的运算如下。</p>
<p><strong>笔记中有一处笔误0xD5F400000应改成0x5F400000</strong></p>
<img src="/2024/01/24/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E7%AE%97%E6%B3%95/%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B.png" class="" title="运算过程">
<p>快速平方根算法代码</p>
<ul>
<li>初始值由0x5F400000改为了0x5f3759df，对于X/2代码中使用了位运算加速求解</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Q_rsqrt</span><span class="hljs-params">(<span class="hljs-type">float</span> number)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">float</span> x2, y;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> threehalfs = <span class="hljs-number">1.5F</span>;<br>    x2 = number * <span class="hljs-number">0.5F</span>;<br>    y = number;<br>    i = * ( <span class="hljs-type">long</span>* ) &amp;y;							<span class="hljs-comment">// evil floating point bit hack</span><br>    i = <span class="hljs-number">0x5f3759df</span> - (i &gt;&gt; <span class="hljs-number">1</span>);					<span class="hljs-comment">// what the fuck? </span><br>    y = * ( <span class="hljs-type">float</span> * ) &amp;i;<br>    y = y * (threehalfs - ( x2 * y * y ) );		<span class="hljs-comment">// 1st iteration</span><br><span class="hljs-comment">//  y = y * (threehalfs - ( x2 * y * y ) );		// 2st iteration, can be removed</span><br>    <br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见用法</title>
    <url>/2024/01/04/git/</url>
    <content><![CDATA[<h4 id="怎样撤销一个已经push到远端的版本"><a href="#怎样撤销一个已经push到远端的版本" class="headerlink" title="怎样撤销一个已经push到远端的版本"></a>怎样撤销一个已经push到远端的版本</h4><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">每次<span class="hljs-built_in">push</span>之前线pull一下<br><br><span class="hljs-number">1</span>、查看当前提交的信息，找到需要撤回到的版本号复制，一串十六进制的数<br>git <span class="hljs-built_in">log</span><br><br><span class="hljs-number">2</span>、使用git reset<br>git reset --soft 复制的版本号<br><br><span class="hljs-number">3</span>、强制回退当前版本号<br><span class="hljs-comment">// 确认一下当前版本</span><br>git <span class="hljs-built_in">log</span><br><span class="hljs-comment">// 谨慎使用，强制使用本地仓库代码修改远程仓库</span><br>git <span class="hljs-built_in">push</span> orgin master --force<br></code></pre></td></tr></table></figure>
<h4 id="新建分支并同步到远端的分支"><a href="#新建分支并同步到远端的分支" class="headerlink" title="新建分支并同步到远端的分支"></a>新建分支并同步到远端的分支</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 在本地新建一个名字为branch_name的分支，并与远端的origin/branch_name同步</span><br>git checkout -<span class="hljs-keyword">b </span><span class="hljs-keyword">branch_name </span><span class="hljs-keyword">origin/branch_name</span><br></code></pre></td></tr></table></figure>
<h4 id="解决git-clone超时的问题"><a href="#解决git-clone超时的问题" class="headerlink" title="解决git clone超时的问题"></a>解决git clone超时的问题</h4><p>从github上clone代码仓库报错<code>Failed to connect to github.com port 443 after 21038 ms: Couldn&#39;t connect to server</code>且尝试去ping一下github官网会丢包</p>
<img src="/2024/01/04/git/image-20231204110955462.png" class="" title="image-20231204110955462">
<p>解决方案</p>
<p>修改系统的hosts，跳过域名解析的过程，直接用ip地址访问</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.30.255.112</span> github.com git<br><span class="hljs-number">185.31.16.184</span> github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure>
<img src="/2024/01/04/git/image-20231204111125551.png" class="" title="image-20231204111125551">
<p>修改hosts需要给文件更高的权限</p>
<img src="/2024/01/04/git/image-20231204111350240.png" class="" title="image-20231204111350240">
<h4 id="github中git-push出现超时的问题"><a href="#github中git-push出现超时的问题" class="headerlink" title="github中git push出现超时的问题"></a>github中git push出现超时的问题</h4><img src="/2024/01/04/git/image-20231204112945547.png" class="" title="image-20231204112945547">
<p>解决方案</p>
<p>1、打开本机的代理服务器</p>
<img src="/2024/01/04/git/image-20231204113100512.png" class="" title="image-20231204113100512">
<p>2、取消git config里面的http和https代理</p>
<img src="/2024/01/04/git/image-20231204113208566.png" class="" title="image-20231204113208566">
<p>3、设置http代理服务器</p>
<img src="/2024/01/04/git/image-20231204113304822.png" class="" title="image-20231204113304822">
<h4 id="linux中输出一个文件夹下面的所有文件名"><a href="#linux中输出一个文件夹下面的所有文件名" class="headerlink" title="linux中输出一个文件夹下面的所有文件名"></a>linux中输出一个文件夹下面的所有文件名</h4><ul>
<li><strong><code>/path/to/directory</code></strong>: 替换为目标目录的路径。</li>
<li><strong><code>-maxdepth 1</code></strong>: 限制<code>find</code>的搜索深度为1，即仅在指定的目录中搜索，而不会搜索其子目录。</li>
<li><strong><code>-type f</code></strong>: 限制搜索结果为普通文件（不包括目录和其他类型的文件）。</li>
<li><strong><code>-exec basename &#123;&#125; \;</code></strong>: 对每一个找到的文件执行<code>basename</code>命令，即输出文件的基本名称。<code>&#123;&#125;</code>是<code>find</code>命令的占位符，表示每个找到的文件的路径。<code>\;</code>表示命令结束。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find /path/to/directory -maxdepth 1 -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">basename</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure>
<h4 id="git查看远端仓库地址"><a href="#git查看远端仓库地址" class="headerlink" title="git查看远端仓库地址"></a>git查看远端仓库地址</h4><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> -<span class="hljs-string">v</span><br><br><span class="hljs-comment"># 更改远程仓库</span><br><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> 仓库地址<br></code></pre></td></tr></table></figure>
<h4 id="查看代码贡献量"><a href="#查看代码贡献量" class="headerlink" title="查看代码贡献量"></a>查看代码贡献量</h4><blockquote>
<p>按照各个作者的修改代码总数排序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%aN&quot;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> count author; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$author</span> &quot;</span>; git <span class="hljs-built_in">log</span> --author=<span class="hljs-string">&quot;<span class="hljs-variable">$author</span>&quot;</span> --pretty=tformat: --numstat | awk <span class="hljs-string">&#x27;&#123; add += $1; subs += $2 &#125; END &#123; total = add + subs; printf &quot;%d\n&quot;, total &#125;&#x27;</span>; <span class="hljs-keyword">done</span> | <span class="hljs-built_in">sort</span> -rnk2<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101现代计算机图形学入门-02</title>
    <url>/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/</url>
    <content><![CDATA[<h2 id="计算机图形学02"><a href="#计算机图形学02" class="headerlink" title="计算机图形学02"></a>计算机图形学02</h2><blockquote>
<p>Transform（变换），图形的变换</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">为什么学习变换<br>2维变换：旋转、缩放、切变<br>齐次坐标 Homogeneous coordinates<br>组合变换<br>3维变换<br></code></pre></td></tr></table></figure>
<h3 id="二维变换"><a href="#二维变换" class="headerlink" title="二维变换"></a>二维变换</h3><p>将矩阵和变换联系起来</p>
<ul>
<li><p>1、缩放</p>
<p>将坐标在向量左边乘一个对角矩阵</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161524873-17084118809551.png" class="" title="image-20231116161524873">
</li>
<li><p>2、反射对称</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161727694-17084118809562.png" class="" title="image-20231116161727694">
</li>
<li><p>3、切变（Shear Matrix）</p>
<p>水平方向坐标发生改变，竖直方向不变，水平的移动大小，按照Y的当前坐标成正比</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161842894-17084118809563.png" class="" title="image-20231116161842894">
</li>
<li><p>4、旋转</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116164956551-17084118809564.png" class="" title="image-20231116164956551">
<p>.PNG)</p>
</li>
</ul>
<p>通过矩阵乘积可以将一个输入图形的坐标转化为想要的输出矩阵的坐标，这样的变换都称为<strong>线性变换</strong></p>
<h3 id="齐次坐标（homogeneous-coordinates）"><a href="#齐次坐标（homogeneous-coordinates）" class="headerlink" title="齐次坐标（homogeneous coordinates）"></a>齐次坐标（homogeneous coordinates）</h3><blockquote>
<p>平移操作无法使用线性变化即矩阵的乘法来获得，所以引入齐次坐标，增加一个维度</p>
<p>齐次坐标的矩阵操作，可以叫做仿射变换</p>
</blockquote>
<p>增加维度以后，通过与新增加列的运算就可以达到平移的变换</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116165833300-17084118809565.png" class="" title="image-20231116165833300">
<ul>
<li><p>Q：Why？将二维的点，增加一个1，将二维的向量，增加一个0</p>
<p>1、通过增加的维度可以标识当前的坐标表示点还是表示向量。可以保证向量具有平移不变性</p>
<p>2、最后一个维度的运算正好表示运算结果的性质</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116170520355-17084118809566.png" class="" title="image-20231116170520355">
<p>3、点+点，得到的结果为两个点的终点，因为第三维为2，与两点之和相除便是中点</p>
</li>
</ul>
<p><strong>齐次坐标下的变换操作矩阵</strong></p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116171041924-17084118809567.png" class="" title="image-20231116171041924">
<ul>
<li><p>逆变换</p>
<p>乘以变化矩阵的逆矩阵，可以变换成原来的图片</p>
</li>
</ul>
<h3 id="变换组合"><a href="#变换组合" class="headerlink" title="变换组合"></a>变换组合</h3><p>1、复杂变换可以通过简单的变化来得到</p>
<p>2、变换的顺序不同，得到的结果不同</p>
<p>3、变换的组合，等价于原始矩阵依次乘上按照一定顺序的齐次矩阵</p>
<ul>
<li>将一个变化还原，或者以任意一个点为中心进行变化，可以先移动到原点，再进行操作</li>
</ul>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116200444279-17084118809568.png" class="" title="image-20231116200444279">
<h3 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h3><ul>
<li><p>三维点和三维向量</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116201112834-17084118809569.png" class="" title="image-20231116201112834">
</li>
<li><p>三维变换齐次矩阵</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116201139440-170841188095610.png" class="" title="image-20231116201139440">
</li>
<li><p>旋转</p>
<p>绕哪个轴旋转哪个轴保持不变</p>
<p>对于一般性的旋转，可以使用简单旋转的组合来完成</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231118142130480-170841188095611.png" class="" title="image-20231118142130480">
</li>
<li><p>使用旋转公式</p>
<p>旋转角度定义为a</p>
<p>旋转轴定义为n</p>
<p>其中<strong>I</strong>表示为单位矩阵</p>
<p>表示为，沿着旋转轴n旋转a的角度得到的旋转矩阵</p>
<img src="/2023/12/16/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231118142833380-170841188095612.png" class="" title="image-20231118142833380">
</li>
</ul>
<h3 id="观测变换（Viewing-transformation）"><a href="#观测变换（Viewing-transformation）" class="headerlink" title="观测变换（Viewing transformation）"></a>观测变换（Viewing transformation）</h3><blockquote>
<p>视图变换、投影变换（正交投影，透视投影）</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>GAMES101</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101现代计算机图形学入门-01</title>
    <url>/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/</url>
    <content><![CDATA[<h2 id="计算机图形学01"><a href="#计算机图形学01" class="headerlink" title="计算机图形学01"></a>计算机图形学01</h2><blockquote>
<p>应用场景：电影，动画，可视化，家具，模拟，虚拟现实（VR），GUI（图形用户接口），字体</p>
</blockquote>
<ul>
<li>好的画面：足够亮（全局光照）</li>
</ul>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-number">1</span>、光栅化	Resterization<br><span class="hljs-number">2</span>、曲线曲面（几何）	Curves <span class="hljs-keyword">and</span> Meshes<br><span class="hljs-number">3</span>、光线追踪	Ray	Tracing<br><span class="hljs-number">4</span>、动画/模拟	Animation/Simulation<br></code></pre></td></tr></table></figure>
<h3 id="计算机图形学-VS-计算机视觉"><a href="#计算机图形学-VS-计算机视觉" class="headerlink" title="计算机图形学 VS 计算机视觉"></a>计算机图形学 VS 计算机视觉</h3><img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104113151777-17084112899531.png" class="" title="image-20231104113151777">
<ul>
<li><p>MODEL，计算机画（图形学）</p>
<p>正向箭头：将三维空间的图形在二维中展示出来，特指图像渲染</p>
<p>自我箭头：MODEL的自我渲染，与图像无关</p>
</li>
<li><p>IMAGE，计算机看（计算机视觉）</p>
<p>反向箭头：从图形中推导和识别出图像的特征</p>
<p>自我箭头：依赖深度学习对图像进行处理</p>
</li>
</ul>
<p>作业相关</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、作业链接：http:<span class="hljs-regexp">//g</span>ames-cn.org<span class="hljs-regexp">/forums/</span>topic<span class="hljs-regexp">/allhw/</span><br><span class="hljs-number">2</span>、作业使用的系统：smartchair<br><span class="hljs-number">3</span>、Use IDE：集成开发环境<br></code></pre></td></tr></table></figure>
<h3 id="线性代数——A-Swift-and-Brutal-Introduction-to-Linear-Algebra"><a href="#线性代数——A-Swift-and-Brutal-Introduction-to-Linear-Algebra" class="headerlink" title="线性代数——A Swift and Brutal Introduction to Linear Algebra"></a>线性代数——A Swift and Brutal Introduction to Linear Algebra</h3><blockquote>
<p>数学：线性代数，微积分，统计，物理：光学，力学，信号处理，数值分析</p>
</blockquote>
<h4 id="向量Vectors"><a href="#向量Vectors" class="headerlink" title="向量Vectors"></a>向量Vectors</h4><p>方向、长度、向量的模、单位向量、点乘、余弦值</p>
<ul>
<li><p>点乘的重要性</p>
<p>使用向量的点积便于计算一个向量在另一个向量上的投影（光的投影）</p>
<p>衡量两个向量的接近程度</p>
<p>分解一个向量（使用投影可以进行加减运算）分解为垂直方向和水平方向</p>
<p>确定向量的基本方向，大于零同方向，小于零反方向</p>
</li>
</ul>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104150955701-17084112899532.png" class="" title="image-20231104150955701">
<ul>
<li><p>叉乘的重要性（使用右手螺旋定则可以确定叉乘的方向）</p>
<p>叉乘可以建立一个三位空间的直角坐标系</p>
<p>任意的三维空间向量都可以分解到三位的单位向量中</p>
</li>
</ul>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104164704660-17084112899533.png" class="" title="image-20231104164704660">
<p>​        叉乘的代数表示（矩阵相乘）</p>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104164849274-17084112899534.png" class="" title="image-20231104164849274">
<p><strong>Q&amp;A:判断一个点是否在三角形的内部</strong></p>
<p>对三角形做逆时针，分别做三条边之间的向量，三个顶点分别于需要判断的点进行叉乘，如AB叉乘AP，如果都大于0，则说明在三角形内部。</p>
<p>结论比较简单，很容易在计算机中使用公式实现出来。</p>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104165645532-17084112899535.png" class="" title="image-20231104165645532">
<ul>
<li><p>矩阵的重要性</p>
<p>图像转换，旋转，平移，剪切，数乘</p>
<ul>
<li><p>矩阵的乘积（第一个矩阵的列数等于第二个矩阵的行数）</p>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231116154858801-17084112899536.png" class="" title="image-20231116154858801">
<p><strong>矩阵的乘积没有任何交换律</strong>，但是有结合律</p>
</li>
<li><p>矩阵与向量的乘积（列向量，可以表示为点的坐标）</p>
<p>可以利用矩阵乘积做一些变化操作（如下：将x，y变化为-x，y）</p>
<img src="/2023/12/15/GAMES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231116155210293-17084112899537.png" class="" title="image-20231116155210293">
</li>
<li><p>转置矩阵、单位矩阵（对角矩阵）</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>GAMES101</tag>
      </tags>
  </entry>
  <entry>
    <title>iEDA项目代码实践</title>
    <url>/2023/09/10/iEDA-test/</url>
    <content><![CDATA[<h2 id="iEDA工程代码实践—布局合法化（LG）"><a href="#iEDA工程代码实践—布局合法化（LG）" class="headerlink" title="iEDA工程代码实践—布局合法化（LG）"></a>iEDA工程代码实践—布局合法化（LG）</h2><blockquote>
<p>开源项目iEDA链接:<a href="https://gitee.com/oscc-project/iEDA.git">https://gitee.com/oscc-project/iEDA.git</a></p>
</blockquote>
<h3 id="一、理论知识"><a href="#一、理论知识" class="headerlink" title="一、理论知识"></a>一、理论知识</h3><p>布局合法化是全局布局以后的一个过程，在全局布局过后，规划版图中的宏单元会放置在相应的位置并保持不再移动，于此同时，对于标准单元的规划，也会通过一些相关算法完成大致位置的摆放，这些摆放是基于相关优化目标下进行的，例如线长，面积等，但是在全局布局中并不会考虑标准单元之间的非法情况，即标准单元重叠的问题，因此在布局合法化中，需要完成的任务就是在尽可能的不破坏全局布局的布局结构的情况下，使得所有标准单元不再重叠。核心算法用到的是<code>Abacus</code>算法和<code>Tetris</code>算法。</p>
<h3 id="二、Abacus算法"><a href="#二、Abacus算法" class="headerlink" title="二、Abacus算法"></a>二、Abacus算法</h3><blockquote>
<p>同一时间只放置一个单元</p>
</blockquote>
<p><strong>算法伪代码</strong></p>
<p><style>.xufjigkwffyy{}</style><img src="/2023/09/10/iEDA-test/image-20230823094215828.png" class="xufjigkwffyy" alt="image-20230823094215828"></p>
<p><strong>核心代码</strong></p>
<img src="/2023/09/10/iEDA-test/image-20230825151306959.png" class="" title="image-20230825151306959">
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1</span>、根据单元的x坐标进行排序<br><span class="hljs-number">2</span>、对于每一个排序好的单元，按照顺序取出每一个单元<br><span class="hljs-number">3</span>、遍历第一行，找出当前行中放置该单元后能够使得<span class="hljs-keyword">cost</span>最小的位置<br><span class="hljs-number">4</span>、按照第<span class="hljs-number">3</span>步的方式遍历每一行，找出全局中能够放置当前单元并使得<span class="hljs-keyword">cost</span>最小的位置<br><span class="hljs-number">5</span>、放置该单元<br></code></pre></td></tr></table></figure>
<p><strong>placeRow解析</strong></p>
<blockquote>
<p>这个函数是<code>AbacusLegalizer</code>中的一个函数，它用于在布局合法化过程中放置一个实例（instance）到一个行（row）中。函数的输入参数包括一个<code>LGInstance</code>实例指针、行的索引<code>row_idx</code>和一个标志<code>is_trial</code>，用于指示是否是试验性放置。</p>
</blockquote>
<p>该函数主要完成了以下工作：</p>
<ul>
<li>在给定的行中找到合适的间隔来放置实例。</li>
<li>计算放置实例的移动代价，包括实例在<code>x</code>和<code>y</code>方向上的移动代价以及超过最大移动约束的处罚。</li>
<li>进行非试验性放置时，更新簇的信息和间隔的剩余长度。</li>
</ul>
<img src="/2023/09/10/iEDA-test/image-20230825154317023.png" class="" title="image-20230825154317023">
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">函数的主要步骤如下：<br><span class="hljs-bullet">1.</span> 获取实例的形状（inst<span class="hljs-emphasis">_shape）。</span><br><span class="hljs-emphasis">2. 从_</span>layout对象中获取指定行的间隔列表（interval<span class="hljs-emphasis">_list）。</span><br><span class="hljs-emphasis">3. 通过搜索找到最近的间隔，即与实例重叠的间隔（interval_</span>idx）。<br><span class="hljs-bullet">   -</span> 如果找不到重叠的间隔，则返回INT32<span class="hljs-emphasis">_MAX表示失败。</span><br><span class="hljs-emphasis">4. 检查选定的间隔是否能够容纳实例的宽度，如果不行，则查找最近的非满间隔，并重新选择。</span><br><span class="hljs-emphasis">   - 如果找不到合适的间隔，则返回INT32_</span>MAX表示失败。<br><span class="hljs-bullet">5.</span> 将实例安排到选定的间隔中，形成一个簇（target<span class="hljs-emphasis">_cluster）。</span><br><span class="hljs-emphasis">6. 计算移动代价（movement_</span>cost）：<br><span class="hljs-bullet">   -</span> 从簇中的每个实例计算到目标位置的x方向移动代价，并累加到movement<span class="hljs-emphasis">_cost中。</span><br><span class="hljs-emphasis">   - 计算实例在y方向上的移动代价。</span><br><span class="hljs-emphasis">   - 将实例在x和y方向上的移动代价相加，得到实例的位移代价（inst_</span>displacement）。<br><span class="hljs-bullet">   -</span> 将实例位移代价加到movement<span class="hljs-emphasis">_cost中。</span><br><span class="hljs-emphasis">7. 根据最大移动约束处罚超过最大移动约束的位移代价。</span><br><span class="hljs-emphasis">8. 如果is_</span>trial为false，即非试验性放置，则替换簇的信息（replaceClusterInfo）和更新间隔的剩余长度（updateRemainLength）。<br><span class="hljs-bullet">9.</span> 返回移动代价（movement<span class="hljs-emphasis">_cost）。</span><br></code></pre></td></tr></table></figure>
<h3 id="三、Tetris算法"><a href="#三、Tetris算法" class="headerlink" title="三、Tetris算法"></a>三、Tetris算法</h3><p><code>Abacus</code>是在<code>Tetris</code>算法上的改进，在<code>Tetris</code>中，对于<code>placeRow</code>的选择是一个单次即可完成的过程，即在当前行中找到了能够合适的位置以后即将该<code>instance</code>放置到该行。因此整体算法流程相似，但复杂度会降低很多。</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">1</span>、根据单元的<span class="hljs-keyword">x</span>坐标进行排序<br><span class="hljs-number">2</span>、对于每一个排序好的单元，按照顺序取出每一个单元<br><span class="hljs-number">3</span>、遍历第一行，找出当前行中放置该单元后能够使得cost最小的位置<br><span class="hljs-number">4</span>、放置该单元<br><br>若改行无法放置该单元，进行换行策略选择，重新执行，直到所有行都无法放置，返回<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure>
<p><style>.xngduuplfpuq{zoom: 67%;}</style><img src="/2023/09/10/iEDA-test/image-20230825163454933.png" class="xngduuplfpuq" alt="image-20230825163454933"></p>
<p>因此对<code>iEDA</code>原始代码<code>Abacus</code>算法调整成<code>Tetris</code>只需要确定两个策略即可：1、如何选择当前<code>instance</code>初始行的策略。2、若初始行无法放置当前<code>instance</code>后，选择其它行的调整策略。</p>
<ul>
<li><p>选择初始行策略</p>
<blockquote>
<p>合法化是在全局布局过后的步骤，应尽可能的减少相关单元的移动，且尽可能地保证单元移动后和移动前地位置相近，因此最好是在该单元所在行的附近行进行移动</p>
</blockquote>
<p>1、加上<code>_row_height</code>后做除法</p>
</li>
</ul>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">auto row_idx = i<span class="hljs-symbol">nt32</span>_t<span class="hljs-comment">((inst_shape.get_center()</span>.get_y<span class="hljs-comment">()</span>+float_t<span class="hljs-comment">(_row_height/2)</span>)/_row_height);<br><span class="hljs-keyword">if</span><span class="hljs-comment">(inst_shape.get_ll_y()</span> <span class="hljs-meta">%</span> _row_height == <span class="hljs-number">0</span>)&#123;<br>  row_idx -= <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>​        2、直接使用<code>y</code>坐标与<code>_row_height</code>做整数相除</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">auto row_idx <span class="hljs-operator">=</span> inst_shape.get_center().get_y()/_row_height<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<ul>
<li>换行策略</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span>(cost == INT32_MAX)&#123;<br>  <span class="hljs-comment">// 更新row_idx的策略</span><br>  auto i = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(cost == INT32_MAX)&#123;<br>    <span class="hljs-comment">// 使用向上向下的扫描线完成</span><br>    <span class="hljs-keyword">if</span>(row_idx + i &gt;= _database._lg_layout-&gt;get_row_num() &amp;&amp; row_idx - i &lt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(row_idx + i &lt; _database._lg_layout-&gt;get_row_num())&#123;<br>      cost = placeRow(inst, row_idx + i, <span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">if</span>(cost != INT32_MAX)<span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(row_idx - i &gt;= <span class="hljs-number">0</span>)&#123;<br>      cost = placeRow(inst, row_idx - i, <span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">if</span>(cost != INT32_MAX)<span class="hljs-keyword">break</span>;<br>    &#125;<br>    i += <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="四、结果"><a href="#四、结果" class="headerlink" title="四、结果"></a>四、结果</h3><ul>
<li>使用原始的<code>Abacus</code>算法</li>
</ul>
<img src="/2023/09/10/iEDA-test/image-20230825163939716.png" class="" title="image-20230825163939716">
<ul>
<li>初始行策略使用：加上<code>_row_height</code>后做除法</li>
</ul>
<img src="/2023/09/10/iEDA-test/image-20230825164152609.png" class="" title="image-20230825164152609">
<ul>
<li>初始行策略使用：直接使用<code>y</code>坐标与<code>_row_height</code>做整数相除</li>
</ul>
<img src="/2023/09/10/iEDA-test/image-20230825164459060.png" class="" title="image-20230825164459060">
<ul>
<li>使用手册上<code>Tetris</code>的方法</li>
</ul>
<img src="/2023/09/10/iEDA-test/image-20230830164032304.png" class="" title="image-20230830164032304">
<img src="/2023/09/10/iEDA-test/image-20230830164051317.png" class="" title="image-20230830164051317">
<ul>
<li>对比</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Abacus</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">Tetris</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">全局布局HPWL</td>
<td style="text-align:center">8703921</td>
<td style="text-align:center">8703921</td>
<td style="text-align:center">8703921</td>
<td style="text-align:center">8703921</td>
</tr>
<tr>
<td style="text-align:center">合法化移动总Movement</td>
<td style="text-align:center">781382</td>
<td style="text-align:center">1410142</td>
<td style="text-align:center">865332</td>
<td style="text-align:center">11052260(14.144)</td>
</tr>
<tr>
<td style="text-align:center">合法化运行时间</td>
<td style="text-align:center">0.010062s</td>
<td style="text-align:center">0.000919s</td>
<td style="text-align:center">0.000944s</td>
<td style="text-align:center">0.086068s</td>
</tr>
<tr>
<td style="text-align:center">布局合法化HPWL</td>
<td style="text-align:center">10798293</td>
<td style="text-align:center">10786671</td>
<td style="text-align:center">10749832</td>
<td style="text-align:center">21674741（2.007）</td>
</tr>
<tr>
<td style="text-align:center">详细布局HPWL</td>
<td style="text-align:center">10069766</td>
<td style="text-align:center">10105715</td>
<td style="text-align:center">10070071</td>
<td style="text-align:center">13192372</td>
</tr>
<tr>
<td style="text-align:center">Average Congestion of Edges</td>
<td style="text-align:center">0.728164</td>
<td style="text-align:center">0.718681</td>
<td style="text-align:center">0.713207</td>
<td style="text-align:center">0.713207</td>
</tr>
<tr>
<td style="text-align:center">Total Overflow</td>
<td style="text-align:center">10.000000</td>
<td style="text-align:center">10.000000</td>
<td style="text-align:center">10.000000</td>
<td style="text-align:center">10.000000</td>
</tr>
<tr>
<td style="text-align:center">Maximal Overflow</td>
<td style="text-align:center">2.000000</td>
<td style="text-align:center">2.000000</td>
<td style="text-align:center">2.000000</td>
<td style="text-align:center">2.000000</td>
</tr>
<tr>
<td style="text-align:center">Peak BinDensity</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">Total HPWL</td>
<td style="text-align:center">10069766</td>
<td style="text-align:center">10105715</td>
<td style="text-align:center">10070071</td>
<td style="text-align:center">13192372</td>
</tr>
<tr>
<td style="text-align:center">Total STWL</td>
<td style="text-align:center">10862347</td>
<td style="text-align:center">10863122</td>
<td style="text-align:center">10864139</td>
<td style="text-align:center">14100332</td>
</tr>
<tr>
<td style="text-align:center">Max STWL</td>
<td style="text-align:center">437405</td>
<td style="text-align:center">442445</td>
<td style="text-align:center">460685</td>
<td style="text-align:center">518305</td>
</tr>
</tbody>
</table>
</div>
<p><strong>结果分析</strong></p>
<ul>
<li><p>将<code>Abacus</code>换成<code>Tetris</code>后，在同样的全局布局的版图中</p>
<ul>
<li><p><code>Movement</code>会增加</p>
<p>因为在<code>Abacus</code>中计算的是每一个单元在所有行中的最小<code>cost</code>，而<code>Tetris</code>中则是计算的是周围行内，会存在差异性，这样的差异性在<strong>较为密集</strong>的全局布局中体现更为明显。</p>
</li>
<li><p>合法化运行时间会减少</p>
<p>很显然，<code>Abacus</code>算法能够降低<code>Movement</code>就是以牺牲时间复杂度作为代价的，每一次<code>instance</code>的放置，平摊下来都会多出<code>_row_nums-1</code>轮次</p>
</li>
<li><p>布局合法化<code>HPWL</code>存在不确定性</p>
<p>在实验中表现出来的是减少的特性，但实际上是表现出的不确定性，因为<code>Abacus</code>算法中的<code>cost</code>仅仅是以当前能够移动的最少的<code>x</code>和<code>y</code>的总和作为基准，并没有将线长给加进去，所以对于线长来说使用<code>Abacus</code>算法仅仅是一个贪心策略，不一定能够达到全局最优的效果</p>
</li>
</ul>
</li>
<li><p>个人感觉<code>Abacus</code>算法还是有点暴力</p>
</li>
</ul>
<h3 id="PS：在重新复盘Tetris算法过后"><a href="#PS：在重新复盘Tetris算法过后" class="headerlink" title="PS：在重新复盘Tetris算法过后"></a>PS：在重新复盘Tetris算法过后</h3><p>最开始并没有完全理解要求完成的任务所描述的<code>Tetris</code>算法，仅仅是在<code>Abacus</code>的基础上置换了一个选择初始行和换行的策略，所以在最开始的代码当中调用的依然是原始的<code>placeRow</code>函数，在这个函数中的操作依然选择的是距离当前<code>instance</code>当中最近的<code>internel</code>，所以能够达到在时间减小的情况之下能够使得<code>HPWL</code>也减小的情况，这样的结果显然是存在偶然性的，因为找到的解都不一定都是最优解，与全局布局的结果有关。</p>
<p>当使用手册上描述的<code>Tetris</code>算法后，最终运行期间的<code>Movement</code>变为原来的14倍多，而<code>HPWL</code>也是原来的2倍左右。</p>
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>EDA</tag>
        <tag>布局</tag>
        <tag>iEDA</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title>EDA基础知识总结</title>
    <url>/2023/09/04/eda-summary/</url>
    <content><![CDATA[<h3 id="一、布局"><a href="#一、布局" class="headerlink" title="一、布局"></a>一、布局</h3><h4 id="布局算法：二次线长布局算法-力矢量布局"><a href="#布局算法：二次线长布局算法-力矢量布局" class="headerlink" title="布局算法：二次线长布局算法+力矢量布局"></a><strong>布局算法：二次线长布局算法+力矢量布局</strong></h4><p>设计目标：调整不同元胞在元胞中的摆放位置，使得元胞在版图中的连线最短，同时确保在布局中没有重叠</p>
<blockquote>
<p>二次线长布局分为两个阶段</p>
<p>第一阶段：依据元胞的中心对元胞进行布局，从而对二次线长函数最小化</p>
<p>第二阶段：将元胞中集中在许多元胞重叠的大的结群打散，从而使所有单元原来的重叠消除</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs \">输入：线网连接，限制的版图区域<br>输出：所有元胞的x坐标和y坐标<br></code></pre></td></tr></table></figure>
<h4 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h4><p>1、元胞可以抽象成一个含有x，y坐标的结构体</p>
<p>2、网表抽象为二维map，记录不同元胞之间的连线情况，同时x，y代表元胞在map中所处的位置信息</p>
<h4 id="算法主要思想"><a href="#算法主要思想" class="headerlink" title="算法主要思想"></a>算法主要思想</h4><p><strong>第一阶段：全局布局（二次线长布局）</strong></p>
<blockquote>
<p>在全局布局的过程中，将元胞的坐标抽象成为中心点的坐标，不考虑其面积、大小以及布局的合法化，仅仅是以最优化模块之间的线长为目标。</p>
</blockquote>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">已知线网的的连接，限制的版图区域，求不同元胞在版图中摆放的位置，使得所有元胞在版图中的连线最短。<br>求：所有的元胞的<span class="hljs-keyword">x</span>坐标和y坐标。<br><br><span class="hljs-number">1</span>、列出所有连接的元胞线网的X的总线长L(p)：所有的<span class="hljs-keyword">x</span>距离的差的平方<br><span class="hljs-number">2</span>、分别对所有参数中的<span class="hljs-keyword">x</span>求偏导，并令偏导为<span class="hljs-number">0</span><br><span class="hljs-number">3</span>、列出方程组，解出来的<span class="hljs-keyword">x</span>阵列就是所需要求的解<br>对于Y方向也是同理<br><br>该算法只是以中心点作为元胞的坐标，所有没有考虑到不同元胞的大小，会存在重叠的问题<br></code></pre></td></tr></table></figure>
<p>距离计算代价函数</p>
<img src="/2023/09/04/eda-summary/image-20230818160028154.png" class="" title="image-20230818160028154">
<p>通过求偏导数，解出x和y。</p>
<p><strong>第二阶段：详细布局（力矢量布局）</strong></p>
<blockquote>
<p>用于在已经布置好的版图中，新加入一个元胞，通过找到让该元胞平衡的状态，来确定该元胞在版图中的位置。</p>
<p>采用力学中的质点弹簧系统来建模，每个元胞运动吸引其他元胞，其中吸引力与距离成正比。如果所有元胞到达它们的平衡位置，线长将得到最小化。<strong>将目标转化为将所有的元胞放在一个力平衡的位置上。</strong>——<strong>称为零力目标</strong>（ZFT）</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>、以二次线长布局过后的布局为初始布局<br><span class="hljs-number">2</span>、为每个布局中的元胞设定坐标，并标记为UNMOVED<br><span class="hljs-number">3</span>、对元胞按照元胞的连接数进行排序，该顺序就是元胞迭代的顺序<br><span class="hljs-number">4</span>、迭代的取出每一个元胞，并寻找它的ZFT位置，直到所有的都完成<br><span class="hljs-number">5</span>、若ZFT位置被占据，则移动到其他的位置<br><br>第<span class="hljs-number">5</span>步确定<span class="hljs-selector-tag">p</span>的ZFT时，若ZFT被元胞<span class="hljs-selector-tag">q</span>占据，则移动位置的确定<br><span class="hljs-number">1</span>、如果可能，将<span class="hljs-selector-tag">p</span>移动到靠近<span class="hljs-selector-tag">q</span>的位置<br><span class="hljs-number">2</span>、若交换<span class="hljs-selector-tag">p</span>，<span class="hljs-selector-tag">q</span>后，代价变小，则交换<br><span class="hljs-number">3</span>、链式移动，<span class="hljs-selector-tag">p</span>移动到<span class="hljs-selector-tag">q</span>，<span class="hljs-selector-tag">q</span>移动到下一个，以此类推<br><span class="hljs-number">4</span>、波状移动，<span class="hljs-selector-tag">p</span>移动到<span class="hljs-selector-tag">q</span>，再重新计算<span class="hljs-selector-tag">q</span>的ZFT<br></code></pre></td></tr></table></figure>
<p>Loss为权重乘以坐标差的累计和</p>
<p><strong>时间复杂度</strong></p>
<p>假设元胞的数量为n</p>
<p>二次线长布局的时间复杂度为：O(n^2)，需要遍历一遍map，找到各个节点之间的连线信息</p>
<p>力矢量布局的时间复杂度为：O(n^2)</p>
<h3 id="二、布线"><a href="#二、布线" class="headerlink" title="二、布线"></a>二、布线</h3><h4 id="布线算法：FLUTE算法"><a href="#布线算法：FLUTE算法" class="headerlink" title="布线算法：FLUTE算法"></a>布线算法：FLUTE算法</h4><p>设计目标：找到能将节点连接的最小斯坦纳生成树</p>
<blockquote>
<p>在EDA的布线中，各个板块的IO接口以及时钟接口之间，通常是走的斯坦纳线，而直接求斯坦纳最小树是NP完全问题，使用FLUTE算法可以将RSMT问题转化为查找表的问题</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">输入：pin结点，以及结点的位置<br>输出：将所有结点连接起来的斯坦纳树<br></code></pre></td></tr></table></figure>
<h4 id="算法数据结构设计"><a href="#算法数据结构设计" class="headerlink" title="算法数据结构设计"></a>算法数据结构设计</h4><p><strong>1、POWV（Potentially optimal wirelength vectors）</strong></p>
<p>在FLUTE算法中，会使用一种带有信息（权重）的数据结构（向量）来表示一种斯坦纳树，任意一棵斯坦纳树都可以使用唯一的POWV来表示，一个POWV向量可以表示多棵不一样的斯坦纳树，如下图。</p>
<blockquote>
<p>前面三位表示x方向上的length</p>
<p>后面三位表示y方向上的length</p>
</blockquote>
<img src="/2023/09/04/eda-summary/image-20230828141138808.png" class="" title="image-20230828141138808">
<p><strong>2、POST（potentially optimal Steiner tree）</strong></p>
<p>对每一个POWV都会对应存储一个POST，也就是说，不是存储所有的斯坦纳树，只是存储一个可能的斯坦纳树，因为同一个向量的所有斯坦纳树的代价总和总是一样的。POWV和POST会构建成一个映射关系，同时将其存入到一个Table中，表中还包含POWV的总权重。而此时，权重最小的则可代表一个最小斯坦纳生成树。</p>
<p><strong>3、table可以使用哈希表来进行设计</strong></p>
<p>使用POWV做表头，权重和POST作为value，给出节点后，生成所有的可能的POWV表，再通过权重对其进行排序，取其POST作为斯坦纳树结果。</p>
<h4 id="算法主要思想-1"><a href="#算法主要思想-1" class="headerlink" title="算法主要思想"></a>算法主要思想</h4><figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">总体流程：<br>所有<span class="hljs-keyword">N</span>点线网根据pin脚的位置都可以划分到<span class="hljs-keyword">n</span>！个group中，每个group中存有POWV，对于一个线网最优线长可由POWV来获得，FLUTE算法首先会预计算这些POWV形成一个查找表。<br>与POWV一起存储的还有<span class="hljs-keyword">POST</span>，一个POWV对应多个<span class="hljs-keyword">POST</span>，一个<span class="hljs-keyword">POST</span>只有一个POWV<br>基于此，要得到一棵RSMT，只需要计算线网所在的组对应的POWV的线长，然后返回对应的<span class="hljs-keyword">POST</span>即可<br>上述查找表算法最高支持9点线网，对于9点以上的需要递归的切分线网<br></code></pre></td></tr></table></figure>
<ul>
<li>生成查找表算法</li>
</ul>
<img src="/2023/09/04/eda-summary/image-20230828144127572.png" class="" title="image-20230828144127572">
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>时间复杂度为：O(nlgn)</p>
<h3 id="三、静态时序分析"><a href="#三、静态时序分析" class="headerlink" title="三、静态时序分析"></a>三、静态时序分析</h3><h4 id="单元库"><a href="#单元库" class="headerlink" title="单元库"></a>单元库</h4><p>在静态时序分析中，单元库（library）是指一个集合，其中包含了各种标准的逻辑元件、时序元件和组合元件的建模。单元库中的元件通常带有特定的时钟延迟和逻辑功能，以及电压和温度等方面的参数，通过使用单元库，可以在时序分析中模拟和评估设计的时序特性，以帮助发现和解决潜在的时序冲突和时序失效问题。</p>
<h4 id="互连寄生"><a href="#互连寄生" class="headerlink" title="互连寄生"></a>互连寄生</h4><p>互连寄生是指在集成电路或电子系统中，由于导线或连接器的存在，引起的非理想的电特性和效果。主要包括电容和电阻，互连寄生会对电路的信号传输、功耗、噪声和时序等方面产生不良的影响。</p>
<p>电阻寄生：互连导线的电阻会引起信号的衰减和功率损耗。较长的导线通常具有更大的电阻。</p>
<p>电容寄生：互连导线的电容会引起信号的延迟和功耗。电容会存储和释放电荷，导致信号传输速度变慢。</p>
<h4 id="单元时延（NLDM表格）"><a href="#单元时延（NLDM表格）" class="headerlink" title="单元时延（NLDM表格）"></a>单元时延（NLDM表格）</h4><p>单元时延（NLDM表格），全称为非线性延迟模型（Non-Linear Delay Model），是一种常用的静态时序分析中的时延模型。在数字电路设计中，时延模型用于描述逻辑元件（如门级电路或时序元件）的输出到输入之间的传播延迟。</p>
<p>NLDM表格是一种常见的时延模型，它以表格的形式表示输入到输出之间的传播延迟。表格的输入是逻辑元件的输入端的不同组合，并且通常包括输入的电压和电流等参数。表格的输出是逻辑元件的输出端的延迟时间，通常以纳秒或皮秒为单位。</p>
<p>NLDM表格通常由电路设计工具根据所用的逻辑元件和工艺库生成。基于这个模型，可以进行静态时序分析，以评估电路的时序性能，如时钟周期、信号传输延迟和时序失效等。</p>
<h4 id="线网时延（Elmore计算）"><a href="#线网时延（Elmore计算）" class="headerlink" title="线网时延（Elmore计算）"></a>线网时延（Elmore计算）</h4><p>线网时延，也称为Elmore时延，是一种常用的近似计算方法，用于估计电路中导线上的传播延迟。它是一种简化的时延模型，适用于传输线上电压/电流从输入端到达输出端的时间。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">Elmore计算基于以下假设和简化：<br>1、传输线上的时延主要由传播速度和传输线上的等效电容决定。<br>2、传播速度是恒定的，不考虑传输线上的阻抗匹配或反射等因素。<br>3、传输线被近似为一系列等效电容连接起来的节点。<br><br>根据这些假设，Elmore计算使用以下步骤来估计线网时延：<br>1、将电路中的传输线划分为一系列节点，每个节点对应于传输线上一个等效电容。<br>2、从输入端开始，依次计算每个节点的时延。每个节点的时延等于前一节点的时延加上当前节点的等效电容与前一节点电流之积。<br>3、在达到输出端后，最后一个节点的时延就是整个线网的传播延迟。<br></code></pre></td></tr></table></figure>
<h4 id="串扰噪声的定义"><a href="#串扰噪声的定义" class="headerlink" title="串扰噪声的定义"></a>串扰噪声的定义</h4><p>噪声是指电路中任意节点上不希望出现的电压或电流的偏差。当噪声作用于某个电路节点上时，它可以瞬间破坏该节点上存储的逻辑信息。如果这一破坏状态被锁存到锁存器中，那么将会导致功能性错误。</p>
<p>主要有毛刺和延时噪声。</p>
<h4 id="时序检查（Setup-Hold）"><a href="#时序检查（Setup-Hold）" class="headerlink" title="时序检查（Setup/Hold）"></a>时序检查（Setup/Hold）</h4><p>时序检查是在数字电路设计中进行的一种重要时序分析，用于验证和确保输入信号在时钟边沿触发时的稳定性和正确性。</p>
<p>Setup Time：是指在时钟边沿到达之前，输入信号必须稳定在其有效值的时间。如果输入信号在设置时间窗口内没有稳定，可能会导致电路中的逻辑冲突和错误。</p>
<p>Hold Time：是指在时钟边沿到达之后，输入信号必须继续保持在其有效值的时间。如果输入信号在保持时间之前改变或不稳定，也会导致电路中的逻辑错误。</p>
<h4 id="时序路径定义"><a href="#时序路径定义" class="headerlink" title="时序路径定义"></a>时序路径定义</h4><p>时序路径（Timing Path）是指信号从一个寄存器节点（如时钟触发器）通过逻辑路径传播到另一个寄存器节点的路径。它描述了数据在电路中的传输和处理过程，并对时序分析和时序优化提供了重要信息。</p>
<p>通过分析时序路径，可以确定信号在路径中的传播延迟，包括设置时间和保持时间等重要时序要求。时序路径分析可用于预测时钟频率、检测时序冲突、优化时序性能，以及验证设计是否满足时序规约等。</p>
<h4 id="时序约束命令"><a href="#时序约束命令" class="headerlink" title="时序约束命令"></a>时序约束命令</h4><img src="/2023/09/04/eda-summary/image-20230818170602715.png" class="" title="image-20230818170602715">
<h3 id="四、EDA性能"><a href="#四、EDA性能" class="headerlink" title="四、EDA性能"></a>四、EDA性能</h3><ul>
<li><p>解决EDA软件中的性能问题</p>
<p>算法：优化数据结构，提高算法性能，降低算法的复杂度</p>
<p>硬件：确保计算机的硬件资源重组，对于一些矩阵操作可以考虑使用GPU加速</p>
<p>分布式：将问题拆解成可以并行计算的小问题，开发支持并行计算的EDA工具</p>
</li>
</ul>
<h3 id="五、EDA后端"><a href="#五、EDA后端" class="headerlink" title="五、EDA后端"></a>五、EDA后端</h3><ul>
<li>EDA后端软件开发的流程</li>
</ul>
<img src="/2023/09/04/eda-summary/EDA%E6%B5%81%E7%A8%8B.jpg" class="">
<h3 id="六、EDA工具"><a href="#六、EDA工具" class="headerlink" title="六、EDA工具"></a>六、EDA工具</h3><ul>
<li><p>常见的EDA仿真工具和Debug工具分别有哪些？它们有什么优势和不足？</p>
<p>仿真工具：</p>
<ul>
<li>ModelSim/QuestaSim (Mentor)</li>
<li>VCS (Synopsys)</li>
<li>Xilinx Vivado Simulator (Xilinx)</li>
<li>Incisive (Cadence)</li>
<li>Icarus Verilog</li>
</ul>
<p>优势：</p>
<ul>
<li>高度准确和精确的模拟功能。</li>
<li>可以模拟各种不同级别的设计，从门级仿真到系统级仿真。</li>
<li>支持时序和功能仿真，可以检测和调试设计中的逻辑错误和时序问题。</li>
</ul>
<p>不足：</p>
<ul>
<li>仿真时间较长，尤其是对于大型和复杂的设计。</li>
<li>需要大量的计算资源（CPU和内存）。</li>
<li>对于某些特定的设计场景，可能需要针对特定工具进行配置和优化。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>物理设计</tag>
        <tag>EDA</tag>
        <tag>布局</tag>
        <tag>布线</tag>
      </tags>
  </entry>
  <entry>
    <title>VLSI超大规模集成电路物理设计</title>
    <url>/2023/08/28/VLSI-Physical-Design/</url>
    <content><![CDATA[<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="电子设计自动化（EDA）"><a href="#电子设计自动化（EDA）" class="headerlink" title="电子设计自动化（EDA）"></a>电子设计自动化（EDA）</h3><p>EDA（Electronic Design Automation），全称电子设计自动化，是用来辅助超大规模集成电路设计生产的工业软件，涵盖电路芯片设计、制造、封装、测试整个流程。随着芯片设计的复杂程度不断提升，基于先进工艺节点的集成电路规模可达到数十亿个半导体器件，不借助EDA已经无法完成芯片设计。</p>
<p>EDA工具是集成电路设计和制造流程的支撑，是集成电路设计方法学的载体，也是连接设计和制造两个环节的纽带和桥梁。</p>
<p>采用软件来实现自动化</p>
<blockquote>
<p>EDA将设计者的需求分为电子系统层次结构中的多个级别，包括集成电路、多芯片模块和印制电路板</p>
</blockquote>
<p>EDA工具总是面向整个设计过程的自动化，并将设计步骤链接成一个完整的设计流。</p>
<h3 id="VLSI设计流程"><a href="#VLSI设计流程" class="headerlink" title="VLSI设计流程"></a>VLSI设计流程</h3><img src="/2023/08/28/VLSI-Physical-Design/image-20230817170808037.png" class="" title="image-20230817170808037">
<p>系统规范—架构设计—功能和逻辑设计—电路设计—物理设计—物理验证和签收—制造—封装和测试—芯片</p>
<p>物理设计关键步骤还可以细分</p>
<p>划分—芯片规划—布局—时钟树综合—布线—时序收敛</p>
<ul>
<li><p>系统规范</p>
<p>定义系统的总体目标和高级需求：功能、性能、物理尺寸、生产技术</p>
</li>
<li><p>架构设计</p>
<p>模拟和混合信号模块集成</p>
<p>存储管理——串行或者并行——寻址方案</p>
<p>计算核的类型核数量（处理器，数字信号处理单元，特别的DSP算法）</p>
<p>芯片内外的通信，对标准协议的支持</p>
<p>硬、软IP模块的使用</p>
<p>引脚分配、封装、管芯封装接口</p>
<p>电源需求</p>
<p>工艺技术核层堆栈的选择</p>
</li>
<li><p>功能和逻辑设计</p>
<ul>
<li><p>功能设计</p>
<p>每个模块的输入、输出和时序行为</p>
</li>
<li><p>逻辑设计（用硬件描述语言HDL，如Verilog和VHDL定义芯片的功能和时序行为）</p>
</li>
<li><p>逻辑综合工具自动使HDL转变为底层的电路单元。即映射为信号网列表或网表和特定的电路单元</p>
</li>
</ul>
</li>
<li><p>电路设计</p>
<p>一些关键的低端的单元必须在晶体管级来进行设计，这就是所谓的电路设计。</p>
<p>包括：静态RAM模块、I/O、模拟电路、高速函数（乘法器）以及静电放电保护电路</p>
</li>
<li><p>物理设计</p>
<p>所有的设计组件（宏模块、单元、门）都实例化为几何表示</p>
<ul>
<li>划分</li>
<li>布线规划</li>
<li>电源和地网布线</li>
<li>布局</li>
<li>时钟网综合</li>
<li>总体布线</li>
<li>详细布线</li>
<li>时序收敛</li>
</ul>
</li>
<li><p>物理验证</p>
</li>
<li><p>制造：fabrication</p>
</li>
<li><p>封装和测试</p>
</li>
</ul>
<h3 id="VLSI设计模式"><a href="#VLSI设计模式" class="headerlink" title="VLSI设计模式"></a>VLSI设计模式</h3><blockquote>
<p>全定制和半定制</p>
</blockquote>
<ul>
<li><p>半定制标准设计模式：</p>
<ul>
<li>基于单元：通常采用标准单元和宏单元，包含许多预定义元件（从元件库复制而来）</li>
<li>基于阵列：采用门阵列或者FPGA，包含若干制备好的元件，通过预布线相连</li>
</ul>
</li>
<li><p>全制定设计</p>
<p>需要有版图编辑器</p>
</li>
<li><p>标准单元设计，有固定的电源和接地端口</p>
<p>布局的自由度较少，复杂度大大降低</p>
</li>
<li><p>宏单元</p>
<p>较大块逻辑，执行可重用的功能</p>
</li>
<li><p>门阵列</p>
<p>具有标准逻辑功能的硅片，但是没有链接</p>
</li>
<li><p>现场可编程门阵列（FPGA）</p>
<p>逻辑单元和互连都是预先制造好，但是用户可以通过开关来配置</p>
</li>
<li><p>结构化ASIC（无通道门阵列）</p>
</li>
</ul>
<h3 id="版图层和设计规则"><a href="#版图层和设计规则" class="headerlink" title="版图层和设计规则"></a>版图层和设计规则</h3><ul>
<li><p>版图层</p>
<p>硅作为扩散层，多晶硅、铝和铜作为互连层；多晶硅作称为poly层，其余曾称为Metal1层、Metal2层等。</p>
<p>单元之间的布线是完全在金属层进行的。</p>
</li>
<li><p>设计规则</p>
<p>大致分为三类</p>
<ul>
<li>尺寸规则：任何组件（形状）的尺寸</li>
<li>间距规则：组件形状之间的间距</li>
<li>覆盖规则：组件形状之间的覆盖量</li>
</ul>
</li>
</ul>
<h3 id="物理设计优化"><a href="#物理设计优化" class="headerlink" title="物理设计优化"></a>物理设计优化</h3><p>物理设计的目标：最小芯片面积、最小线长和最少过孔</p>
<p>最优化的目标：提升电路性能，可靠性</p>
<ul>
<li><p>版图优化</p>
<blockquote>
<p>满足约束：工艺约束、电气约束、几何约束</p>
</blockquote>
</li>
</ul>
<h3 id="EDA常用术语"><a href="#EDA常用术语" class="headerlink" title="EDA常用术语"></a>EDA常用术语</h3><p>逻辑设计：将HDL描述映射到电路门和门在网表级的连接的过程。</p>
<ul>
<li>结果通常是单元或其他基本电路元件和连接的网表。</li>
</ul>
<p>物理设计：决定单元（或者其他电路元件）和它们的连接在集成电路版图中几何布置的过程。连接拓扑从网表中得到。</p>
<ul>
<li>物理设计的结果是几何和功能都正确的表示，用标准文件格式，例如GDSII流。</li>
</ul>
<p>版图验证包括：</p>
<ul>
<li>设计规则检验（DRC）——遵守所有的技术需求</li>
<li>版图和原理图一致性检验（LVS）——是否和原始网表一致</li>
<li>天线规则检验——没有天线效应</li>
<li>电气规则检验——遵守所有的电气需求</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">组件：有基本功能的电路元件<br>模块：一个电路划分或者一部分构件的集合<br>块：具有形状的组件，有固定尺寸的电路划分<br>单元：用不同构建建立的逻辑或者功能单位。如：INV，NAND，<span class="hljs-keyword">NOR，常用来指标准单元和宏单元</span><br><span class="hljs-keyword"></span>标准单元：一种预先决定功能的单元，在标准单元里，逻辑设计是将标准单元排列在行里来实现的<br>宏单元：一种没有预先定义尺寸的单元。可以指大型物理版图，如<span class="hljs-keyword">SRAM，CPU核</span><br><span class="hljs-keyword"></span>引脚：一个电子终端，用于连接给定的构件到它的外部环境<br>层：制造工艺等级，在这个等几种，设计构件在芯片上成型。<br>接触层：硅核金属层之间的直接连接，接触层经常用在单元内<br>过孔：金属层之间的连接，通常用来连接不同层的布线结构<br>线网或信号：必须在相同电势下连接的引脚或终端的集合<br>供电网：提供电流给单元的电源（VDD）和地网（GND）<br>网表：设计中连接的所有信号网和构件的集合，或者是所有网和分段设计的连接引脚的列表。<br>网表可以组成：<span class="hljs-number">1</span>、面向引脚，每个设计构件都有一个相关线网的列表。<span class="hljs-number">2</span>、面向线网，每一个线网都有一个相关构件的列表。网表在逻辑综合中创建，是物理设计的关键输入。<br>线网权重（W）：用来表示线网的重要性或关键性<br><br>网表的表示方法：连接图和连接矩阵<br></code></pre></td></tr></table></figure>
<h3 id="第一章总结"><a href="#第一章总结" class="headerlink" title="第一章总结"></a>第一章总结</h3><ul>
<li><p>什么是EDA？</p>
<p>EDA全称是Electrical Design Automation（电子设计自动化），是芯片设计中的辅助软件工具也是必不可少的一个工具，随着芯片中集成的半导体和电路规模越来越大，EDA工具也越来越重要。</p>
</li>
<li><p>超大规模集成电路（VLSI）的设计流程？</p>
<p>系统规范—架构设计—逻辑功能设计—物理设计—物理验证—制造—封装—测试—芯片</p>
</li>
<li><p>其中物理设计包括哪些部分？</p>
<p>物理设计包括：布图规划，布局规划，布线，时钟树综合，时序分析</p>
</li>
</ul>
<h2 id="第二章-网表和系统划分"><a href="#第二章-网表和系统划分" class="headerlink" title="第二章 网表和系统划分"></a>第二章 网表和系统划分</h2><p>一般采用分治的策略进行芯片设计，先将模块进行布局，然后将结果转换为几何划分。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>降低现代集成电路设计复杂度的方法是将它们划分为更小的模块。</p>
</blockquote>
<p>划分的主要目标是将电路进行划分，使得子电路之间的连接数最小化，且符合设计约束。</p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica">元胞：构成组件的任何逻辑或功能单元<br>划分或块是由元胞和组件构成的<br>多元划分的问题是将电路划分为<span class="hljs-built_in">K</span>个部分<br></code></pre></td></tr></table></figure>
<h3 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h3><p>在平衡划分大小时，将所有割边数或割边的权重数最小化，称为最小割划分算法</p>
<h3 id="划分算法"><a href="#划分算法" class="headerlink" title="划分算法"></a>划分算法</h3><blockquote>
<p>Kernighan-Lin算法（KL）、KL拓展算法、Fiduccia-Mattheyses（FM）算法</p>
<p><strong>模拟退火法</strong>、随机爬山算法</p>
</blockquote>
<p>KL算法：对于一个含有2*N个元胞且要划分的区域为N：N的，使用的是两个不同划分之间的元胞进行交换，通过计算能够是当前增益达到最大。</p>
<p>FM算法：划分不平衡的算法，其中需要一个平衡因子来控制移动以后是否平衡。通过计算能够使得移动以后使得当前达到增益最大。可用于超图中。</p>
<h3 id="多级划分框架"><a href="#多级划分框架" class="headerlink" title="多级划分框架"></a>多级划分框架</h3><blockquote>
<p>从粗粒度网表，到细粒度网表</p>
</blockquote>
<p>为了提高网表划分的可扩展性，FM算法被嵌入到了一个多级框架中去，包含几个不同的步骤。</p>
<p>1、原始的展平的网表被进行层次结群。</p>
<p>2、将FM算法应用到这个结群网表中。</p>
<p>3、部分网表在非粗粒度阶段被解开结群。</p>
<p>4、在细粒度阶段，FM算法增量式应用到部分被解开结群的网表中。</p>
<p>5、第3和第4一直继续知道所有网表解开结群为止。</p>
<ul>
<li><p>结群</p>
<p>连接紧密的结点被结群，结群之外的连接保持原来网表的结构。通常结群的大小会受到限制，从而防止结群的退化。</p>
<p>合并结点后，结群的权重是它所包含的成员结点的权重综合</p>
</li>
<li><p>多级划分</p>
<p>当结构过多的时候，FM算法会收到一定的限制，复杂度会很高，所以通过多级划分的方式可以减小复杂度</p>
</li>
<li><p>基于多FPGA的系统划分</p>
</li>
</ul>
<h2 id="第三章-芯片规划"><a href="#第三章-芯片规划" class="headerlink" title="第三章 芯片规划"></a>第三章 芯片规划</h2><p>芯片规划处理大规模模块：高速缓存、嵌入式内存及面积已知、形状固定或可变或集成电路IP核等。</p>
<p><strong>芯片规划主要包括了三个主要阶段：布图规划、引脚分配、电源规划</strong></p>
<p>布局规划：根据模块的面积和长宽比来优化芯片的大小、降低互连线长度和改善时延，从而确定了这些模型的位置和大小。</p>
<p>引脚分配：通过输出信号线连接到块引脚。I/O布局为芯片的输入和输出引脚确定焊盘的位置，通常在芯片的边缘。这一步最理想在布局规划前进行。</p>
<p>电源规划：建立电源供电网，电源网和底线网。</p>
<h3 id="布图规划介绍"><a href="#布图规划介绍" class="headerlink" title="布图规划介绍"></a>布图规划介绍</h3><p>布图描述了模块之间的关系</p>
<p>布局规划阶段确保：1、每个芯片模块被分配了一个形状或位置，便于进行门布局。2、每个有外部连接的引脚被分配了一个位置，这样内部和外部的线网都可以进行布线了。</p>
<h3 id="布图规划的优化目标"><a href="#布图规划的优化目标" class="headerlink" title="布图规划的优化目标"></a>布图规划的优化目标</h3><p>每个模块的位置和它的长宽比</p>
<ul>
<li>全局边界框的面积和形状：影响电路性能、成品率、制造代价</li>
<li>总线长，最小生成树</li>
<li>面积和总线长的组合</li>
<li>信号时延</li>
</ul>
<h3 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">矩形划分：将芯片面积划分为一组块或非重叠矩形的几何<br>布图规划二划分：通过不断对矩形进行划分得到的一个矩形划分，从整个芯片开始，反复用水平或垂直割线将其划分为两个小矩形。<br>二划分树或者二划分布图规划树：有k个叶子和k<span class="hljs-string">-1</span>个内部节点的二叉树，每个叶子代表一个块，每个内部节点代表一条水平或垂直割线。<br>布图树：一棵表示层次化布图的树。每个叶子节点代表一个块，每个内部节点代表一个水平分割或垂直分割。<br>约束图：对一个布图表示，包括两个有向图，垂直约束图和水平约束图，可以得到块之间的相对位置关系。<br>垂直约束图：节点权重表示块的高度。最长路径，相当于布局所需的最小垂直高度。<br>水平约束图：结点权重代表块的宽度。最长路径，相当于布局所需的最小水平宽度。<br>序列对：块排列的一个有序对。用S+和S-表示，用于区分序列是左右关系还是上下关系。<br></code></pre></td></tr></table></figure>
<h3 id="布图的表示"><a href="#布图的表示" class="headerlink" title="布图的表示"></a>布图的表示</h3><blockquote>
<p>布图的表示方法：1、约束图，2、序列对</p>
</blockquote>
<p>布图、约束图（垂直约束图，水平约束图）、序列对</p>
<p>问题：</p>
<p>如何将一个布图转化为一个约束图对（垂直&amp;水平）</p>
<ul>
<li>垂直约束图：从下到上，从左到右，先绘制所有的有向箭头，再删除不能直接相连的箭头</li>
</ul>
<p>如何将一个布图转化为一个序列对</p>
<ul>
<li>序列的规则，先考虑垂直方向，再考虑水平方向<ul>
<li>a在b的左边，s1<a,b> s2<a,b></li>
<li>a在b的上面，s1<a,b> s2<b,a></li>
</ul>
</li>
</ul>
<p>如何将一个序列对转化为一个布图</p>
<blockquote>
<p>已知布图的起始点，每个块的宽和高，布图的布局方向（一般是左下到右上）</p>
</blockquote>
<h3 id="布图规划算法"><a href="#布图规划算法" class="headerlink" title="布图规划算法"></a>布图规划算法</h3><blockquote>
<p>布图优化算法：给定一个块的几何，布图尺寸的选择决定了布图面积的最小值，以及每个块的方向和大小。</p>
<p><strong>群生长，模拟退火法</strong>：寻求1、在满足布图面积上限的条件下，最小化互连线总长度。2、同时优化总线长和面积。</p>
</blockquote>
<ul>
<li><p>布局尺寸变化</p>
<p>寻找最小面积布图的尺寸和相应的每个块的尺寸。</p>
<ul>
<li>构造所有块的形状函数</li>
<li>确定顶层布图的形状函数</li>
<li>找出布图和每个独立块的尺寸和位置</li>
</ul>
</li>
</ul>
<p>群生长</p>
<p>基于群生长的方法中，布图是由迭代的增加块，直到所有块都被分配完。</p>
<ul>
<li><p>线性排序</p>
<p>终端网：没有被其他没被安置的相关块</p>
<p>新网：在部分构造排序的任何块上都没有引脚</p>
<p>持续网：在部分构造排序上至少在块上有一个引脚，以及在无序块上至少有一个引脚</p>
<p>以终端网减去新网的值作为增益，排序后每次都进行迭代，得到最终线性排序的序列</p>
</li>
<li><p>群生长</p>
<p>按照线性排序的顺序，依次将最优块放置在布图上</p>
</li>
</ul>
<p>模拟退火（SA）</p>
<p>是一种迭代算法，从一个初始解开始，寻求目标函数解的不断改进。在每次迭代中，要考虑当前解的局部邻域解。</p>
<h3 id="引脚分配"><a href="#引脚分配" class="headerlink" title="引脚分配"></a>引脚分配</h3><p>在引脚分配中，所有线网（信号）被分配到唯一的引脚位置，这样设计性能才是最优化的。优化目标包括块内外的最大化线网可布性和最小化电寄生参数。</p>
<p>引脚分配可以用来连接功能或电等价的元胞引脚。</p>
<p>优化目标：建立一个块和所有它与其他块的引脚的连接关系。</p>
<h3 id="电源和地线布线"><a href="#电源和地线布线" class="headerlink" title="电源和地线布线"></a>电源和地线布线</h3><p>电源和地线网分布设计</p>
<blockquote>
<p>供电网VDD和GND，为每个元胞提供电源，每个元胞都必须与VDD和GND相连。</p>
<p>供电网是：大型的、跨越整个芯片的、再信号布线之前布线</p>
</blockquote>
<p>电源和地线网的物理设计有两种方法：平面法，主要用于模拟电路或者定制块设计中。网格法，主要用于数字集成电路设计中。</p>
<ul>
<li>芯片规划的步骤：布图规划、引脚分配、电源和地线分配</li>
<li>布图用什么来表示？</li>
<li>布图规划有哪些算法？</li>
</ul>
<h2 id="第4章-全局和详细布局"><a href="#第4章-全局和详细布局" class="headerlink" title="第4章 全局和详细布局"></a>第4章 全局和详细布局</h2><p>将电路划分成小模块和对版图进行布局规划，从而确定块的轮廓线和引脚位置后，要求解优化目标（最小化元件间的总线长），布局要确定每个块中的标准单元或逻辑元件的位置。</p>
<p>全局布局：分配大概的位置，给可变动的器件</p>
<ul>
<li>忽视可布目标的特殊形状和大小，不会试图去排列它们的位置到有效的行和列中去。</li>
<li>进行全局定位和全局分布密度</li>
</ul>
<p>详细布局：明确器件的位置使其成为合理的元胞位置并确保没有重叠</p>
<ul>
<li>通过局部操作（交换两个元件）或移动一个行中的几个元件来为其他元件提供位置空间，从而增量式的改进每个标准单元的位置。</li>
</ul>
<p>合法化：将可布元件布置到行列中去，并消除重叠。</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>布局的目标：为了确定所有电路元件在一个（平面）版图中的位置和方向，给出解的约束（如没有元胞的重叠）和优化目标（如总线长最小化）</p>
<h3 id="优化目标-1"><a href="#优化目标-1" class="headerlink" title="优化目标"></a>优化目标</h3><p>布局器通常优化目标是总线长。</p>
<ul>
<li><p>几种划线模型的选择</p>
<ul>
<li>单链模型</li>
<li>星形模型</li>
<li>最小生成树模型（克鲁斯卡尔）（RMST）</li>
<li>直线最小树</li>
</ul>
</li>
<li><p>带线网权重的总线长</p>
<ul>
<li>所有网络的线长与权重的乘积之和</li>
</ul>
</li>
<li><p>最大割数</p>
<p>最小化某一个布局总的割数</p>
</li>
<li><p>布线拥挤度（可以使用密度来表示：即布线所需要的轨道数与可提供的轨道数的比值）</p>
<p>当所有穿过边的布线数小于最大的布线数时，则说明该布局是可布线的</p>
</li>
<li><p>信号延时</p>
<p>对于给定的涉及，布局的总线长影响最大时钟频率，主要依赖于线网的时延和门时延。</p>
<p>电路时序通常使用静态时序分析法（STA）进行验证，对线网和门时延进行估算。常见的术语包括实际到达时间（AAT）和需求到达时间（RAT），可对电路中每个结点v进行估算。</p>
</li>
</ul>
<h3 id="全局布局"><a href="#全局布局" class="headerlink" title="全局布局"></a>全局布局</h3><blockquote>
<p>全局布局确定布局的大致位置，详细布局消除重叠的因素</p>
</blockquote>
<p>最小割划分、二次布局、力矢量布局、模拟退火</p>
<ul>
<li><p>最小割布局：利用划分算法将网表和版图区域划分为较小的子网表和子区域。子网表和子区域重复划分到更小的部分，直到每个子区域包含少量的元胞。当实现最小割布局时，网表被划分为每个子区域拥有它自己唯一的子网表。</p>
<p>版图划分的方向：割方向交替法（垂直割线和水平割线交替划分）、割方向重复法（先用单一方向划分，直到达到最小以后，在换方向）</p>
<p>在版图划分的过程中，通常会将版图划分的方向和最小割划分算法结合起来，这样才能够在版图上最终定位某一个模块的位置。</p>
<ul>
<li><p>最小化割网的标准算法KL算法和FM算法</p>
</li>
<li><p>有外部链接的最小割布局</p>
<p>假设每个元胞分别被布置在它们各自的区域中心。如果相关的i拦截接近下一个划分割线，在做下一个割线时则不用考虑这些结点。</p>
</li>
</ul>
</li>
<li><p>解析布局（最小化目标函数）</p>
<ul>
<li><strong>二次线长布局</strong>：分为两个阶段<ul>
<li>第一阶段：依据元胞的中心对元胞进行布局，<strong>从而对二次线长函数最小化</strong>。</li>
<li>第二阶段：将元胞中集中在许多元胞重叠的大的结群打散，从而使所有的单元原来的重叠消除。<strong>详细布局将所有元胞位置合法化并产生一个高质量的、无重叠的布局。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>  第一阶段方法：迭代求解线性方程：共轭梯度法（CG）、逐次超松弛法（SOR）</p>
<p>  第二阶段方法：详细布局：最小割布局、力矢量布局</p>
<ul>
<li><p>二次线长布局具体算法：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><code class="hljs llvm">已知线网的的连接，限制的版图区域，求不同元胞在版图中摆放的位置，使得所有元胞在版图中的连线最短。求：所有的元胞的<span class="hljs-keyword">x</span>坐标和y坐标。<br><br><span class="hljs-number">1</span>、列出所有连接的元胞线网的X的总线长L(p)：所有的<span class="hljs-keyword">x</span>距离的差的平方<br><span class="hljs-number">2</span>、分别对所有参数中的<span class="hljs-keyword">x</span>求偏导，并令偏导为<span class="hljs-number">0</span><br><span class="hljs-number">3</span>、列出方程组，解出来的<span class="hljs-keyword">x</span>阵列就是所需要求的解<br>对于Y方向也是同理<br><br>该算法只是以中心点作为元胞的坐标，所有没有考虑到不同元胞的大小，会存在重叠的问题<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>力矢量布局</strong></p>
<p>用于在已经布置好的版图中，新加入一个元胞，通过找到让该元胞平衡的状态，来确定该元胞在版图中的位置。</p>
<p>采用力学中的质点弹簧系统来建模，每个元胞运动吸引其他元胞，其中吸引力与距离成正比。如果所有元胞到达它们的平衡位置，线长将得到最小化。<strong>将目标转化为将所有的元胞放在一个力平衡的位置上。</strong>——<strong>称为零力目标</strong>（ZFT）</p>
<ul>
<li>对于每一个元胞，都有一个理想的最小ZFT位置。</li>
<li>通过迭代的移动每个单元或者交换元胞到这个位置或相邻近位置，逐步改善布局结果</li>
</ul>
<blockquote>
<p>个人认为：这个方法不能让每一个元胞都到达力的平衡状态，使用一次迭代或者交换，就会打乱原始平衡的元胞。</p>
</blockquote>
</li>
<li><p>基本力矢量布局算法</p>
<blockquote>
<p>Loss为权重乘以坐标差的累计和</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-number">1</span>、任意初始布局<br><span class="hljs-number">2</span>、为每个布局中的元胞设定坐标，并标记为UNMOVED<br><span class="hljs-number">3</span>、对元胞按照元胞的连接数进行排序，该顺序就是元胞迭代的顺序<br><span class="hljs-number">4</span>、迭代的取出每一个元胞，并寻找它的ZFT位置，直到所有的都完成<br><span class="hljs-number">5</span>、若ZFT位置被占据，则移动到其他的位置<br><br>第<span class="hljs-number">5</span>步确定<span class="hljs-selector-tag">p</span>的ZFT时，若ZFT被元胞<span class="hljs-selector-tag">q</span>占据，则移动位置的确定<br><span class="hljs-number">1</span>、如果可能，将<span class="hljs-selector-tag">p</span>移动到靠近<span class="hljs-selector-tag">q</span>的位置<br><span class="hljs-number">2</span>、若交换<span class="hljs-selector-tag">p</span>，<span class="hljs-selector-tag">q</span>后，代价变小，则交换<br><span class="hljs-number">3</span>、链式移动，<span class="hljs-selector-tag">p</span>移动到<span class="hljs-selector-tag">q</span>，<span class="hljs-selector-tag">q</span>移动到下一个，以此类推<br><span class="hljs-number">4</span>、波状移动，<span class="hljs-selector-tag">p</span>移动到<span class="hljs-selector-tag">q</span>，再重新计算<span class="hljs-selector-tag">q</span>的ZFT<br></code></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>模拟退火算法</p>
<p>列出损失函数，使用带动量的梯度下降，最终计算出使得损失函数最小的最优解</p>
</li>
<li><p>现代布局算法</p>
</li>
</ul>
<h3 id="合法化和详细布局"><a href="#合法化和详细布局" class="headerlink" title="合法化和详细布局"></a>合法化和详细布局</h3><blockquote>
<p>合法化：寻求合法的、没有重叠的布局，从而减少对线长、时序和其他设计目标的不利影响。</p>
</blockquote>
<p>目标：消除元胞中的重叠</p>
<p>使用贪心算法</p>
<ul>
<li><p>按照x坐标进行排序，并进行贪心处理，贪心选择策略为移动到当前元胞最近的，可用的合法位置，但不能超出行的范围。</p>
</li>
<li><p>缺点</p>
<ul>
<li>没有对网表进行考虑</li>
<li>产生了大量的空白区域</li>
</ul>
</li>
</ul>
<h2 id="第五章-总体布线"><a href="#第五章-总体布线" class="headerlink" title="第五章  总体布线"></a>第五章  总体布线</h2><p>在总体布线中，具有相同点位的引脚用线路相连。</p>
<h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>给定一个布局和一个网表：确定必要的连接数</p>
<p>需要优化的布线目标：最小化总线长，最大时序松弛</p>
<p>总体布线可分为：固定的裸片布线（芯片外形和所有布线资源都是固定的），可变的裸片布线（可以根据需要添加新布线轨道）</p>
<p>常见的几种布线算法</p>
<ul>
<li>总体布线：粗粒分配布线到<strong>布线区域</strong></li>
<li>详细布线：细粒分配布线到<strong>布线轨道</strong>，包括线网排序，引脚排序。用于完善总体布线。</li>
<li>时序驱动布线：线网拓扑优化和资源分配到关键线网</li>
<li>大信号网布线：电源（VDD）和地线（GND）布线</li>
<li>几何技术：非曼哈顿和时钟布线</li>
</ul>
<h3 id="术语和定义"><a href="#术语和定义" class="headerlink" title="术语和定义"></a>术语和定义</h3><figure class="highlight mathematica"><table><tr><td class="code"><pre><code class="hljs mathematica">布线轨道（列）：一条可用的水平（垂直）接线通路。<br>布线区域：包含了布线轨道的区域。<br>规格一致的布线区域：由均匀分布的水平和垂直网格线形成，产生芯片区域上规格一致的网格。<br>规格不一致的布线区域：由水平和垂直边界形成，与外部引脚连接或宏单元边界对齐。<br>通道：一个矩形不限区域，在两个相对边上由引脚，而在另两边则没有引脚。<br>水平通道：在顶端和低端边界上有引脚的通道。<br>垂直通道：在左右边界上有引脚的通道。<br>通道容量：代表了可用的布线轨道或者列的数量。<br>开关盒：水平和垂直通道的交集。<br><span class="hljs-number">2</span><span class="hljs-built_in">D</span>开关盒：四个边界都有端子的开关盒。<br><span class="hljs-number">3</span><span class="hljs-built_in">D</span>开关盒：六个边界都有端子的开关盒，包括顶部和底部。<br></code></pre></td></tr></table></figure>
<p>优化目标</p>
<blockquote>
<p>最小总线长度，减少线网上的信号时延</p>
</blockquote>
<p>1、确定一个给定布局是否可布线。2、在可用布线区域中确定所有线网的一个粗略布线。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>物理设计</tag>
        <tag>EDA</tag>
        <tag>电子设计自动化</tag>
        <tag>VLSI</tag>
      </tags>
  </entry>
  <entry>
    <title>集成电路静态时序分析学习笔记</title>
    <url>/2023/08/26/static-timing-analysis/</url>
    <content><![CDATA[<h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><blockquote>
<p>集成电路：在一块很小的硅单晶片上，利用半导体工艺制作出许多二极管、晶体管以及电阻、电容等，并连接成能完成特定电子技术功能的电子电路。</p>
</blockquote>
<h3 id="静态时序分析技术"><a href="#静态时序分析技术" class="headerlink" title="静态时序分析技术"></a>静态时序分析技术</h3><p>静态时序分析既要检验门级电路的最大延迟、以保证电路在指定的频率下能够满足建立时间的要求，同时要检验门级电路的最小延迟、以满足保持时间的需求。</p>
<p><strong>静态时序分析优缺点</strong></p>
<ul>
<li>优点<ul>
<li>分析执行速度快</li>
<li>不需要测试向量</li>
<li>对于有时序路径的时序，测试覆盖率可以近乎达到100%</li>
<li>能够完成动态仿真所不能实现的复杂分析</li>
</ul>
</li>
<li>缺点<ul>
<li>不能验证设计的功能</li>
<li>智能验证同步时序电路的时序特性</li>
<li>不能自动识别设计中的特殊路基</li>
</ul>
</li>
</ul>
<h2 id="第二章-静态时序分析的基础知识"><a href="#第二章-静态时序分析的基础知识" class="headerlink" title="第二章 静态时序分析的基础知识"></a>第二章 静态时序分析的基础知识</h2><h3 id="逻辑门单元"><a href="#逻辑门单元" class="headerlink" title="逻辑门单元"></a>逻辑门单元</h3><img src="/2023/08/26/static-timing-analysis/image-20230810165634110.png" class="" title="image-20230810165634110">
<p>反相器：根据输入数据的逻辑电平进行逻辑取反的求值运算，并通过输出导出求值结果。</p>
<p>逻辑门延时：逻辑单元自身逻辑求值的时间。信号线延时：逻辑信号从逻辑门单元的输出端口开始在互连线上传播到下一级逻辑输入端口的延时。</p>
<h3 id="门单元的时序计算参数"><a href="#门单元的时序计算参数" class="headerlink" title="门单元的时序计算参数"></a>门单元的时序计算参数</h3><p>组合逻辑门单元相关的时序参数主要包括信号转换延时和逻辑门延时</p>
<p><strong>1、信号转换延时</strong></p>
<blockquote>
<p>输入端口或输出端口的信号电平由高到低或由低到高所需要的时间即为信号转换延时。</p>
</blockquote>
<p>可以调整上升沿和下降沿的阈值，来设置不同的上拉跨度和下降跨度</p>
<p><strong>2、逻辑门延时</strong></p>
<blockquote>
<p>通过由晶体管组成的逻辑门可以使高、低电平输入信号进行逻辑求值并产生对应的高电平或者低电平信号输出。</p>
</blockquote>
<h3 id="时序单元相关约束"><a href="#时序单元相关约束" class="headerlink" title="时序单元相关约束"></a>时序单元相关约束</h3><p>时序单元相关约束信息包括：建立时间、保持时间、恢复时间、移除时间以及最小脉冲宽度</p>
<p><strong>1、建立时间</strong></p>
<p>在时钟信号到来之前需要保持的时间，一般是以50%为间隔</p>
<img src="/2023/08/26/static-timing-analysis/image-20230811144505780.png" class="" title="image-20230811144505780">
<p><strong>2、保持时间</strong></p>
<p>时序单元要实现正确的逻辑功能，信号在时钟沿有效后必须保持的最小时间长度。</p>
<p><strong>3、恢复时间</strong></p>
<p>保证单元正常的逻辑功能，要求低电平复位信号或者高电平清零信号在时钟有效沿之前保持的最小时间长度。</p>
<p><strong>4、移除时间</strong></p>
<p>保证单元正确的逻辑功能，要求低电平复位信号或者高电平清零信号在时钟有效沿之后继续保持有效的最小时间长度。</p>
<p><strong>5、最小脉冲宽度</strong></p>
<p>脉冲波形的开始到结束之间的最小时间间隔。</p>
<h3 id="时钟特性"><a href="#时钟特性" class="headerlink" title="时钟特性"></a>时钟特性</h3><blockquote>
<p>时钟的时序特性</p>
<p>时钟周期：时钟频率的倒数</p>
<p>时钟占空比：时钟信号高电平在一个周期之内所占的时间比率</p>
<p>时钟转换时间：时钟信号的电压从标准供电电源电压的10-90的时间间隔</p>
<p>时钟延迟：时钟延迟是指时钟信号从时钟源输出端口到达时序单元时钟输入端口所需要的传播时间</p>
<p>时钟偏斜</p>
<p>时钟抖动</p>
</blockquote>
<h3 id="时序弧"><a href="#时序弧" class="headerlink" title="时序弧"></a>时序弧</h3><p>用于表达时序的一种数据</p>
<blockquote>
<p>静态时序分析是基于时序弧数据的时序分析。</p>
<p>时序弧的信息一般分为连线延时和单元延时，单元延时中的时序弧分为基本时序弧和约束时序弧</p>
</blockquote>
<h3 id="PVT环境"><a href="#PVT环境" class="headerlink" title="PVT环境"></a>PVT环境</h3><p>工艺、工作电压、工作温度等参数设置的组合简称为PVT</p>
<p>1、TYP（Typical）工艺<br>包括典型的工艺，典型的工艺温度、典型的有效电源电压</p>
<p>2、BCF（Best-Case Fast）</p>
<p>包括最快的工艺、最低的工艺温度、最高的有效电源电压</p>
<p>3、WCS（Worst-Case Show）</p>
<p>包括最慢的工艺、最高的工艺温度、最低的有效电源电压</p>
<h3 id="时序计算单位"><a href="#时序计算单位" class="headerlink" title="时序计算单位"></a>时序计算单位</h3><p>基于温度、电压、电流、电阻、电容负载和时间等不同类型的变量银子进行计算</p>
<h2 id="第三章-单元库时序模型"><a href="#第三章-单元库时序模型" class="headerlink" title="第三章 单元库时序模型"></a>第三章 单元库时序模型</h2><h3 id="基本时序模型简介"><a href="#基本时序模型简介" class="headerlink" title="基本时序模型简介"></a>基本时序模型简介</h3><p><strong>快速时序模型</strong></p>
<blockquote>
<p>通过时序信息库对应单元的时序弧信息，把需要建模的时序路径的时序弧近似为某些单元的时序弧组合</p>
</blockquote>
<p><strong>接口逻辑模型</strong></p>
<p>使用一种结构化的方法，将原始电路简化为只包含接口逻辑的一个小电路。</p>
<p><strong>抽取时序模型</strong></p>
<p>从一个模块的门级网表中抽取模块的时序信息，可以隐藏单元的内部实现细节，有利于保护知识产权。</p>
<h3 id="Synopsys工艺库模型"><a href="#Synopsys工艺库模型" class="headerlink" title="Synopsys工艺库模型"></a>Synopsys工艺库模型</h3><p>线性延时模型：通过线性方程来计算单元的门延时和输出端转换延时</p>
<p>非线性延时模型：由驱动模型和接受模型组成</p>
<p>复合电流源延时模型：指定输入信号转换时间和逻辑门的输出负载值，通过电路仿真模拟出逻辑门的延时和输出转换时间</p>
<h3 id="延时计算模型"><a href="#延时计算模型" class="headerlink" title="延时计算模型"></a>延时计算模型</h3><p>1、CMOS通用延时计算模型</p>
<p>逻辑门固有的本征延时、输入信号转换延时、信号连线延时、输出信号转换延时</p>
<p>2、CMOS非线性延时计算模型</p>
<p>逻辑门延时、信号互连线连线延时</p>
<p>由输入信号转换时间与输出负载作为索引，时序分析时以一个二维查找表的形式来计算延时。</p>
<p>计算过程：查找表中索引参数的某个采样点延时可直接查表得出，再通过插值算法来计算延时。</p>
<h4 id="互连线计算模型"><a href="#互连线计算模型" class="headerlink" title="互连线计算模型"></a>互连线计算模型</h4><p>芯片内的互连线大致可以分为以下3种</p>
<p>1、短线，局部互连线</p>
<p>2、中长线，模块间互连线</p>
<p>3、长线，全局互连线</p>
<ul>
<li><p>集总C模型</p>
<p>当导线的电阻部分很小且驱动单元的转换频率在较低范围内，就可以很合理地只考虑导线地电容部分，并把分布的电容集总为单个电容。</p>
</li>
<li><p>集总RC模型</p>
<p>当导线长度超过几微米后会有明显地电阻，因此采用电阻电容模型。</p>
</li>
<li><p>分布RC模型</p>
</li>
<li><p>传输线模型</p>
</li>
</ul>
<h4 id="线负载时序模型"><a href="#线负载时序模型" class="headerlink" title="线负载时序模型"></a>线负载时序模型</h4><h3 id="引脚电容值计算"><a href="#引脚电容值计算" class="headerlink" title="引脚电容值计算"></a>引脚电容值计算</h3><p>每一个单元的时序模型除了延迟信息外，还包含输入引脚的电容信息</p>
<ul>
<li>方法一、对流入输入引脚的电流进行积分</li>
<li>方法二、基于输出转换时间结果，通过查找表的方法来确定对应的输出电容负载</li>
</ul>
<h3 id="功耗模型计算"><a href="#功耗模型计算" class="headerlink" title="功耗模型计算"></a>功耗模型计算</h3><blockquote>
<p>包括开关功耗，短路电流功耗，哑阈漏流功耗，开关功耗和短路电流功耗组成动态功耗</p>
</blockquote>
<p>动态功耗是单元在转换过程中电源电流的积分</p>
<p>静态功耗（哑阈漏流）计算方法，设置单元的输入信号为固定电平，然后对单元的哑阈漏流进行瞬态分析，得到哑阈漏流功耗值。</p>
<h3 id="时序信息建模基本方法"><a href="#时序信息建模基本方法" class="headerlink" title="时序信息建模基本方法"></a>时序信息建模基本方法</h3><blockquote>
<p>考虑两方面的延迟信息</p>
<p>1、输入端口到输出端口的延迟信息，即时序弧</p>
<p>2、输入端口之间存在的时序约束信息，建立或保持时间约束</p>
</blockquote>
<h2 id="第四章、时序信息库文件"><a href="#第四章、时序信息库文件" class="headerlink" title="第四章、时序信息库文件"></a>第四章、时序信息库文件</h2><blockquote>
<p>时序信息库文件中记录着逻辑门延时、输出信号转换延时和功耗等信息，这些信息在用于时序分析时被调用，来计算延时值和功耗值。时序文件的内容主要由组、属性、和因子组成。</p>
</blockquote>
<p>这一章是对一些库文件的介绍</p>
<h2 id="第五章、静态时序分析的基本方法"><a href="#第五章、静态时序分析的基本方法" class="headerlink" title="第五章、静态时序分析的基本方法"></a>第五章、静态时序分析的基本方法</h2><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p>从逻辑电路图转化为时序图，需要标记中间的逻辑节点，生成中间结果后，再绘制时序图。</p>
<h3 id="时序分析策略"><a href="#时序分析策略" class="headerlink" title="时序分析策略"></a>时序分析策略</h3><blockquote>
<p>基于路径的时序分析策略和基于模块的时序分析策略</p>
</blockquote>
<p>1、基于路径的时序分析策略：基于时序图寻找从起点到终点的所有路径并进行时序分析</p>
<p>2、基于模块的时序分析策略：基于图的时序分析策略，基于时序图找到从起点到终点的所有路径，在进行时序分析时只基于该路径下延迟最严重的结点进行计算。</p>
<h3 id="时序路径延时计算方法"><a href="#时序路径延时计算方法" class="headerlink" title="时序路径延时计算方法"></a>时序路径延时计算方法</h3><p>1、组合逻辑之间路径延时计算方法</p>
<p>把逻辑门延时和信号线延时逐一相加来实现</p>
<p>2、时序逻辑之间路径延时计算方法</p>
<p>通过逻辑路径的逻辑门延时和信号线延时逐一相加来实现</p>
<h3 id="时序路径的分析方法"><a href="#时序路径的分析方法" class="headerlink" title="时序路径的分析方法"></a>时序路径的分析方法</h3><p>对建立时间和保持时间进行分析</p>
<p>1、建立时间分析：在时钟捕获信号有效沿到来前，数据信号必须提前达到稳定状态的时间</p>
<img src="/2023/08/26/static-timing-analysis/image-20230817160931612.png" class="" title="image-20230817160931612">
<p>2、保持时间分析：为保证时序单元对数据读取正确，数据在时钟有效沿到来之后仍需要保持稳定的时间</p>
<img src="/2023/08/26/static-timing-analysis/image-20230817160942849.png" class="" title="image-20230817160942849">
<h2 id="第六章、时序约束"><a href="#第六章、时序约束" class="headerlink" title="第六章、时序约束"></a>第六章、时序约束</h2><h3 id="时钟约束"><a href="#时钟约束" class="headerlink" title="时钟约束"></a>时钟约束</h3><ul>
<li><p>创建时钟</p>
<p>时钟源点：根据情况定义为设计中的一个端口</p>
<p>时钟周期：时钟振荡周期，频率的倒数</p>
<p>时钟占空比：默认百分之50，高低电平在一个周期中的占比</p>
<p>时钟转换延时：高低电平之间进行切换所需要的延时</p>
<p>时钟不确定性：抖动、偏斜等</p>
<p>时钟延迟：从时钟源输出端到达时序单元时钟输入端传播延时。</p>
</li>
<li><p>生成时钟</p>
<blockquote>
<p>基于主时钟并通过相关逻辑转换后，在相位、频率、占空比等方面和主时钟有一定变化的分支时钟。</p>
</blockquote>
</li>
<li><p>虚拟时钟</p>
</li>
<li><p>最小时钟脉宽</p>
</li>
</ul>
<h3 id="I-O延时约束"><a href="#I-O延时约束" class="headerlink" title="I/O延时约束"></a>I/O延时约束</h3><ul>
<li>设置输入延时：在一个有效时钟周期内，外部逻辑的输出数据到达设计输入端口所占用的延时</li>
<li>设置输出延时：在一个有效时钟周期内，输出端口数据到外部逻辑所占用的延时</li>
</ul>
<h3 id="I-O环境建模约束"><a href="#I-O环境建模约束" class="headerlink" title="I/O环境建模约束"></a>I/O环境建模约束</h3><blockquote>
<p>主要包括：</p>
<p>输入驱动建模</p>
<p>输出负载建模</p>
</blockquote>
<h3 id="时序例外"><a href="#时序例外" class="headerlink" title="时序例外"></a>时序例外</h3><p>1、多周期路径设置</p>
<p>2、伪路径设置：某些时序路径在某特定的工作状态下不工作，要求非常宽松，不会有真正的工作信号通过</p>
<p>3、最大演示和最小延时设置</p>
<h3 id="恒定状态约束"><a href="#恒定状态约束" class="headerlink" title="恒定状态约束"></a>恒定状态约束</h3><h3 id="屏蔽时序约束"><a href="#屏蔽时序约束" class="headerlink" title="屏蔽时序约束"></a>屏蔽时序约束</h3><blockquote>
<p>针对单元具体端口内部的时序弧并且进行屏蔽，等价于移除该单元内部的时序弧，时序分析时，与该时序弧相关的所有时序路径都被移除</p>
</blockquote>
<h3 id="时序设计规则约束"><a href="#时序设计规则约束" class="headerlink" title="时序设计规则约束"></a>时序设计规则约束</h3><p>1、最大转换时间</p>
<p>2、最大电容负载</p>
<p>3、最大扇出</p>
<blockquote>
<p>扇出指逻辑单元输出端直接连接的下级逻辑单元输入端的个数。</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>集成电路</tag>
        <tag>EDA</tag>
        <tag>静态时序分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Modern C++学习笔记</title>
    <url>/2023/08/15/Effective-Modern-C-notes/</url>
    <content><![CDATA[<h2 id="Effective-Modern-C-学习笔记"><a href="#Effective-Modern-C-学习笔记" class="headerlink" title="Effective Modern C++学习笔记"></a>Effective Modern C++学习笔记</h2><blockquote>
<p>重点掌握auto、智能指针、移动构造、lambda</p>
</blockquote>
<h3 id="第一章、类型推导"><a href="#第一章、类型推导" class="headerlink" title="第一章、类型推导"></a>第一章、类型推导</h3><h4 id="条款1、模板类型推导"><a href="#条款1、模板类型推导" class="headerlink" title="条款1、模板类型推导"></a>条款1、模板类型推导</h4><figure class="highlight d"><table><tr><td class="code"><pre><code class="hljs d">情况一、按值传递，传入副本<br><span class="hljs-keyword">template</span>&lt;typename T&gt;<br><span class="hljs-keyword">void</span> f(T param)<br><br>情况二、引用传递，传入地址<br><span class="hljs-keyword">template</span>&lt;typename T&gt;<br><span class="hljs-keyword">void</span> f(<span class="hljs-keyword">const</span> T&amp; param)<br><br>情况三、指针传递<br><span class="hljs-keyword">template</span>&lt;typename T&gt;<br><span class="hljs-keyword">void</span> f(T* param)<br><br>万能引用，即也可以引用右值<br>情况四、万能引用，如果是右值，则传入的是右值的地址<br><span class="hljs-keyword">template</span>&lt;typename T&gt;<br><span class="hljs-keyword">void</span> f(T&amp;&amp; param)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>当向引用型别的形参传入const对象时，他们期望该对象保持其不可该修改的属性，即const引用</p>
<p>因此向持有T&amp;型别的模板传入const对象时安全的</p>
</blockquote>
<ul>
<li><p>当使用万能引用时，型别推导规则会区分实参是左值还是右值，如果是左值就是单个引用情况“&amp;”，如果是右值则是“&amp;&amp;”情况</p>
</li>
<li><p>如果是按值传递，则传入的是一个副本，无论做什么操作都无法改变原始的数据</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> name[] = <span class="hljs-string">&quot;sda&quot;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptrToName = name<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">f</span>(T param)<br><span class="hljs-built_in">f</span>(name)<br><br>T会推到成<span class="hljs-type">const</span> <span class="hljs-type">char</span>*的类型<br></code></pre></td></tr></table></figure>
<h4 id="条款2、auto类型推导"><a href="#条款2、auto类型推导" class="headerlink" title="条款2、auto类型推导"></a>条款2、auto类型推导</h4><blockquote>
<p>auto类型推导就是模板类型推导，当某一个变量采用auto来声明时，auto则扮演模板中的角色，通过表达式的右边的值推出左边。</p>
</blockquote>
<p>C++14允许auto来说明函数返回值需要推导</p>
<h4 id="条款3、decltype"><a href="#条款3、decltype" class="headerlink" title="条款3、decltype"></a>条款3、decltype</h4><p>decltype可以声明返回值型别依赖于形参性别的函数模板，因为函数模板的数据类型不确定，通过使用decltype引用一个模板类型的数据，可以推出该函数模板的类型，通过尾序返回值可返回该数据类型的结果。</p>
<p>在对万能引用进行推导时，返回值需要加上std::forward</p>
<h3 id="第二章、auto"><a href="#第二章、auto" class="headerlink" title="第二章、auto"></a>第二章、auto</h3><blockquote>
<p>优先使用auto定义，而非使用显式定义，可以防止对象忘记初始化的错误。</p>
</blockquote>
<p>auto优点</p>
<ul>
<li>1、避免初始化变量和冗余的变量声明（如，迭代器声明）</li>
<li>2、在不同位的操作系统移植过程中可以避免参数位数表达不一致的问题</li>
</ul>
<p>auto不能用在vector&lt; bool &gt;中，在单个返回operator[]时返回的是bool的引用。</p>
<h3 id="第三章——模板还是有点晦涩难懂"><a href="#第三章——模板还是有点晦涩难懂" class="headerlink" title="第三章——模板还是有点晦涩难懂"></a>第三章——模板还是有点晦涩难懂</h3><h4 id="条款7、创建对象注意区分（）和"><a href="#条款7、创建对象注意区分（）和" class="headerlink" title="条款7、创建对象注意区分（）和{}"></a>条款7、创建对象注意区分（）和{}</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用大括号初始化容器会强烈优先选择带有std::initializer_list类别形参的构造函数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; v&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure>
<p>空大括号表达的是没有形参，如果使用list的话，应该在小括号在再加一个大括号。</p>
<h4 id="条款8、优先使用nullptr"><a href="#条款8、优先使用nullptr" class="headerlink" title="条款8、优先使用nullptr"></a>条款8、优先使用nullptr</h4><p>作为指针传入参数时，传入空指针优先使用nullptr，因为nullptr指代明确，不像0和NULL既可以指代整型也可以指代空指针。</p>
<p>nullptr可以隐式的转化为所有指针类型。</p>
<h4 id="条款9、优先使用别名声明，而非typedef————-回头看"><a href="#条款9、优先使用别名声明，而非typedef————-回头看" class="headerlink" title="条款9、优先使用别名声明，而非typedef————-回头看"></a>条款9、优先使用别名声明，而非typedef————-回头看</h4><p>using作用可以等效于typedef用于别名的声明，使用using的优势在于，可以将其与模板进行结合起来，别名模板。</p>
<h4 id="条款10、优先使用限定作用域的枚举"><a href="#条款10、优先使用限定作用域的枚举" class="headerlink" title="条款10、优先使用限定作用域的枚举"></a>条款10、优先使用限定作用域的枚举</h4><blockquote>
<p>enum class name{}；使用class关键词限定作用域，又称为枚举类。</p>
</blockquote>
<p>使用枚举的成员需要用到<code>name::</code>来取。</p>
<ul>
<li>使用限定作用域的枚举的枚举量是更强型别的，不限范围的枚举型别中的枚举量可以隐式转化到整数类别。</li>
<li>强类型的参数不能够和非同类型的参数进行比较，也不能进行隐式转换，必须通过强制转化才能够进行比较。</li>
<li>限定作用域的枚举型别可以进行前置声明。不限定作用域的枚举要想进行前置声明，则可以进行对底层型别的声明：enum color: std::uint8_t</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 条款10、优先使用限定作用域的枚举</span><br><span class="hljs-keyword">enum</span> color &#123;<br>	black,<br>	white,<br>	red<br>&#125;;<br><br><span class="hljs-comment">// 重定义报错</span><br><span class="hljs-comment">// auto white = false;</span><br><br><span class="hljs-comment">// 枚举类，限定作用域在color2中</span><br><span class="hljs-keyword">enum</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">color2</span> &#123;<br>	black1,<br>	white1,<br>	red1<br>&#125;;<br><br><span class="hljs-built_in">auto</span> white1 = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">auto</span> c = color2::red1;<br></code></pre></td></tr></table></figure>
<h4 id="条款11、优先选用删除函数"><a href="#条款11、优先选用删除函数" class="headerlink" title="条款11、优先选用删除函数"></a>条款11、优先选用删除函数</h4><p>在类里面的函数后面加上<code>=delete</code>可以组x织客户去调用函数，说明该函数已经失效。</p>
<p>任何函数都可以成为删除函数，但只有成员函数能声明为private。</p>
<h4 id="条款12、在需要改写的函数添后面加上override声明表示子类需要改写这个函数"><a href="#条款12、在需要改写的函数添后面加上override声明表示子类需要改写这个函数" class="headerlink" title="条款12、在需要改写的函数添后面加上override声明表示子类需要改写这个函数"></a>条款12、在需要改写的函数添后面加上override声明表示子类需要改写这个函数</h4><p>函数重写的必要条件：</p>
<ul>
<li>基类中的函数必须是虚函数</li>
<li>函数名字必须完全相同（析构函数例外）</li>
<li>函数形参型别完全相同</li>
<li>函数常量性必须完全相同</li>
<li>函数返回值和异常规格必须兼容</li>
<li>引用饰词必须完全相同</li>
</ul>
<p>成员函数引用饰词的作用就是针对发起成员函数调用的现象，加一些区分度。</p>
<h4 id="条款13、优先选用const-iterator"><a href="#条款13、优先选用const-iterator" class="headerlink" title="条款13、优先选用const_iterator"></a>条款13、优先选用const_iterator</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">// 建立iterator并插入<br>std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = std::find(<span class="hljs-keyword">values</span>.<span class="hljs-keyword">begin</span>(), <span class="hljs-keyword">values</span>.<span class="hljs-keyword">end</span>(), <span class="hljs-number">1983</span>);<br><span class="hljs-keyword">values</span>.<span class="hljs-keyword">insert</span>(it, <span class="hljs-number">1998</span>)<br></code></pre></td></tr></table></figure>
<p>容器的cbegin和cend都返回的是const_iterator型别，不能修改，但是可以通过insert插入元素到列表中。</p>
<p>将const元素传入begin函数中，会产生一个const_iterator</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 条款13、优先选用const_iterator</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo13</span><span class="hljs-params">()</span> </span>&#123;<br>	std::vector&lt;<span class="hljs-type">int</span>&gt; vec&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br><br>	<span class="hljs-keyword">for</span> (std::vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = vec.<span class="hljs-built_in">begin</span>(); iter != vec.<span class="hljs-built_in">end</span>(); ++iter) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;old element:&quot;</span> &lt;&lt; *iter;				<span class="hljs-comment">// 打印元素</span><br><br>		(*iter) += <span class="hljs-number">1</span>;										<span class="hljs-comment">// 通过迭代器修改对应元素</span><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;, new:&quot;</span> &lt;&lt; *iter &lt;&lt; std::endl;<br><br>	&#125;<br><br>	<span class="hljs-keyword">auto</span> it = std::<span class="hljs-built_in">find</span>(vec.<span class="hljs-built_in">cbegin</span>(), vec.<span class="hljs-built_in">cend</span>(), <span class="hljs-number">3</span>);<br>	vec.<span class="hljs-built_in">insert</span>(it, <span class="hljs-number">1</span>);<br><br>	<span class="hljs-keyword">for</span> (std::vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator iter = vec.<span class="hljs-built_in">cbegin</span>(); iter != vec.<span class="hljs-built_in">cend</span>(); ++iter) &#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;old element:&quot;</span> &lt;&lt; *iter &lt;&lt; std::endl;				<span class="hljs-comment">// 打印元素</span><br><br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>优先使用begin，end等，而非成员函数版本</li>
</ul>
<h4 id="条款14、对于确保不发生异常的函数，加上noexcept声明"><a href="#条款14、对于确保不发生异常的函数，加上noexcept声明" class="headerlink" title="条款14、对于确保不发生异常的函数，加上noexcept声明"></a>条款14、对于确保不发生异常的函数，加上noexcept声明</h4><p>在C++98中，出现异常后，调用栈会开解至异常出现的调用方，C++11中，中止前只是可能会解开。因此优化器不需要再异常传出函数的前提下，将执行期间栈保持在开解状态，也不用在异常溢出函数的前提下，保证所有对象的构造顺序的逆序完成解析。</p>
<p><code>push_back</code>中采用的原则是：能移动则移动，必须复制才复制。具有强异常性质。</p>
<p>使用<code>noexcept</code>能够极大程度的便于编译器优化。</p>
<p>析构函数和内存释放函数都隐式的具备又noexcept的性质。</p>
<h4 id="条款15、使用constexpr"><a href="#条款15、使用constexpr" class="headerlink" title="条款15、使用constexpr"></a>条款15、使用constexpr</h4><p>const：表示“只读”的含义，被const修饰的变量不能够修改，可以定义编译器和运行期的常量</p>
<p>constexpr：表示“常量”的含义，只能够定义编译器的常量，可以提高运行效率</p>
<ul>
<li>constexpr修饰的函数在编译过程展开，被隐式的转化为了内联函数</li>
<li>如果要修改const修饰的变量的值，需要加上关键字volatile</li>
</ul>
<p>constexpr函数仅限于掺入和返回字面型别：在编译器就可以确定的数据类型。</p>
<h4 id="条款16、使用const成员函数的线程安全性"><a href="#条款16、使用const成员函数的线程安全性" class="headerlink" title="条款16、使用const成员函数的线程安全性"></a>条款16、使用const成员函数的线程安全性</h4><h4 id="条款17、"><a href="#条款17、" class="headerlink" title="条款17、"></a>条款17、</h4><h3 id="第四章、智能指针"><a href="#第四章、智能指针" class="headerlink" title="第四章、智能指针"></a>第四章、智能指针</h3><blockquote>
<p>智能指针是用来管理内存泄漏的，内存泄漏：在为对象动态申请内存空间后，如存在忘记释放内存，或者运行过程中程序中断的问题，导致申请的内存空间被占用造成内存泄漏。</p>
</blockquote>
<h4 id="条款18、使用unique-ptr管理具备专属所有权的资源"><a href="#条款18、使用unique-ptr管理具备专属所有权的资源" class="headerlink" title="条款18、使用unique_ptr管理具备专属所有权的资源"></a>条款18、使用unique_ptr管理具备专属所有权的资源</h4><p>智能指针<code>unique_ptr</code></p>
<ul>
<li>独享它的对象</li>
<li>包含头文件#include<memory></li>
<li>可以高效的转化为<code>shared_ptr</code></li>
</ul>
<p>unique_ptr和裸指针在默认情况下有着相同的尺寸，实现的是专属所有权语义，</p>
<p>工厂函数返回的是一个<code>unique_ptr</code>指针，可以用auto来接收。</p>
<ul>
<li>将一个裸指针赋值给<code>unique_ptr</code>将不会通过编译</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 智能指针用法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	std::string _name;<br>	<span class="hljs-built_in">AA</span>() &#123;<br>		std::cout &lt;&lt; _name &lt;&lt; <span class="hljs-string">&quot;调用构造函数1\n&quot;</span>;<br>	&#125;<br>	<span class="hljs-built_in">AA</span>(<span class="hljs-type">const</span> std::string&amp; m_name) :_name(m_name) &#123;<br><br>		std::cout &lt;&lt; _name &lt;&lt; <span class="hljs-string">&quot;调用构造函数2\n&quot;</span>;<br>	&#125;<br>	~<span class="hljs-built_in">AA</span>() &#123;<br><br>		std::cout &lt;&lt; <span class="hljs-string">&quot;调用析构函数\n&quot;</span>;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo19</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">using</span> std::unique_ptr;<br>	<span class="hljs-keyword">using</span> std::make_unique;<br>	<span class="hljs-function">unique_ptr&lt;AA&gt; <span class="hljs-title">p0</span><span class="hljs-params">(<span class="hljs-keyword">new</span> AA(<span class="hljs-string">&quot;xiaoli&quot;</span>))</span></span>;<br>	unique_ptr&lt;AA&gt; p1 = std::<span class="hljs-built_in">make_unique</span>&lt;AA&gt;(<span class="hljs-string">&quot;xiaowang&quot;</span>);<br>	unique_ptr&lt;<span class="hljs-type">int</span>&gt; pp1 = <span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;();         <span class="hljs-comment">// 数据类型为int。</span><br>	unique_ptr&lt;AA&gt; pp2 = <span class="hljs-built_in">make_unique</span>&lt;AA&gt;();       <span class="hljs-comment">// 数据类型为AA，默认构造函数。</span><br>	unique_ptr&lt;AA&gt; pp3 = <span class="hljs-built_in">make_unique</span>&lt;AA&gt;(<span class="hljs-string">&quot;xiaoxi&quot;</span>);  <span class="hljs-comment">// 数据类型为AA，一个参数的构造函数。</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="条款19、使用shared-ptr管理具备共享所有权的资源"><a href="#条款19、使用shared-ptr管理具备共享所有权的资源" class="headerlink" title="条款19、使用shared_ptr管理具备共享所有权的资源"></a>条款19、使用shared_ptr管理具备共享所有权的资源</h4><p>RAII思想（Resource Acquisition Is Initialization）资源获取即初始化。将获取的资源和对象的生命周期绑定在一起。</p>
<ul>
<li>设计RAII类的四个步骤<ul>
<li>设计一个类封装资源，资源可以是内存、文件、socket、锁等等一切</li>
<li>在构造函数中执行资源的初始化，比如申请内存、打开文件、申请锁</li>
<li>在析构函数中执行销毁操作，比如释放内存、关闭文件、释放锁</li>
<li>使用时声明一个该对象的类，一般在你希望的作用域声明即可，比如在函数开始，或者作为类的成员变量</li>
</ul>
</li>
</ul>
<p>引用计数带来的一些性能问题：</p>
<ul>
<li>尺寸是裸指针的两倍</li>
<li>引用计数的内存必须动态分配</li>
<li>引用计数的递增和递减必须是原子操作</li>
</ul>
<p>从一个已有shared_ptr移动构造一个新的shared_ptr会将源shared_ptr置空，不会增加引用计数。</p>
<p>使用shared_ptr如果出现了循环引用则会导致计数用于也无法回到0，资源将无法被释放。使用<code>weak_ptr</code>配合使用便可以解决这个问题，因为<code>weak_ptr</code>不会控制对象的生命周期，但是知道对象释放的时间，会和对象共同消失。</p>
<h4 id="条款20、weak-ptr使用"><a href="#条款20、weak-ptr使用" class="headerlink" title="条款20、weak_ptr使用"></a>条款20、weak_ptr使用</h4><p>1、使用<code>weak_ptr</code>代替可能空悬的<code>shared_ptr</code></p>
<p>2、<code>weak_ptr</code>可以用于缓存，观察者列表，以及避免shared_ptr指针环路</p>
<h4 id="条款21、优先使用make-…ptr而不是直接使用new"><a href="#条款21、优先使用make-…ptr而不是直接使用new" class="headerlink" title="条款21、优先使用make_…ptr而不是直接使用new"></a>条款21、优先使用make_…ptr而不是直接使用new</h4><p>1、使用new的代码更加冗余</p>
<p>2、使用new会触发两次内存分配，而使用make系列则只用触发一次内存分配</p>
<h4 id="条款22、Pimpl用法"><a href="#条款22、Pimpl用法" class="headerlink" title="条款22、Pimpl用法"></a>条款22、Pimpl用法</h4><p>将类内的数据成员使用struct结构体打包起来，并使用一个智能指针指向该结构体，在.cpp文件中对这些数据进行操作，能够极大便利的降低类的客户和类的实现者之间的依赖。</p>
<h3 id="右值引用、移动语义和完美转发"><a href="#右值引用、移动语义和完美转发" class="headerlink" title="右值引用、移动语义和完美转发"></a>右值引用、移动语义和完美转发</h3><ul>
<li>移动语义可以使得编译器能够使用移动操作代替昂贵的复制操作。</li>
<li>完美转发使得人们可以撰写接收任意实参的函数模板，并将其转发到其它函数，目标函数会接收到与转发函数所接收到的完全相同的实参。</li>
</ul>
<h4 id="条款23、理解std-move和std-forward"><a href="#条款23、理解std-move和std-forward" class="headerlink" title="条款23、理解std::move和std::forward"></a>条款23、理解std::move和std::forward</h4><p>使用move可以将参数强制转化为右值</p>
<p>如果想要取得对某一个对象执行移动操作的能力，则不要将其声明为常量，因为针对常量对象执行的移动操作将会变化为复制操作。</p>
<p>forward是一个有条件的强制转化，只有当实参是使用右值完成初始化时，它才会执行向右值型别的强制转化。如果需要选择性的对某一些形参进行左值或者右值引用，则可以用forward来进行标识。</p>
<h4 id="条款24、区分万能引用和右值引用"><a href="#条款24、区分万能引用和右值引用" class="headerlink" title="条款24、区分万能引用和右值引用"></a>条款24、区分万能引用和右值引用</h4><p>在模板和类型推导中出现<code>&amp; &amp;</code>很大可能就是万能引用：即表达式或者传入的实参，既可以是左值也可以时右值。</p>
<h4 id="条款25、针对右值引用使用move，针对万能引用使用forward"><a href="#条款25、针对右值引用使用move，针对万能引用使用forward" class="headerlink" title="条款25、针对右值引用使用move，针对万能引用使用forward"></a>条款25、针对右值引用使用move，针对万能引用使用forward</h4><p>因为万能引用使用<code>forward</code>它可以有条件的自动转化传入的实参作为左值还是右值。</p>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h4 id="条例30、完美转发失败的情形"><a href="#条例30、完美转发失败的情形" class="headerlink" title="条例30、完美转发失败的情形"></a>条例30、完美转发失败的情形</h4><p>完美转发的含义：一个函数把自己的形参传递（转发）给另一个函数，为了使得第二个函数接受第一个函数所接受的同一个对象。</p>
<p>完美转发不仅仅转发对象，还转发其显著的特征：型别、是左值还是右值，是否带有const或者volatile修饰词。</p>
<p>转发失败的定义：使用某特定实参调用转发函数会执行某操作，但使用同一实参调用其封装后的函数会执行不同的操作。即右值引用成功，但是万能引用失败。</p>
<p>具体形参：</p>
<ul>
<li>大括号初始化的列表</li>
<li>0或者NULL用作空指针</li>
<li>仅有声明的整型static const成员变量</li>
<li>重载的函数名字和模板名字</li>
<li>位域</li>
</ul>
<h3 id="第五章、lambda表达式"><a href="#第五章、lambda表达式" class="headerlink" title="第五章、lambda表达式"></a>第五章、lambda表达式</h3><p>lambda运行期的对象是<code>闭包</code>，根据不同的捕获模式，闭包会持有数据的副本或引用。</p>
<p>闭包类就是实例化闭包的类，每个lambda式都会触发编译器生成一个独一无二的闭包类。闭包中的语句会变成它的闭包类成员函数的可执行指令。</p>
<h4 id="条款31、避免默认捕获模式"><a href="#条款31、避免默认捕获模式" class="headerlink" title="条款31、避免默认捕获模式"></a>条款31、避免默认捕获模式</h4><p>C++11有两种默认捕获模式：按值或按引用。按引用的默认捕获模式可能导致空悬引用。</p>
<p>按引用捕获会导致闭包包含指涉到局部变量的引用，或者指涉到定义lambda式作用域内的形参的引用。一旦lambda式所创建的闭包越过了该局部变量或者形参的生命周期，那么闭包内的引用就会悬空。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++新特性</tag>
      </tags>
  </entry>
  <entry>
    <title>集成电路物理设计学习笔记</title>
    <url>/2023/08/09/Physical-design/</url>
    <content><![CDATA[<h2 id="第一章、集成电路物理设计方法"><a href="#第一章、集成电路物理设计方法" class="headerlink" title="第一章、集成电路物理设计方法"></a>第一章、集成电路物理设计方法</h2><h3 id="数字集成电路设计流程"><a href="#数字集成电路设计流程" class="headerlink" title="数字集成电路设计流程"></a>数字集成电路设计流程</h3><p>三个I年代，发明，实施和整合</p>
<p>Innovation：布局布线的基本算法、时序分析和逻辑综合的发明</p>
<p>Implementation：开始于FPGA中门阵列的实现，ASIC设计中同等高度标准逻辑单元库的设计</p>
<p>Integration：模块化</p>
<p><strong>芯片的物理实施重点解决的问题</strong></p>
<p>对于深亚微米芯片</p>
<ul>
<li><p>解决时序驱动设计</p>
</li>
<li><p>防止工艺天线效应</p>
</li>
<li>进行信号完整性分析</li>
</ul>
<p>对于纳米的设计，需要多考虑的问题</p>
<ul>
<li>功耗分析和低功耗设计，并要统一考虑它的功能验证，逻辑综合和形式验证</li>
<li>实施纳米设计中的光学近似检查（OPC）和移相掩膜（PSM），增加设计产额和可制造性设计</li>
<li>统计静态时序分析，多端角分析</li>
</ul>
<p><strong>展平式物理设计</strong></p>
<blockquote>
<p>标准逻辑门单元库的简历。采用自下向上的方法，设计晶体管-仿真-建立版图-对逻辑门单元仿真建模</p>
</blockquote>
<img src="/2023/08/09/Physical-design/01.png" class="">
<p><strong>硅虚拟原型设计</strong></p>
<img src="/2023/08/09/Physical-design/02.png" class="">
<p>与展平化的物理设计流程区别</p>
<ul>
<li>布图阶段，考虑将整个设计进行分割</li>
<li>布线时用了快速近似的试验布线法</li>
<li>在做RC提取时，可以用集总电容模型</li>
</ul>
<p><strong>层次化物理设计</strong></p>
<blockquote>
<p>芯片设计的最终检查标准之一为是否实现了时序收敛</p>
</blockquote>
<p>自上而下的层次化物理设计：将设计分为数个分割块，对每个分割块进行展品化处理（独立的布局布线），在顶层完成组装设计</p>
<img src="/2023/08/09/Physical-design/03.png" class="">
<p>优点：将很大的设计化成多个小设计，如果有时序问题可能存在于个别模块，再去重点解决，降低了复杂性。</p>
<ul>
<li><p>基于设计驱动时序图</p>
<p>在顶层设计和模块设计之间建立一个连接的时序图桥梁，从而避免当模块设计完成后回到顶层无法收敛而造成大量的设计迭代。</p>
<p>将模块级的实施分成多个阶段，如时钟树综合，详细布线阶段，布线优化阶段</p>
</li>
</ul>
<h3 id="数字集成电路设计收敛"><a href="#数字集成电路设计收敛" class="headerlink" title="数字集成电路设计收敛"></a>数字集成电路设计收敛</h3><blockquote>
<p>设计时序收敛任务通过三大部分工作来完成：数据系统，优化引擎，分析引擎</p>
<p>数据系统：由读取、处理和存储</p>
<p>优化引擎：基于算法去实现逻辑优化，布局优化，和布线优化</p>
<p>分析引擎：由设计工程师借助EDA工具用于时序分析，功耗分析和噪声分析的EDA工具</p>
</blockquote>
<p><strong>时序收敛</strong></p>
<p>静态时序分析最重要任务：寻找最长延时路径以及最坏情况下的延时</p>
<p>总延时：由逻辑门延时和互连线延时组成</p>
<p>静态时序路径：组合逻辑电路，时序逻辑电路形成的路径</p>
<p><strong>功耗分析</strong></p>
<ul>
<li><p>静态功耗分析</p>
<p>使用时序库提供的器件功耗可以计算</p>
</li>
<li><p>动态功耗分析</p>
<p>需要提供设计仿真的数据</p>
</li>
</ul>
<p>降低功耗的方式：多电源电压方法、门控电路方法、衬底电压偏执方法</p>
<img src="/2023/08/09/Physical-design/04.png" class="">
<h3 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h3><ul>
<li><p>1、讨论什么是数字电路的物理设计和物理实施？</p>
<p>集成电路的物理实施方法被概括为从RTL综合到最终完成GDSII数据的实现，RTL一种硬件描述语言，用于描述数字电路的逻辑功能和寄存器传输级别的行为。GDSII是一种电子设计自动化工具所使用的标准格式，用于描述芯片的物理布局和制造信息。</p>
<p>将RTL转换为GDSII是一个多步骤的过程，通常包括以下几个主要阶段：</p>
<ul>
<li>1、逻辑综合：将RTL描述的电路转换为门级电路，生成门级网表。</li>
<li>2、时序优化：对门级网表进行优化，以减少电路的面积、功耗或者时钟延迟等。</li>
<li>3、布局：根据门级网表生成芯片的物理布局，包括各个组件的位置、尺寸和连线等。</li>
<li>4、布线：根据布局信息进行连线，确保电路的信号可以正确传输。</li>
<li>5、物理验证：对布局和布线结果进行物理验证，包括规则检查、电气特性分析等。<ul>
<li>后面有一个提取阶段</li>
</ul>
</li>
<li>6、转换为GDSII：将经过物理验证的布局和布线结果转化为GDSII格式，生成最终的物理设计数据</li>
</ul>
</li>
<li><p>2、什么是硅虚拟原型SVP？为什么要提出硅虚拟模型设计方法？</p>
<p>硅虚拟原型：是一种基于软件仿真和硬件加速的技术，用于验证和评估芯片设计的功能和新能。</p>
<p>采用硅虚拟模型设计方法能够尽早预估该设计能否大致实现时序收敛，具有更快的设计迭代速度和更低的开发成本。</p>
</li>
<li><p>3、展平式物理设计与层次式物理设计的共同点和不同点是什么？</p>
<p>基本流程都具备，但是步骤顺序可能存在偏差</p>
<p>展平式设计是一种自下而上的模块化方法，从底层器件再到版图</p>
<p>层次化设计是一种自上而下的物理设计方法，从版图再往下</p>
</li>
<li><p>4、设计收敛的实现与设计流程有关吗？</p>
<p>有关，设计流程可以提供一种系统化的方法和框架，能够有效地引导和管理设计的各个阶段，以实现设计收敛，使得设计能够按照预期目标收敛。</p>
</li>
<li><p>5、当今EDA工具的设计所采用的主要的数据文件格式有哪些？数据库格式有哪些？常用的编程语言有哪些？</p>
<p>RTL：硬件描述语言编写的RTL代码</p>
<p>网表：描述芯片的逻辑电路结构和连接关系的文本文件</p>
<p>GDSII：用于描述芯片的物理布局和制造信息的二进制格式</p>
<p>LEF和DEF：用于描述芯片的物理布局和制造信息的二进制格式</p>
<p>SDC：用于定义时序约束的文本文件，指定电路的时序要求和约束条件</p>
</li>
</ul>
<h2 id="第二章、物理设计建库与验证"><a href="#第二章、物理设计建库与验证" class="headerlink" title="第二章、物理设计建库与验证"></a>第二章、物理设计建库与验证</h2><h3 id="集成电路工艺与版图"><a href="#集成电路工艺与版图" class="headerlink" title="集成电路工艺与版图"></a>集成电路工艺与版图</h3><p><strong>CMOS工艺流程</strong></p>
<p>晶圆—形成制造晶体管所需的衬底和阱区—形成晶体管栅层图形—形成源漏、衬底和阱接触等其它有源区—通过接触孔将需要连接的地方与第一层金属互连—进行其它几层金属互连—添加钝化层与外界隔离开</p>
<p><strong>工艺技术文件</strong></p>
<blockquote>
<p>晶体代工厂提供给设计者用于后端版图设计的技术文件，用于与EDA工具交互工艺信息，内容包括图形定义及显示信息，互连线工艺信息和通孔工艺信息</p>
</blockquote>
<h3 id="设计规则检查（DRC）"><a href="#设计规则检查（DRC）" class="headerlink" title="设计规则检查（DRC）"></a>设计规则检查（DRC）</h3><p>主要目的：检查版图中所有因违反设计规则而引起潜在断路，短路或不良效应的物理验证过程</p>
<p><strong>版图设计规则</strong></p>
<blockquote>
<p>晶圆代工厂对不同工艺参数制定出满足芯片制造良率的同一工艺层以及不同工艺层之间几何尺寸的最小值，这些最小值规划的集合就是版图设计规则。</p>
</blockquote>
<ul>
<li>逻辑运算<ul>
<li>AND操作</li>
<li>OR操作</li>
<li>NOT操作，双目运算，A NOT B属于A，但不属于B的部分</li>
</ul>
</li>
<li>拓扑运算<ul>
<li>重叠</li>
<li>包含</li>
<li>相切</li>
</ul>
</li>
<li>集合运算<ul>
<li>面积</li>
<li>周长</li>
<li>间距</li>
</ul>
</li>
</ul>
<h3 id="电路规则检查"><a href="#电路规则检查" class="headerlink" title="电路规则检查"></a>电路规则检查</h3><blockquote>
<p>1、所有信号的电气连接关系是否一致</p>
<p>2、器件类型尺寸是否一致</p>
<p>LVS文件：期间提前规则、电路比较规则、器件捆绑规则</p>
</blockquote>
<p><strong>电路提取与比较</strong></p>
<p>步骤：更具LVS提取规则，从版图中抽取出版图所需要的网表文件。将抽取出的网表文件与电路网表文件做对比。</p>
<p><strong>器件类型和数目及尺寸检查</strong></p>
<ul>
<li>器件类型检查：电阻、电容、电感、双极晶体管、MOS管、二极管<ul>
<li>通过从版图与原理图中寻找名称相一致的器件实现</li>
</ul>
</li>
<li>器件数目与尺寸检查<ul>
<li>检查版图中对应节点上期间的数量以及每个器件的尺寸是否与原理图中对应结点的期间数量与尺寸一致</li>
</ul>
</li>
</ul>
<p><strong>LVS在数字IC中的检查</strong></p>
<p>常用的解决LVS错误的方法</p>
<ul>
<li>检查器件数目</li>
<li>检查器件类型</li>
<li>检查节点数量</li>
<li>检查电源线和地线的连接</li>
<li>从关键点找起</li>
</ul>
<h3 id="版图寄生参数提取与设计仿真"><a href="#版图寄生参数提取与设计仿真" class="headerlink" title="版图寄生参数提取与设计仿真"></a><strong>版图寄生参数提取与设计仿真</strong></h3><p><strong>版图寄生参数提取</strong></p>
<p>版图设计的完整寄生参数应当包括R（电阻）、C（电容）、L（电感）、K（互感）</p>
<p>LPE（版图寄生参数提取）/PRE（寄生电阻提取）提取的主要参数包括MOS管源漏的周长、面积、电阻，沟道的长与宽，双极晶体管和二极管的结面积、结周长，以及结点寄生电容、互连线电容电阻、接触孔电阻等。</p>
<p><strong>版图设计仿真</strong></p>
<p>使用牛顿迭代法，用泰勒级数的前几项来寻找方程f(x)=0的根</p>
<h3 id="逻辑单元库的建立"><a href="#逻辑单元库的建立" class="headerlink" title="逻辑单元库的建立"></a>逻辑单元库的建立</h3><blockquote>
<p>逻辑单元的建库流程归纳为以下5步</p>
<p>1、方案设计与论证</p>
<p>2、电路设计</p>
<p>3、版图设计与物流库生成</p>
<p>4、标准单元特性及库模型生成</p>
<p>5、设计验证</p>
</blockquote>
<p><strong>逻辑单元类别</strong></p>
<p>完整的单元库根据在芯片中的应用可以分为三类</p>
<ul>
<li><p>标准单元(standard cell)</p>
<p>放置于芯片的核心区起逻辑功能粘接作用</p>
</li>
<li><p>模块宏单元(macro block)</p>
<p>放置于芯片核心区，至少包括嵌入式存储器（RAM和ROM）、IP、COT模块</p>
<p>其它重要的宏单元模块：始终PLL模块，DSP模块</p>
</li>
<li><p>输入输出单元(I/O pad cell)</p>
<p>放置于核区的周围，用于芯片信号的输入、输出和电源供给</p>
</li>
</ul>
<img src="/2023/08/09/Physical-design/05.png" class="">
<p><strong>逻辑单元电路</strong></p>
<p>组合逻辑电路简称为组合电路包括</p>
<ul>
<li>反向逻辑电路：反向器、与非门、或非门</li>
<li>非反向逻辑电路：缓冲器、与门、或门</li>
<li>其它常用逻辑电路：数据选择门（MUX）、异或门、数据传输门（TBUF）、复合门（AOI）</li>
<li>特殊功能的逻辑电路：加法器、乘法器、除法器</li>
</ul>
<p>时序逻辑电路也称为时序电路</p>
<blockquote>
<p>输出信号不但同但钱的输入相关还和上一时间的输出有关，具有记忆功能</p>
</blockquote>
<p>包括：</p>
<ul>
<li>锁存器（Latch）：专指电平敏感的时序电路</li>
<li>寄存器类（flip flop）：时钟边沿出发</li>
</ul>
<p><strong>模块单元（宏单元模块）</strong></p>
<p>存储单元ROM：NOR ROM、NAND ROM、EPROM、EEPROM、FAMOS ROM</p>
<p>存储单元RAM：静态随机存储器SRAM、动态随机存储器DRAM</p>
<p>专用模块：客户自由工具COT，专用标准产品ASSP，信号处理器DSP</p>
<p>黑盒子商业IP模块：电路设计不公开</p>
<p>模拟电路模块：时钟锁相环PLL模块</p>
<p><strong>输入输出单元</strong></p>
<blockquote>
<p>包括输入信号、输出信号、三态门、双向、电源和接地单元</p>
</blockquote>
<p>对于输入单元要考虑静电放电的防护</p>
<p>形成电阻的方法：n型扩散层、p型扩散层和多晶硅</p>
<p>形成电容的方法：Poly、Mos栅电容</p>
<p><strong>物理单元库与数据文件，LEF文件</strong></p>
<img src="/2023/08/09/Physical-design/01.png" class="">
<p>标准单元建库的规则</p>
<ul>
<li>所有单元都等高的矩形，或者是基本高度的整数倍</li>
<li>所有版图都用预先定义的模板进行设计</li>
<li>所有单元的端口位置、大小、形状都尽量满足网格间距的要求</li>
<li>电源线和地线一般位于单元的上下边界</li>
</ul>
<p>模块单元建库</p>
<ul>
<li>先建立RAM和ROM的基本单元</li>
<li>根据比特和字长，自底向上堆砌生成版图</li>
</ul>
<p>I/O单元</p>
<ul>
<li>IO拐角单元在芯LEF文档的单元类型中被定义为Endcap，分布在拐角处</li>
</ul>
<p><strong>时序单元建库与数据文件</strong></p>
<p>器件延时：表示信号通过一个逻辑门时所经历的时间，反映了门对输入信号变化响应的快慢。通过输入信号电压变化的50%到输出信号电压变化的50%所需要的时间来定义门延时的大小。</p>
<img src="/2023/08/09/Physical-design/06.png" class="">
<p>用于DSM设计的器件延时模型</p>
<ul>
<li>开关线性RC模型</li>
<li>经验推导公式（K-Factor方程）</li>
<li>非线性延时模型</li>
<li>可伸缩多项式模型</li>
</ul>
<p>时序库文件</p>
<img src="/2023/08/09/Physical-design/07.png" class="">
<p>EDA工具通常采用两种模型计算天线比率，一种时部分检查模型，另一种是积累检查模型</p>
<h3 id="习题：-1"><a href="#习题：-1" class="headerlink" title="习题："></a>习题：</h3><ul>
<li><p>1、什么是标准单元库？它主要包括哪几类单元？它们分别在电路中起什么作用？</p>
<p>标准单元库是一种预先设计和验证的模块化的芯片单元集合，用于构建数字集成电路，包含了经过验证和优化的标准逻辑门和寄存器等基本单元，可以在芯片设计中重复使用，以节省设计时间和提高设计的可靠性。</p>
<p>主要包括：逻辑门、寄存器、编码解码器、算术逻辑单元、存储器单元</p>
<p>使用标准单元库可以提高设计的效率，降低设计风险，促进可重用性。</p>
</li>
<li><p>2、标准单元有几种不同抽象级别的描述？为什么要采用不同抽象层描述同一电路单元？</p>
<p>逻辑级描述、电路级描述、物理级描述</p>
<p>采用不同抽象层描述同一电路单元可以更好的管理设计的不同方面，优化设计的性能和可靠性，并在设计复杂性和效率之间进行权衡。</p>
</li>
<li><p>3、解释LEF库文件在物理实施布局布线中的作用和重要性，并说明它所定义的内容是如何知道EDA工具实现自动布局布线的。</p>
<p>LEF库文件定义了标准单元的物理特性，包括尺寸大小方向以及引脚位置和功能等等</p>
<p>EDA工具实现自动布局布线是通过读取和解析LEF库文件中的信息。工具可以根据LEF文件中定义的物理特性和约束，生成优化芯片的物理布局和连线。</p>
</li>
</ul>
<h2 id="第三章、布图规划（芯片规划）和布局"><a href="#第三章、布图规划（芯片规划）和布局" class="headerlink" title="第三章、布图规划（芯片规划）和布局"></a>第三章、布图规划（芯片规划）和布局</h2><h3 id="布图规划"><a href="#布图规划" class="headerlink" title="布图规划"></a>布图规划</h3><p>布图规划开始时，首先要准备好各种基本设计数据和相应的物理库、时序库文件，并输入到不图规划的工具环境中来</p>
<img src="/2023/08/09/Physical-design/08.png" class="">
<p>布图规划主要内容包含对芯片大小的规划、芯片设计输入输出单元的规划、大量硬核或模块的规划</p>
<p><strong>布图规划的主要目标</strong></p>
<ul>
<li>确定芯片的面积</li>
<li>确保时序的收敛</li>
<li>保证芯片的稳定</li>
<li>满足布线的要求：保证布线通畅的同时，尽量缩短走线的长度</li>
</ul>
<p><strong>I/O接口单元的放置与供电</strong></p>
<p>放置方式：1、pin点方式，2、pad条状方式，3、做成固定模块，将pad集成</p>
<p>当芯片面积较大，芯片时序较为紧张时，I/O单元也可能均匀分布在芯片的内部</p>
<p>I/O单元的供电：I/O单元分为信号接口和电源两种</p>
<p>电源I/O单元分为3类：给模拟器件供电的I/O单元、给数字期间供电的、用于隔离数字供电和模拟供电</p>
<p>数字I/O也分为两大组：一组是给I/O单元供电，一组是给核内的标准单元供电</p>
<p>给I/O单元供电的供电单元数量由多种因素决定：I/O单元的消耗、输出I/O单元的驱动能力、同步开关噪声</p>
<p><strong>布图规划方案与延迟预估</strong></p>
<p>展平化设计</p>
<p>因为还没有进入布线阶段，使用线负载模型预估当前布局的时序，展平式的方法会占用大量的内存，需要很长的运行时间。</p>
<p>层次化设计</p>
<blockquote>
<p>思想是将大规模的顶层设计分解成多个子模块，每个子模块并行完成布局布线，最后在顶层组装。</p>
<p>大致分为三个步骤：芯片顶层设计规划、子模块分割与实现、芯片顶层组装时序</p>
</blockquote>
<p>在层次化设计的过程中，需要在布图和布局规划中对时钟进行预估，流程图如下：</p>
<blockquote>
<p>根据子模块大小，和子模块中的元件数量以及复杂度来进行预估</p>
</blockquote>
<img src="/2023/08/09/Physical-design/09.png" class="">
<p><strong>模块布放与布线通道</strong></p>
<p>布线轨道：芯片内部专门用于布线的路径</p>
<p>布线通道：每两条或多条布线轨道的空间，上面不可以摆放标准单元</p>
<h3 id="电源规划"><a href="#电源规划" class="headerlink" title="电源规划"></a>电源规划</h3><blockquote>
<p>给整个芯片的供电设计出一个均匀的网络，电源规划在芯片布图规划后或在布图规划过程中交叉完成。</p>
<p>电源网络设置、数字模拟混合供电、单电源与多电源供电电压网络设置</p>
</blockquote>
<p>芯片供电是通过I/O单元来实现的，需要先完成电源预算，</p>
<p><strong>电源网络设计</strong></p>
<ul>
<li>电源连接关系定义global net connect</li>
<li>芯片核内部分的电源环设计power ring</li>
<li>芯片内所包含的硬核（如 RAM、ROM以及IP、COT模块）的电源环设计</li>
<li>芯片核内纵横交错的电源网络设计</li>
<li>芯片的供电单元与电源环的连接</li>
<li>芯片内部的电源网络与硬核电源环连接部分的设计</li>
<li>将标准单元的供电网络和硬核电源环连接部分的设计</li>
<li>I/O供电单元电源环的设计</li>
</ul>
<p>1、全局电源</p>
<p>电源的定义主要包括：全局电源的定义以及连接关系的定义。</p>
<ul>
<li>电源和接地网络：通过wire定义</li>
<li>接高电压和接低电压网络</li>
<li>电压和接地端口</li>
<li>填充单元网络</li>
</ul>
<p>2、电源环线</p>
<p>为了能够均匀供电，包围在标准单元周围的环形供电金属，是连接供电I/O单元和标准单元的桥梁</p>
<p>电源网格可以平均分布电流，缩短电流回路，在有效减少电压降的同时，避免由于电流分布不均时造成的热点现象以及电迁移问题。</p>
<p>3、电源条线</p>
<p>芯片内部纵横交错的电源网格和电源条线设计有专门的理论和算法。</p>
<img src="/2023/08/09/Physical-design/10.png" class="">
<p>纵向必须用偶数层走线，横向必须用奇数层走线。</p>
<p><strong>数字与模拟混合供电</strong></p>
<p>1、模拟模块的工作区域一般放置于芯片的某个角落</p>
<p>2、模拟区域需要单独供电</p>
<p>3、在模拟模块的周围布置保护隔离环，从而实现数字信号和模拟信号电源之间的隔离</p>
<img src="/2023/08/09/Physical-design/11.png" class="">
<p><strong>多电源供电</strong>（麻了，看不懂）</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><blockquote>
<p>因为此时以及将芯片的各个部分规划好了，需要在具体规划的区域中填充详细的模块</p>
</blockquote>
<p><strong>展平式布局</strong></p>
<p>模块的摆放与布局</p>
<p>标准单元的摆放和优化</p>
<p>简单来说：放置模块和标准单元·</p>
<p><strong>层次化布局</strong></p>
<blockquote>
<p>先分配子模块、作子模块的布局、所有子模块完成后在顶层组装</p>
</blockquote>
<ul>
<li><p>约束类型确定</p>
<blockquote>
<p>约束类型一般有三种：向导约束、区域约束和限制约束</p>
</blockquote>
</li>
<li><p>子模块大小位置的制定</p>
</li>
</ul>
<p><strong>布局目标预估</strong></p>
<blockquote>
<p>在标准单元布局优化完成后，需要对设计进行拥塞分析，静态时序分析，噪声分析，和电源分析以确定布局的好坏</p>
</blockquote>
<p>布局的目标</p>
<ul>
<li>各模块的位置相对确定</li>
<li>满足设计规则的要求</li>
<li>芯片的时序和供电较为良好</li>
</ul>
<p><strong>标准单元布局优化算法</strong></p>
<blockquote>
<p>布局优化的算法从步骤上可以分成三个阶段：结群布局、全局布局、详细布局</p>
</blockquote>
<p>1、布局优化的算法</p>
<ul>
<li><p>结群算法（clustering聚类算法）</p>
<p>选择一个单元作为种子，以各个种子为原始群不断结合与其最紧密的单元。</p>
</li>
<li><p>模拟退火算法、KL算法、FM算法</p>
</li>
<li><p>全局布局：最小切割法、模拟退火算法、贪心算法、力向量算法、NRG算法、HALO算法</p>
</li>
<li><p>布局优化算法：纯标准单元布局算法、模块布局算法、混合单元布局算法</p>
</li>
</ul>
<p>2、从优化目标上优化算法</p>
<ul>
<li>基于布线拥塞的布局优化算法</li>
<li>基于时序的布局算法</li>
<li>预防噪声的布局算法</li>
</ul>
<h3 id="扫描链重组"><a href="#扫描链重组" class="headerlink" title="扫描链重组"></a>扫描链重组</h3><blockquote>
<p>扫描链是可测试性设计的重要内容，将芯片中所应用的普通寄存器替换成带扫描功能的多输入输出扫描寄存器，首位连接成串，从而实现附加的测试功能。</p>
</blockquote>
<p>将连接在扫描链上的在芯片内随机分布的扫描寄存器单元按照其物理位置，在不影响逻辑功能的前提下，重写进行连接，从而减少扫描链的走线长度。</p>
<p>实现方法：</p>
<ul>
<li>本地化重组</li>
<li>基于扫描DEF的扫描链重组方法</li>
</ul>
<h3 id="物理设计网表文件"><a href="#物理设计网表文件" class="headerlink" title="物理设计网表文件"></a>物理设计网表文件</h3><p>DEF(design exchange format)文件：设计交换给格式</p>
<p>PDEF(physical DEF)：物理设计交换格式</p>
<h2 id="第四章时钟树综合CTS"><a href="#第四章时钟树综合CTS" class="headerlink" title="第四章时钟树综合CTS"></a>第四章时钟树综合CTS</h2><h3 id="时钟信号"><a href="#时钟信号" class="headerlink" title="时钟信号"></a>时钟信号</h3><p><strong>时钟信号抖动</strong>：时钟抖动定义为信号时间与理想事件时间的偏差，抖动中含有确定抖动成分和随机抖动成分。</p>
<ul>
<li>确定抖动：串扰、电磁干扰、同时开关输出引起</li>
<li>随即抖动：服从高斯分布，通常由半导体晶体结构的热振动和半导体掺杂密度不均匀中共价电子引起</li>
</ul>
<h3 id="时钟树综合的方法"><a href="#时钟树综合的方法" class="headerlink" title="时钟树综合的方法"></a>时钟树综合的方法</h3><blockquote>
<p>芯片设计中的时钟分为两类：真实时钟（real clock）和虚拟时钟（virtual clock）</p>
<p>真实时钟又有两种模式：时钟树综合前没有延时的理想时钟，时钟树综合后的传播时钟</p>
</blockquote>
<p><strong>时钟树综合与标准设计约束文件</strong>：SDC文件（时序约束文件）</p>
<p>SDC文件三部分：时钟定义、输入延迟、输出延迟</p>
<p>通过工艺文件来约束时钟信号的相关属性</p>
<p>时钟的定义将通过时钟树综合来实现，时钟延迟和时钟抖动或不确定性将在静态时序分析时进行检查。</p>
<p><strong>时钟树结构</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">时钟树：时钟信号在物理设计中的实现结果<br>根节点：时钟信号的起点<br>叶结点：时钟信号经过一系列分布结点最终到达寄存器时钟输入端或其它时钟终点<br>根单元、分布单元、叶单元：根节点、分布节点和叶结点都依附于的逻辑单元<br></code></pre></td></tr></table></figure>
<p>时钟网络从根节点逐级插入驱动器，从而到达其叶结点，按照芯片始终网络的约束要求产生时钟树的过程叫做是中暑综合。</p>
<img src="/2023/08/09/Physical-design/image-20230809095839094.png" class="" title="image-20230809095839094">
<p>时钟树根据其在芯片内的分布特征，可分为多种结构：H树、 X树、平衡树、疏状或脊椎状时钟网</p>
<h3 id="时钟树设计策略"><a href="#时钟树设计策略" class="headerlink" title="时钟树设计策略"></a>时钟树设计策略</h3><p><strong>时钟树综合策略</strong></p>
<ul>
<li>自我交叉</li>
<li>相互交叉时钟</li>
<li>有用偏差</li>
</ul>
<img src="/2023/08/09/Physical-design/image-20230809102800761.png" class="" title="image-20230809102800761">
<ul>
<li><p>OVC片上误差分析法与CPPR共同路径悲观去除的应用</p>
</li>
<li><p>与布局相结合的手动时钟树设计</p>
</li>
<li>对时钟插入多驱动的buffer</li>
</ul>
<p><strong>异步时钟树设计</strong></p>
<p>实际的SoC设计中，是以异步时钟设计来实现的，从而降低功耗</p>
<img src="/2023/08/09/Physical-design/image-20230809105341276.png" class="" title="image-20230809105341276">
<p><strong>门控时钟</strong></p>
<p>门控时钟是降低功耗最常用的方法，使用一个控制信号控制时钟的开启。</p>
<h3 id="时钟树分析"><a href="#时钟树分析" class="headerlink" title="时钟树分析"></a>时钟树分析</h3><p><strong>时钟树与功耗分析</strong></p>
<blockquote>
<p>时钟树上的功耗由静态功耗、短路功耗和跳变功耗三部分组成</p>
</blockquote>
<ul>
<li>静态功耗：各个buffer上静态功耗和，减少静态功耗的方法就是减少buffer的加权数</li>
<li>短路功耗：与转换时间成正比，与阈值电压的3次方成反比</li>
<li>跳变功耗：占比50%以上，由门的加权数值以及互连线总的电容决定</li>
</ul>
<p>降低功耗的方案</p>
<ul>
<li>1、减小时钟信号转换时间，信号从10%转化到90%所需要的时间</li>
<li>2、降低结点电容</li>
</ul>
<h2 id="第五章、布线"><a href="#第五章、布线" class="headerlink" title="第五章、布线"></a>第五章、布线</h2><blockquote>
<p>将分布在芯片核内的模块、标准单元和输入输出接口单元按逻辑关系进行互联</p>
<p>要求百分百地完成它们之间的所有逻辑信号的互联，并为满足各种约束条件进行优化</p>
</blockquote>
<h3 id="全局布线"><a href="#全局布线" class="headerlink" title="全局布线"></a>全局布线</h3><p><strong>全局布线目标</strong></p>
<ul>
<li>1、使总连线最短</li>
<li>2、布线分散均匀不至于引起局部拥塞</li>
<li>3、使关键路径延时最小，遵守时序规则</li>
<li>4、理解信号完整性要求，避免串扰</li>
<li>5、保持将BUS总线聚集相连等</li>
</ul>
<p><strong>全局布线规划</strong></p>
<h3 id="详细布线"><a href="#详细布线" class="headerlink" title="详细布线"></a>详细布线</h3><p><strong>详细布线的目标</strong></p>
<ul>
<li>1、理解所有的设计规则</li>
<li>2、自动切换并综合利用多层金属作连线</li>
<li>3、遵守时序规则，优先使关键路径的延时满足要求</li>
<li>4、对总连线长度进行优化</li>
</ul>
<p><strong>详细布线与设计规则</strong></p>
<ul>
<li>设计规则</li>
<li>通孔和最小面积要求</li>
<li>密度要求</li>
<li>掩膜光刻过程中的工艺天线效应</li>
<li>串扰在布线中的预防和修复</li>
<li>纳米布线规则</li>
<li>对焦布线规则</li>
</ul>
<p><strong>布线修正</strong></p>
<ul>
<li>自动修正</li>
<li>渐进修正</li>
<li>局部修正</li>
</ul>
<h2 id="第六章、静态时序分析"><a href="#第六章、静态时序分析" class="headerlink" title="第六章、静态时序分析"></a>第六章、静态时序分析</h2><blockquote>
<p>做时序分析前，首先要对芯片的物理版图设计进行包括电阻、电感、电容参数的提取，在进行延时计算。</p>
</blockquote>
<h3 id="延迟计算与布线参数提取"><a href="#延迟计算与布线参数提取" class="headerlink" title="延迟计算与布线参数提取"></a>延迟计算与布线参数提取</h3><p><strong>延迟计算模型</strong></p>
<blockquote>
<p>可以在布局之后进行，也可以在时钟树综合后进行。使用WLM区估算</p>
</blockquote>
<p>各种参数提取、各种物理公式：电阻电容电感</p>
<h3 id="寄生参数与延迟格式文件"><a href="#寄生参数与延迟格式文件" class="headerlink" title="寄生参数与延迟格式文件"></a>寄生参数与延迟格式文件</h3><p>1、标准寄生参数格式文件</p>
<ul>
<li>SPF-Standard Parasistic Format（File），标准寄生参数格式文件</li>
<li>DSPF-Detailed SPF，详细标准寄生参数格式文件</li>
<li>RSPF-Reduced SPF，简化标准寄生参数格式文件</li>
<li>SPEF-Standard Parasitic Exchange Format（File），标准寄生参数交换格式文件</li>
</ul>
<h3 id="静态时序分析"><a href="#静态时序分析" class="headerlink" title="静态时序分析"></a>静态时序分析</h3><blockquote>
<p>进行时序分析时，简单的说就是将某一段路径的时序与时序约束的要求进行比较。根本目的是为了检查在时钟的控制和要求的约束下，与其相关的数据能够符合时序要求被记录存储下来，这种时序检查就是一对常说的建立时间时序和保持时间时序。</p>
</blockquote>
<p>Setup定义：在时钟作用前沿到达前，同步输入信号D必须保持稳定的那段时间以使信号不至于丢失。</p>
<p>Hold定义：在时钟作用前沿到达后，同步输入信号D必须保持稳定的那段时间以使得信号不至于丢失。</p>
<p>1、建立时序（Setup）的违例</p>
<p>要求同步输入数据D必须在时钟信号前的某个时段到达且不发射变化，这样数据才会被成功的锁存。</p>
<p>2、保存时序违例</p>
<p>增长数据的路径延迟</p>
<p><strong>时序分析与时钟特性</strong></p>
<ul>
<li>定义输入输出环境参数<ul>
<li>1、确定驱动</li>
<li>2、确定驱动单元</li>
<li>3、确定负载</li>
<li>4、确定删除</li>
</ul>
</li>
</ul>
<h3 id="时序优化"><a href="#时序优化" class="headerlink" title="时序优化"></a>时序优化</h3><p><strong>造成时序违例的因素</strong></p>
<ul>
<li>1、系统设计的复杂性和抽象性，存在不合理的约束</li>
<li>2、逻辑综合时依据了不合理的WLM</li>
<li>3、设计太大，互连线的相互牵制引起时序违例</li>
<li>4、设计做了不合理的布局</li>
</ul>
<h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1、什么是静态时序分析？描述它的分析步骤过程。</p>
<ul>
<li>静态时序分析是一种在设计和验证数字电路时用于评估电路时序特性的方法。主要用于分析电路中的时序路径，包括组合逻辑路径和时钟路径，以确保电路在给定的时钟频率下能够满足时序要求。是一种基于约束和路径分析的方法，用于评估电路的时序特性和性能。</li>
</ul>
<p>2、什么是建立时间和保持时间？什么是虚假路径、多周期路径？</p>
<ul>
<li>建立时间：在时钟上升沿到来之前，为了确保输入数据能够稳定的被采样，输入信号必须保持不变的最小时间。</li>
<li>保持时间：在时钟上升沿到来之后，为了确保输入数据能够完整的写入，输入型号必须保持不变的最小时间。</li>
<li>虚假路径：在时序分析中被认为不需要满足时序约束的路径。这些路径不会对电路的正常工作产生影响，因此可以被忽略。</li>
<li>多周期路径：信号的传播时间可以超过一个周期。</li>
</ul>
<p>3、如何保证物理实施阶段的时序收敛？</p>
<ul>
<li>通过静态时序分析</li>
</ul>
<h2 id="第七章、功耗分析"><a href="#第七章、功耗分析" class="headerlink" title="第七章、功耗分析"></a>第七章、功耗分析</h2><blockquote>
<p>动态分析：芯片工作过程中产生的功耗</p>
<p>静态分析：芯片在待机状态时产生的平均功耗</p>
</blockquote>
<h3 id="静态功耗分析"><a href="#静态功耗分析" class="headerlink" title="静态功耗分析"></a>静态功耗分析</h3><blockquote>
<p>反偏二极管泄漏电流</p>
<p>门栅感应漏极泄漏电流</p>
<p>亚阈值泄漏电流</p>
<p>门栅泄漏电流</p>
</blockquote>
<h3 id="动态功耗分析"><a href="#动态功耗分析" class="headerlink" title="动态功耗分析"></a>动态功耗分析</h3><blockquote>
<p>开关功耗+短路功耗</p>
</blockquote>
<h3 id="电压降分析与电迁移分析"><a href="#电压降分析与电迁移分析" class="headerlink" title="电压降分析与电迁移分析"></a><strong>电压降分析与电迁移分析</strong></h3><p>电迁移：在一定的制造工艺下，在它上面所能允许流过的最大电流是有一定限度的，否则过大的电流将会使金属连线断裂，导致芯片失效，这种由于电流引起的电路失效现象称为EM电迁移。</p>
<p>电源网络的电迁移由平均电流密度、金属宽度以及孔的大小决定</p>
<p>电迁移容限测量方法：漂移速度法、低频噪声法、电阻模型模拟、等，常用寿命测试法（测量一定数量的相同样品在规定条件下的失效时间）</p>
<h3 id="功耗分析数据文件"><a href="#功耗分析数据文件" class="headerlink" title="功耗分析数据文件"></a>功耗分析数据文件</h3><blockquote>
<p>功耗分析需要建立相应的数据库，并且借助于与功耗相关的文件来有效地控制和处理这些数据</p>
</blockquote>
<p>静态分析数据——TCF文件</p>
<p>动态分析数据——输入多两个重要信息：电源凸点的位置分布信息和动态功耗仿真用的VCD文件+TWF文件</p>
<p><strong>电源网格视图库</strong>——PGV(power grid view)</p>
<blockquote>
<p>用于分析芯片电压降效应的一种库文档格式</p>
<p>使用PGV库计算功耗的精度不是很高</p>
<p>根据供电网络分布，首先分别提取电源网络的电阻和电流节点处的平均结点阀门电流，再建立电源网络视图库</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>集成电路</tag>
        <tag>物理设计</tag>
        <tag>EDA</tag>
        <tag>Pyhsical Design</tag>
      </tags>
  </entry>
  <entry>
    <title>A-Star算法模拟实现</title>
    <url>/2023/07/28/a-star-assignment/</url>
    <content><![CDATA[<h2 id="A-star算法模拟实现"><a href="#A-star算法模拟实现" class="headerlink" title="A star算法模拟实现"></a>A star算法模拟实现</h2><h3 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h3><p>已知如下图地图，黑色表示障碍物无法通行，要求实现避障算法寻找从红色起点出发到达绿色终点的最优路径。</p>
<img src="/2023/07/28/a-star-assignment/1.jpg" class="" title="img">
<p>要求：</p>
<p>（1） 对图中的地图进行建模，抽象成类，对数据进行封装；</p>
<p>（2） 思考寻路算法的实现，对问题进行拆解，对算法实现也要求抽象接口类；</p>
<p>（3） 使用给定的C++工程模板，按照模板编写CMakeLists.txt，以及Google Test单元测试，DoxyGen注释的使用。</p>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><blockquote>
<p>拿到题目最开始的想法就是想静态的实现对地图的绘制，然后对Astar算法进行复习，通过思考过后，觉得map形状，起始点，终点以及障碍，都是可以由用户通过交互的方式来完成的，进而选择将一些必要的数据聚合在类里面封装起来，本次实验一共设计了两个类，分别为Point（用于存储点的信息），Map（用于存储地图的相关信息，同时前端界面的拓展）</p>
</blockquote>
<h4 id="1、点的坐标抽象成一个结构体"><a href="#1、点的坐标抽象成一个结构体" class="headerlink" title="1、点的坐标抽象成一个结构体"></a>1、点的坐标抽象成一个结构体</h4><p>Xy结构体存储的是点的位置坐标，x表示横坐标，y表示纵坐标，初始值都设置为0。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">struct Xy<br>&#123;<br>    int x <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>    int y <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<h4 id="2、地图上的每一个点抽象成一个Point类"><a href="#2、地图上的每一个点抽象成一个Point类" class="headerlink" title="2、地图上的每一个点抽象成一个Point类"></a>2、地图上的每一个点抽象成一个Point类</h4><ul>
<li>Point类中含有的私有成员</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Xy _xy</td>
<td style="text-align:center">Xy结构体，存储当前Point的坐标信</td>
</tr>
<tr>
<td style="text-align:center">int _value</td>
<td style="text-align:center">状态码，用于标记当前的坐标的Point状态</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Point类中含有的公有成员</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int _f</td>
<td style="text-align:center">总代价</td>
</tr>
<tr>
<td style="text-align:center">int _g</td>
<td style="text-align:center">当前走过的代价</td>
</tr>
<tr>
<td style="text-align:center">int _h</td>
<td style="text-align:center">到终点的代价</td>
</tr>
<tr>
<td style="text-align:center">Point* _parent;</td>
<td style="text-align:center">存储上一个经过的Point保存路径信息</td>
</tr>
<tr>
<td style="text-align:center">Point();</td>
<td style="text-align:center">默认构造函数</td>
</tr>
<tr>
<td style="text-align:center">Point(int m_x, int m_y, int m_value);</td>
<td style="text-align:center">重载构造函数</td>
</tr>
<tr>
<td style="text-align:center">~Point();</td>
<td style="text-align:center">析构函数</td>
</tr>
<tr>
<td style="text-align:center">void insertAbs();</td>
<td style="text-align:center">将当前Point设置为障碍</td>
</tr>
<tr>
<td style="text-align:center">void insertFirst();</td>
<td style="text-align:center">将当前Point设置为起始点</td>
</tr>
<tr>
<td style="text-align:center">void insertFinal();</td>
<td style="text-align:center">将当前Point设置为终点</td>
</tr>
<tr>
<td style="text-align:center">void insertNoAbs();</td>
<td style="text-align:center">将当前Point设置成非障碍</td>
</tr>
<tr>
<td style="text-align:center">void insertPriority();</td>
<td style="text-align:center">将当前Point设置为优先队列内</td>
</tr>
<tr>
<td style="text-align:center">int getValue();</td>
<td style="text-align:center">获取当前状态码</td>
</tr>
<tr>
<td style="text-align:center">void updateF();</td>
<td style="text-align:center">更新_f值</td>
</tr>
<tr>
<td style="text-align:center">Xy getXy();</td>
<td style="text-align:center">得到坐标信息</td>
</tr>
<tr>
<td style="text-align:center">void setParent(Point&amp; p);</td>
<td style="text-align:center">设置父节点</td>
</tr>
<tr>
<td style="text-align:center">bool operator&lt;(const Point&amp; point1)const;</td>
<td style="text-align:center">重载比较函数作为优先队列第三个参数</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Point类的友元函数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Point&amp; m_point);</td>
<td style="text-align:center">重载输出运算符打印Point信息</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3、将地图抽象程一个Map类"><a href="#3、将地图抽象程一个Map类" class="headerlink" title="3、将地图抽象程一个Map类"></a>3、将地图抽象程一个Map类</h4><ul>
<li>Map类中含有的私有成员</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int _length;</td>
<td style="text-align:center">地图的长度</td>
</tr>
<tr>
<td style="text-align:center">int _weight;</td>
<td style="text-align:center">地图的宽度</td>
</tr>
<tr>
<td style="text-align:center">Xy _first;</td>
<td style="text-align:center">起始点的坐标信息</td>
</tr>
<tr>
<td style="text-align:center">Xy _final;</td>
<td style="text-align:center">终点的坐标信息</td>
</tr>
<tr>
<td style="text-align:center">std::vector&lt; std::vector&lt; Point  &gt; &gt; _map;</td>
<td style="text-align:center">整个地图由二维的Point组成</td>
</tr>
<tr>
<td style="text-align:center">std::priority_queue&lt; Point &gt; _point_open;</td>
<td style="text-align:center">存放当前优先队列中的点</td>
</tr>
<tr>
<td style="text-align:center">std::vector&lt; Xy &gt; _path;</td>
<td style="text-align:center">寻路完毕过后的路径信息</td>
</tr>
<tr>
<td style="text-align:center">bool _haveway = 1;</td>
<td style="text-align:center">表示当前地图是否有通路</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Map类中含有的公有成员</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Map();</td>
<td style="text-align:center">默认构造函数</td>
</tr>
<tr>
<td style="text-align:center">Map(int m_length, int m_weight);</td>
<td style="text-align:center">重载构造函数，通过地图的宽和高来初始化地图</td>
</tr>
<tr>
<td style="text-align:center">void insertAbs(int x, int y);</td>
<td style="text-align:center">将当前点设置为障碍</td>
</tr>
<tr>
<td style="text-align:center">void insertFirst(int x, int y);</td>
<td style="text-align:center">将当前点设置为起始点</td>
</tr>
<tr>
<td style="text-align:center">void insertFinal(int x, int y);</td>
<td style="text-align:center">将当前点设置为终点</td>
</tr>
<tr>
<td style="text-align:center">void deleteAbs(int x, int y);</td>
<td style="text-align:center">删除当前障碍点</td>
</tr>
<tr>
<td style="text-align:center">bool isOnBoard(Xy xy);</td>
<td style="text-align:center">判断当前点是否越界</td>
</tr>
<tr>
<td style="text-align:center">int twoPointDistance(Xy point1, Xy point2);</td>
<td style="text-align:center">计算两点之间的斜线距离</td>
</tr>
<tr>
<td style="text-align:center">int gAdd(Xy point1, Xy point2);</td>
<td style="text-align:center">计算代价_g的增量距离</td>
</tr>
<tr>
<td style="text-align:center">void aStar();</td>
<td style="text-align:center">实现AStar算法</td>
</tr>
<tr>
<td style="text-align:center">void getPath();</td>
<td style="text-align:center">存储起点到终点的最短路径</td>
</tr>
<tr>
<td style="text-align:center">void reStart();</td>
<td style="text-align:center">刷新状态码和初始化操作</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>Map类的友元函数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Map&amp; m_map);</td>
<td style="text-align:center">重载输出运算符，用于整个地图的输出，输出的数据为各个坐标位置的状态码</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>拓展，用于前端的成员</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">成员名</th>
<th style="text-align:center">具体含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void paintEvent(QPaintEvent* event) override;</td>
<td style="text-align:center">重写绘图画笔事件</td>
</tr>
<tr>
<td style="text-align:center">void mousePressEvent(QMouseEvent* event);</td>
<td style="text-align:center">重写鼠标监听事件</td>
</tr>
<tr>
<td style="text-align:center">int start_x = 10;</td>
<td style="text-align:center">基坐标x</td>
</tr>
<tr>
<td style="text-align:center">int start_y = 10;</td>
<td style="text-align:center">基坐标y</td>
</tr>
<tr>
<td style="text-align:center">int gsize = 50;</td>
<td style="text-align:center">网格大小</td>
</tr>
<tr>
<td style="text-align:center">bool start_button = 0;<br/>bool final_button = 0;<br/>bool abs_button = 0;<br/>bool a_star_button = 0;<br/>bool clear_button = 1;<br/>bool restart_button = 0;</td>
<td style="text-align:center">鼠标资源的控制符号</td>
</tr>
<tr>
<td style="text-align:center">int last_x = 0;</td>
<td style="text-align:center">记录上一次鼠标点击的坐标x</td>
</tr>
<tr>
<td style="text-align:center">int last_y = 0;</td>
<td style="text-align:center">记录上一次鼠标点击的坐标y</td>
</tr>
</tbody>
</table>
</div>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><blockquote>
<p>核心算法用到的是A-Star算法，这是一个启发式算法，属于贪心算法和bfs的结合，使用的贪心选择策略为当前预计的最小代价，通过代价函数来确定其下一步应该走的路径，每一次都记录上一次路过的结点，最终到达终点以后即可获得走过的路径。    </p>
</blockquote>
<figure class="highlight nsis"><table><tr><td class="code"><pre><code class="hljs nsis">算法描述<br><span class="hljs-number">1</span>、建一个优先队列，优先队列按照代价从低到高进行排序。<br><span class="hljs-number">2</span>、计算起始点的代价，将起始点<span class="hljs-keyword">push</span>到优先队列中。<br><span class="hljs-number">3</span>、不断从优先队列中取出<span class="hljs-literal">top</span>的元素，并将其周围的点<span class="hljs-keyword">push</span>到优先队列中，周围的点满足的条件，不是障碍，且不在当前的openlist中，若在其中则比较代价大小，代价小则更新。并将父节点的记录保存下来。<br><span class="hljs-number">4</span>、如果已经到了终点，则按照父节点寻找路径。<br><span class="hljs-number">5</span>、若优先队列为空以后，则说明起点到终点没有路径。<br></code></pre></td></tr></table></figure>
<img src="/2023/07/28/a-star-assignment/image-20230803165730214.png" class="" title="image-20230803165730214">
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h3><ul>
<li><p>地图的长和宽</p>
<p>用户手动输入地图的长和宽，得到长和宽以后，会自动初始化地图大小</p>
</li>
<li><p>输入起始点</p>
<p>选择地图上的某一空白处作为起始点</p>
</li>
<li><p>输入终点</p>
<p>选择地图上的某一空白处作为终点</p>
</li>
<li><p>输入障碍</p>
<p>选择地图上的空白处可以设置为障碍</p>
</li>
<li><p>清除障碍</p>
<p>点击clear_abs可以将障碍清除</p>
</li>
<li><p>寻路</p>
<p>点击a-star进行从起点到终点的寻路</p>
</li>
</ul>
<h4 id="输入测试："><a href="#输入测试：" class="headerlink" title="输入测试："></a>输入测试：</h4><blockquote>
<p>在本次实验中，一共设置了6个可以提供选择的按钮，当按钮处于灰色状态时，代表按钮处于未被激活状态，即该按钮不可点击，当按钮处于蓝色则说明按钮可点击。</p>
<p>ADD_FIRST        设置起点</p>
<p>ADD_FINAL        设置终点</p>
<p>A_STAR                使用Astar开始寻路</p>
<p>ADD_ABS            设置障碍</p>
<p>CLEAR_ABS            清除障碍</p>
<p>RESTART                重新开始，将一些状态清除</p>
</blockquote>
<ul>
<li>测试一、5行10列</li>
</ul>
<img src="/2023/07/28/a-star-assignment/image-20230803171605818.png" class="" title="image-20230803171605818">
<ul>
<li>测试二、3行5列</li>
</ul>
<img src="/2023/07/28/a-star-assignment/image-20230803171645811.png" class="" title="image-20230803171645811">
<h4 id="结果测试"><a href="#结果测试" class="headerlink" title="结果测试"></a>结果测试</h4><blockquote>
<p>结果说明：</p>
<p>绿色的网格代表设置的起点</p>
<p>红色的网格代表设置的终点</p>
<p>黑色的网格代表设置的障碍</p>
<p>白色的网格代表可以通路</p>
<p>灰色的网格代表寻路算法经过的搜索空间</p>
</blockquote>
<ul>
<li>测试一、无障碍情况</li>
</ul>
<img src="/2023/07/28/a-star-assignment/image-20230803172210807.png" class="" title="image-20230803172210807">
<img src="/2023/07/28/a-star-assignment/image-20230803173053255.png" class="" title="image-20230803173053255">
<ul>
<li>测试二、随机障碍情况</li>
</ul>
<img src="/2023/07/28/a-star-assignment/image-20230803173141837.png" class="" title="image-20230803173141837">
<img src="/2023/07/28/a-star-assignment/image-20230803173212434.png" class="" title="image-20230803173212434">
<img src="/2023/07/28/a-star-assignment/image-20230803173244879.png" class="" title="image-20230803173244879">
<img src="/2023/07/28/a-star-assignment/image-20230803173329009.png" class="" title="image-20230803173329009">
<ul>
<li><p>测试三、无通路情况</p>
<blockquote>
<p>没有通路，则不会寻路，状态码为5的表示搜索到了的位置，从打印出的状态码中可以看出，搜索在障碍的边界处便中断了。</p>
</blockquote>
</li>
</ul>
<img src="/2023/07/28/a-star-assignment/image-20230803173754572.png" class="" title="image-20230803173754572">
<img src="/2023/07/28/a-star-assignment/image-20230803173808529.png" class="" title="image-20230803173808529">
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="遇到的一些问题"><a href="#遇到的一些问题" class="headerlink" title="遇到的一些问题"></a>遇到的一些问题</h4><ul>
<li><p><strong>优先队列中比较函数的使用</strong></p>
<p>最开始使用的是代价f值作为比较函数中的参数，这样会导致一种情况，如果有两个代价一样的结点插入优先队列的时候，在下一次弹出优先队列的过程中，代价一样的结点会按照进入队列的先后顺序来进行弹出，也就是说在代价相同的结点中是按照广度优先的方式来进行的。但是如果我们在f值相同的情况下，再对h值进行比较，每次优先选择h值最小即最接近终点的结点出队列，这样就会将解空间缩小很多，具体案例如下所示。</p>
<ul>
<li>使用两个参数的比较函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> Point::<span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; point1)<span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">if</span> (_f == point1._f) <span class="hljs-keyword">return</span> _h &gt; point1._h;<br>    <span class="hljs-keyword">return</span> _f &gt; point1._f;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<img src="/2023/07/28/a-star-assignment/image-20230803183655944.png" class="" title="image-20230803183655944">
<ul>
<li><ul>
<li>使用一个参数的比较函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> Point::<span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Point&amp; point1)<span class="hljs-type">const</span> &#123;<br>    <span class="hljs-comment">// if (_f == point1._f) return _h &gt; point1._h;</span><br>    <span class="hljs-keyword">return</span> _f &gt; point1._f;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<img src="/2023/07/28/a-star-assignment/image-20230803183939400.png" class="" title="image-20230803183939400">
<ul>
<li><p><strong>关于插入优先队列以后是否需要更新f值的问题</strong></p>
<p>在起初的版本中，通过简单的分析认为不需要更新f值，因为最开始认为如果能够在之前就到达的位置，再后面再到达了，说明会绕一些弯路，所以这样的f值肯定会大于或等于最开始进入openlist的结点。但在运行过程中出现了下面的问题，问题就是因为没有更新f值造成的，因为在最优路径中第一次遍历的最优路径上的点，不一定是通过最优路径中的点遍历的，所以会存在有f更小的现象。</p>
</li>
</ul>
<img src="/2023/07/28/a-star-assignment/%E9%97%AE%E9%A2%98%EF%BC%9A%E6%8F%92%E5%85%A5%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BB%A5%E5%90%8E%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%96%B0f%E5%80%BC.png" class="" title="问题：插入优先队列以后没有更新f值">
<ul>
<li><p><strong>在优先队列中查找元素的问题</strong></p>
<p>优先队列是一个堆的结构，很适用于取出最大值或者最小值，但如果是想要从优先队列中找到某一个元素，就较为难办了，在实验中出现的场景便是，需要确认当前遍历的结点是否在优先队列中，如果在优先队列中，则需要进行比较，不在的话则插入。</p>
<p>采用的方式是在Point类中加入了一个value参数，用于表示当前结点的状态码，当value为0时表示属于通路，1表示障碍，2表示起点，3表示终点，5表示在优先队列中，通过这样的方式便可以极大便利的获取当前结点的状态值，并达到随机访问结点状态的现象，如果某一个结点在优先队列中，只需要查看该节点的状态码即可。设置状态码还有一个好处，如果需要重新开始的话，只需要将该节点的状态码改为0即可。</p>
</li>
<li><p><strong>一个超级无脑的小bug</strong></p>
<p>在调试过程中，发现无法进行多次寻路，找了将近一天，最后发现Point中使用指针存储的parent结点用于寻路，下意识的在析构函数中使用delete删除parent，因为没有给parent分配内存，是使用等号复制地址的。所以在使用界面交互进行多次寻路的过程中，出现内存被回收的问题，窗口强制退出。</p>
</li>
<li><p><strong>前端遇到的一些问题</strong></p>
<p>前端需要解决的最主要的问题并不是绘图，而是资源状态的获取问题，获取鼠标事件，以及如何控制不同的点击执行不同的操作，最后使用一些bool值来进行组合完成。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>A*算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Cmake学习笔记</title>
    <url>/2023/07/26/cmake-study/</url>
    <content><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>cmake的定义  ——-高级编译配置工具</p>
<p>当多个人用不同的语言或者编译器开发一个项目，最终要输出一个可执行文件或者共享库（dll，so等等）需要用到—-CMake</p>
<p>所有操作都是通过编译CMakeLists.txt来完成的—简单</p>
<p>官网 <a href="http://www.cmake.org/">www.cmake.org</a></p>
<h1 id="CMake安装"><a href="#CMake安装" class="headerlink" title="CMake安装"></a>CMake安装</h1><p><a href="http://www.cmake.org/HTML/Download.html">http://www.cmake.org/HTML/Download.htm</a>l  可以下载安装</p>
<h1 id="CMake一个HelloWord"><a href="#CMake一个HelloWord" class="headerlink" title="CMake一个HelloWord"></a>CMake一个HelloWord</h1><p>1、写一个HelloWord</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#main.cpp</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>std::cout &lt;&lt;  <span class="hljs-string">&quot;hello word&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2、写CMakeLists.txt</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">#CMakeLists.<span class="hljs-function">txt</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">PROJECT</span> <span class="hljs-params">(HELLO)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">SET</span><span class="hljs-params">(SRC_LIST main.cpp)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">MESSAGE</span><span class="hljs-params">(STATUS <span class="hljs-string">&quot;This is BINARY dir &quot;</span> $&#123;HELLO_BINARY_DIR&#125;)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">MESSAGE</span><span class="hljs-params">(STATUS <span class="hljs-string">&quot;This is SOURCE dir &quot;</span>$&#123;HELLO_SOURCE_DIR&#125;)</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">ADD_EXECUTABLE</span><span class="hljs-params">(hello $&#123;SRC_LIST&#125;)</span></span><br></code></pre></td></tr></table></figure>
<p>3、使用cmake，生成makefile文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">cmake .<br><br>输出：<br>[root@localhost cmake]<span class="hljs-meta"># cmake .</span><br><span class="hljs-function">CMake <span class="hljs-title">Warning</span> <span class="hljs-params">(dev)</span> in CMakeLists.txt:</span><br><span class="hljs-function">  Syntax Warning in cmake code at</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /root/cmake/CMakeLists.txt:<span class="hljs-number">7</span>:<span class="hljs-number">37</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">  Argument not separated from preceding token by whitespace.</span><br><span class="hljs-function">This warning is for project developers.  Use -Wno-dev to suppress it.</span><br><span class="hljs-function"></span><br><span class="hljs-function">-- The C compiler identification is GNU <span class="hljs-number">10.2</span><span class="hljs-number">.1</span></span><br><span class="hljs-function">-- The CXX compiler identification is GNU <span class="hljs-number">10.2</span><span class="hljs-number">.1</span></span><br><span class="hljs-function">-- Check for working C compiler: /usr/bin/cc</span><br><span class="hljs-function">-- Check for working C compiler: /usr/bin/cc -- works</span><br><span class="hljs-function">-- Detecting C compiler ABI info</span><br><span class="hljs-function">-- Detecting C compiler ABI info - done</span><br><span class="hljs-function">-- Check for working CXX compiler: /usr/bin/c++</span><br><span class="hljs-function">-- Check for working CXX compiler: /usr/bin/c++ -- works</span><br><span class="hljs-function">-- Detecting CXX compiler ABI info</span><br><span class="hljs-function">-- Detecting CXX compiler ABI info - done</span><br><span class="hljs-function">-- This is BINARY dir /root/cmake</span><br><span class="hljs-function">-- This is SOURCE dir /root/cmake</span><br><span class="hljs-function">-- Configuring done</span><br><span class="hljs-function">-- Generating done</span><br><span class="hljs-function">-- Build files have been written to: /root/cmake</span><br></code></pre></td></tr></table></figure>
<p>目录下就生成-CMakeFiles, CMakeCache.txt, cmake_install.cmake 等文件，并且生成了Makefile.</p>
<p>4、使用make命令编译</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">root@localhost cmake]<span class="hljs-meta"># make</span><br>Scanning dependencies of target hello<br>[<span class="hljs-number">100</span>%] Building CXX object CMakeFiles/hello.dir/main.cpp.o<br>Linking CXX executable hello<br>[<span class="hljs-number">100</span>%] Built target hello<br></code></pre></td></tr></table></figure>
<p>5、最终生成了Hello的可执行程序</p>
<h1 id="CMake一个HelloWord-的语法介绍"><a href="#CMake一个HelloWord-的语法介绍" class="headerlink" title="CMake一个HelloWord-的语法介绍"></a>CMake一个HelloWord-的语法介绍</h1><h2 id="PROJECT关键字"><a href="#PROJECT关键字" class="headerlink" title="PROJECT关键字"></a>PROJECT关键字</h2><p>可以用来指定工程的名字和支持的语言，默认支持所有语言</p>
<p>PROJECT (HELLO)   指定了工程的名字，并且支持所有语言—建议</p>
<p>PROJECT (HELLO CXX)      指定了工程的名字，并且支持语言是C++</p>
<p>PROJECT (HELLO C CXX)      指定了工程的名字，并且支持语言是C和C++</p>
<p>该指定隐式定义了两个CMAKE的变量</p>
<p><projectname>_BINARY_DIR，HELLO_BINARY_DIR</p>
<p><projectname>_SOURCE_DIR，HELLO_SOURCE_DIR</p>
<p>MESSAGE关键字就可以直接使用者两个变量，当前都指向当前的工作目录，后面会讲外部编译</p>
<p>问题：如果改了工程名，这两个变量名也会改变</p>
<p>解决：再定义两个预定义变量：PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，这两个变量和HELLO_BINARY_DIR，HELLO_SOURCE_DIR是一致的。所以改了工程名也没有关系</p>
<h2 id="SET关键字"><a href="#SET关键字" class="headerlink" title="SET关键字"></a>SET关键字</h2><p>用来显示的指定变量的</p>
<p>SET(SRC_LIST main.cpp)    SRC_LIST变量就包含了main.cpp</p>
<p>也可以 SET(SRC_LIST main.cpp t1.cpp t2.cpp)</p>
<h2 id="MESSAGE关键字"><a href="#MESSAGE关键字" class="headerlink" title="MESSAGE关键字"></a>MESSAGE关键字</h2><p>向终端输出用户自定义的信息</p>
<p>主要包含三种信息：</p>
<ul>
<li>SEND_ERROR，产生错误，生成过程被跳过。</li>
<li>SATUS，输出前缀为—的信息。</li>
<li>FATAL_ERROR，立即终止所有 cmake 过程.</li>
</ul>
<h2 id="ADD-EXECUTABLE关键字"><a href="#ADD-EXECUTABLE关键字" class="headerlink" title="ADD_EXECUTABLE关键字"></a>ADD_EXECUTABLE关键字</h2><p>生成可执行文件</p>
<p>ADD_EXECUTABLE(hello ${SRC_LIST})     生成的可执行文件名是hello，源文件读取变量SRC_LIST中的内容</p>
<p>也可以直接写 ADD_EXECUTABLE(hello main.cpp)</p>
<p>上述例子可以简化的写成</p>
<p>PROJECT(HELLO)<br>ADD_EXECUTABLE(hello main.cpp)</p>
<p>注意：工程名的 HELLO 和生成的可执行文件 hello 是没有任何关系的</p>
<h1 id="语法的基本原则"><a href="#语法的基本原则" class="headerlink" title="语法的基本原则"></a>语法的基本原则</h1><ul>
<li><p>变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名</p>
</li>
<li><p>指令(参数 1 参数 2…) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.cpp 源文件</p>
<p>就要写成：ADD_EXECUTABLE(hello main.cpp func.cpp)或者ADD_EXECUTABLE(hello main.cpp;func.cpp)</p>
</li>
<li><p>指令是大小写无关的，参数和变量是大小写相关的。推荐全部使用大写指令</p>
</li>
</ul>
<h2 id="语法注意事项"><a href="#语法注意事项" class="headerlink" title="语法注意事项"></a>语法注意事项</h2><ul>
<li>SET(SRC_LIST main.cpp) 可以写成 SET(SRC_LIST “main.cpp”)，如果源文件名中含有空格，就必须要加双引号</li>
<li>ADD_EXECUTABLE(hello main) 后缀可以不行，他会自动去找.c和.cpp，最好不要这样写，可能会有这两个文件main.cpp和main</li>
</ul>
<h1 id="内部构建和外部构建"><a href="#内部构建和外部构建" class="headerlink" title="内部构建和外部构建"></a>内部构建和外部构建</h1><ul>
<li>上述例子就是内部构建，生产的临时文件特别多，不方便清理</li>
<li>外部构建，就会把生成的临时文件放在build目录下，不会对源文件有任何影响强烈使用外部构建方式</li>
</ul>
<h2 id="外部构建方式举例"><a href="#外部构建方式举例" class="headerlink" title="外部构建方式举例"></a>外部构建方式举例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//例子目录，CMakeLists.txt和上面例子一致</span><br>[root@localhost cmake]<span class="hljs-meta"># pwd</span><br>/root/cmake<br>[root@localhost cmake]<span class="hljs-meta"># ll</span><br>total <span class="hljs-number">8</span><br>-rw-r--r--. <span class="hljs-number">1</span> root root <span class="hljs-number">198</span> Dec <span class="hljs-number">28</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span> CMakeLists.txt<br>-rw-r--r--. <span class="hljs-number">1</span> root root  <span class="hljs-number">76</span> Dec <span class="hljs-number">28</span> <span class="hljs-number">00</span>:<span class="hljs-number">18</span> main.cpp<br></code></pre></td></tr></table></figure>
<p>1、建立一个build目录，可以在任何地方，建议在当前目录下</p>
<p>2、进入build，运行cmake ..    当然..表示上一级目录，可以写CMakeLists.txt所在的绝对路径，生产的文件都在build目录下了</p>
<p>3、在build目录下，运行make来构建工程</p>
<p>注意外部构建的两个变量</p>
<p>1、HELLO_SOURCE_DIR  还是工程路径</p>
<p>2、HELLO_BINARY_DIR   编译路径 也就是 /root/cmake/bulid</p>
<h1 id="让Hello-World看起来更像一个工程"><a href="#让Hello-World看起来更像一个工程" class="headerlink" title="让Hello World看起来更像一个工程"></a>让Hello World看起来更像一个工程</h1><ul>
<li>为工程添加一个子目录 src，用来放置工程源代码</li>
<li>添加一个子目录 doc，用来放置这个工程的文档 hello.txt</li>
<li>在工程目录添加文本文件 COPYRIGHT, README</li>
<li>在工程目录添加一个 <a href="http://runhello.sh/">runhello.sh</a> 脚本，用来调用 hello 二进制</li>
<li>将构建后的目标文件放入构建目录的 bin 子目录</li>
<li>将 doc 目录 的内容以及 COPYRIGHT/README 安装到/usr/share/doc/cmake/</li>
</ul>
<h2 id="将目标文件放入构建目录的-bin-子目录"><a href="#将目标文件放入构建目录的-bin-子目录" class="headerlink" title="将目标文件放入构建目录的 bin 子目录"></a>将目标文件放入构建目录的 bin 子目录</h2><p>每个目录下都要有一个CMakeLists.txt说明</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">[root@localhost cmake]<span class="hljs-meta"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>└── src<br>    ├── CMakeLists.txt<br>    └── main.cpp<br></code></pre></td></tr></table></figure>
<p>外层CMakeLists.txt</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">PROJECT</span>(HELLO)<br><span class="hljs-built_in">ADD_SUBDIRECTORY</span>(src bin)<br></code></pre></td></tr></table></figure>
<p>src下的CMakeLists.txt</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">ADD_EXECUTABLE</span>(hello main.cpp)<br></code></pre></td></tr></table></figure>
<h3 id="ADD-SUBDIRECTORY-指令"><a href="#ADD-SUBDIRECTORY-指令" class="headerlink" title="ADD_SUBDIRECTORY 指令"></a>ADD_SUBDIRECTORY 指令</h3><p>ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</p>
<ul>
<li><p>这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置</p>
</li>
<li><p>EXCLUDE_FROM_ALL函数是将写的目录从编译中排除，如程序中的example</p>
</li>
<li><p>ADD_SUBDIRECTORY(src bin)</p>
<p>将 src 子目录加入工程并指定编译输出(包含编译中间结果)路径为bin 目录</p>
<p>如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在build/src 目录</p>
</li>
</ul>
<h3 id="更改二进制的保存路径"><a href="#更改二进制的保存路径" class="headerlink" title="更改二进制的保存路径"></a>更改二进制的保存路径</h3><p>SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量 来指定最终的目标二进制的位置</p>
<p>SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)<br>SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib)</p>
<p>思考：加载哪个CMakeLists.txt当中</p>
<p>哪里要改变目标存放路径，就在哪里加入上述的定义，所以应该在src下的CMakeLists.txt下写</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>一种是从代码编译后直接 make install 安装</li>
<li>一种是打包时的指定 目录安装。<ul>
<li>简单的可以这样指定目录：make install DESTDIR=/tmp/test</li>
<li>稍微复杂一点可以这样指定目录：./configure –prefix=/usr</li>
</ul>
</li>
</ul>
<h2 id="如何安装HelloWord"><a href="#如何安装HelloWord" class="headerlink" title="如何安装HelloWord"></a>如何安装HelloWord</h2><p>使用CMAKE一个新的指令：INSTALL</p>
<p>INSTALL的安装可以包括：二进制、动态库、静态库以及文件、目录、脚本等</p>
<p>使用CMAKE一个新的变量：CMAKE_INSTALL_PREFIX</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 目录树结构</span><br>[root@localhost cmake]<span class="hljs-meta"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>├── COPYRIGHT<br>├── doc<br>│   └── hello.txt<br>├── README<br>├── runhello.sh<br>└── src<br>    ├── CMakeLists.txt<br>    └── main.cpp<br><br><span class="hljs-number">3</span> directories, <span class="hljs-number">7</span> files<br></code></pre></td></tr></table></figure>
<h3 id="安装文件COPYRIGHT和README"><a href="#安装文件COPYRIGHT和README" class="headerlink" title="安装文件COPYRIGHT和README"></a>安装文件COPYRIGHT和README</h3><p>INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/)</p>
<p>FILES：文件</p>
<p>DESTINATION：</p>
<p>1、写绝对路径</p>
<p>2、可以写相对路径，相对路径实际路径是：${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径></p>
<p>CMAKE_INSTALL_PREFIX  默认是在 /usr/local/</p>
<p>cmake -DCMAKE_INSTALL_PREFIX=/usr    在cmake的时候指定CMAKE_INSTALL_PREFIX变量的路径</p>
<h3 id="安装脚本runhello-sh"><a href="#安装脚本runhello-sh" class="headerlink" title="安装脚本runhello.sh"></a>安装脚本runhello.sh</h3><p>PROGRAMS：非目标文件的可执行程序安装(比如脚本之类)</p>
<p>INSTALL(PROGRAMS runhello.sh DESTINATION bin)</p>
<p>说明：实际安装到的是 /usr/bin</p>
<h3 id="安装-doc-中的-hello-txt"><a href="#安装-doc-中的-hello-txt" class="headerlink" title="安装 doc 中的 hello.txt"></a>安装 doc 中的 hello.txt</h3><ul>
<li><p>一、是通过在 doc 目录建立CMakeLists.txt ，通过install下的file</p>
</li>
<li><p>二、是直接在工程目录通过</p>
<p>INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake)</p>
</li>
</ul>
<p>DIRECTORY 后面连接的是所在 Source 目录的相对路径</p>
<p>注意：abc 和 abc/有很大的区别</p>
<p>目录名不以/结尾：这个目录将被安装为目标路径下的</p>
<p>目录名以/结尾：将这个目录中的内容安装到目标路径</p>
<h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>cmake ..</p>
<p>make</p>
<p>make install</p>
<h1 id="静态库和动态库的构建"><a href="#静态库和动态库的构建" class="headerlink" title="静态库和动态库的构建"></a>静态库和动态库的构建</h1><p>任务：</p>
<p>１，建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 </p>
<p>２，安装头文件与共享库。</p>
<p>静态库和动态库的区别</p>
<ul>
<li>静态库的扩展名一般为“.a”或“.lib”；动态库的扩展名一般为“.so”或“.dll”。</li>
<li>静态库在编译时会直接整合到目标程序中，编译成功的可执行文件可独立运行</li>
<li>动态库在编译时不会放到连接的目标程序中，即可执行文件无法单独运行。</li>
</ul>
<h2 id="构建实例"><a href="#构建实例" class="headerlink" title="构建实例"></a>构建实例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">[root@localhost cmake2]<span class="hljs-meta"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>└── lib<br>    ├── CMakeLists.txt<br>    ├── hello.cpp<br>    └── hello.h<br></code></pre></td></tr></table></figure>
<p>hello.h中的内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HELLO_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Hello_H</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HelloFunc</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>
<p>hello.cpp中的内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;hello.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HelloFunc</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>项目中的cmake内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">PROJECT</span>(HELLO)<br><span class="hljs-built_in">ADD_SUBDIRECTORY</span>(lib bin)<br></code></pre></td></tr></table></figure>
<p>lib中CMakeLists.txt中的内容</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SET</span>(LIBHELLO_SRC hello.cpp)<br><span class="hljs-built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)<br></code></pre></td></tr></table></figure>
<h3 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h3><p>ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC})</p>
<ul>
<li>hello：就是正常的库名，生成的名字前面会加上lib，最终产生的文件是libhello.so</li>
<li>SHARED，动态库    STATIC，静态库</li>
<li>${LIBHELLO_SRC} ：源文件</li>
</ul>
<h3 id="同时构建静态和动态库"><a href="#同时构建静态和动态库" class="headerlink" title="同时构建静态和动态库"></a>同时构建静态和动态库</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 如果用这种方式，只会构建一个动态库，不会构建出静态库，虽然静态库的后缀是.a</span><br><span class="hljs-built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)<br><span class="hljs-built_in">ADD_LIBRARY</span>(hello STATIC $&#123;LIBHELLO_SRC&#125;)<br><br><span class="hljs-comment">// 修改静态库的名字，但是往往希望他们的名字是相同的，只是后缀不同</span><br><span class="hljs-built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)<br><span class="hljs-built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)<br></code></pre></td></tr></table></figure>
<h3 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h3><p>这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本</p>
<p>同时构建静态和动态库</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">SET</span>(LIBHELLO_SRC hello.cpp)<br><br><span class="hljs-built_in">ADD_LIBRARY</span>(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)<br><br><span class="hljs-comment">//对hello_static的重名为hello</span><br><span class="hljs-built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES  OUTPUT_NAME <span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-comment">//cmake 在构建一个新的target 时，会尝试清理掉其他使用这个名字的库，因为，在构建 libhello.so 时， 就会清理掉 libhello.a</span><br><span class="hljs-built_in">SET_TARGET_PROPERTIES</span>(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">ADD_LIBRARY</span>(hello SHARED $&#123;LIBHELLO_SRC&#125;)<br><br><span class="hljs-built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES  OUTPUT_NAME <span class="hljs-string">&quot;hello&quot;</span>)<br><span class="hljs-built_in">SET_TARGET_PROPERTIES</span>(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="hljs-number">1</span>)<br><br></code></pre></td></tr></table></figure>
<h3 id="动态库的版本号"><a href="#动态库的版本号" class="headerlink" title="动态库的版本号"></a>动态库的版本号</h3><p>一般动态库都有一个版本号的关联</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">libhello.so<span class="hljs-number">.1</span><span class="hljs-number">.2</span><br>libhello.so -&gt;libhello.so<span class="hljs-number">.1</span><br>libhello.so<span class="hljs-number">.1</span>-&gt;libhello.so<span class="hljs-number">.1</span><span class="hljs-number">.2</span><br></code></pre></td></tr></table></figure>
<p>CMakeLists.txt 插入如下</p>
<p><code>SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)</code></p>
<p>VERSION 指代动态库版本，SOVERSION 指代 API 版本。</p>
<h3 id="安装共享库和头文件"><a href="#安装共享库和头文件" class="headerlink" title="安装共享库和头文件"></a>安装共享库和头文件</h3><p>本例中将 hello 的共享库安装到<prefix>/lib目录，</p>
<p>将 hello.h 安装到<prefix>/include/hello 目录</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//文件放到该目录下</span><br><span class="hljs-built_in">INSTALL</span>(FILES hello.h DESTINATION include/hello)<br><br><span class="hljs-comment">//二进制，静态库，动态库安装都用TARGETS</span><br><span class="hljs-comment">//ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。</span><br><span class="hljs-built_in">INSTALL</span>(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib)<br></code></pre></td></tr></table></figure>
<p>注意：</p>
<p>安装的时候，指定一下路径，放到系统下</p>
<p><code>cmake -DCMAKE_INSTALL_PREFIX=/usr ..</code></p>
<h3 id="使用外部共享库和头文件"><a href="#使用外部共享库和头文件" class="headerlink" title="使用外部共享库和头文件"></a>使用外部共享库和头文件</h3><p>准备工作，新建一个目录来使用外部共享库和头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">[root@MiWiFi-R4CM-srv cmake3]<span class="hljs-meta"># tree</span><br>.<br>├── build<br>├── CMakeLists.txt<br>└── src<br>    ├── CMakeLists.txt<br>    └── main.cpp<br></code></pre></td></tr></table></figure>
<p>main.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hello.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">HelloFunc</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="解决：make后头文件找不到的问题"><a href="#解决：make后头文件找不到的问题" class="headerlink" title="解决：make后头文件找不到的问题"></a>解决：make后头文件找不到的问题</h3><p>PS：include <hello/hello.h>  这样include是可以，这么做的话，就没啥好讲的了</p>
<p>关键字：INCLUDE_DIRECTORIES    这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割</p>
<p>在CMakeLists.txt中加入头文件搜索路径</p>
<p>INCLUDE_DIRECTORIES(/usr/include/hello)</p>
<h3 id="解决：找到引用的函数问题"><a href="#解决：找到引用的函数问题" class="headerlink" title="解决：找到引用的函数问题"></a>解决：找到引用的函数问题</h3><p>报错信息：undefined reference to `HelloFunc()’</p>
<p>关键字：LINK_DIRECTORIES     添加非标准的共享库搜索路径</p>
<p>指定第三方库所在路径，LINK_DIRECTORIES(/home/myproject/libs)</p>
<p>关键字：TARGET_LINK_LIBRARIES    添加需要链接的共享库</p>
<p>TARGET_LINK_LIBRARIES的时候，只需要给出动态链接库的名字。</p>
<p>在CMakeLists.txt中插入链接共享库，主要要插在executable的后面</p>
<p>查看main的链接情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">[root@MiWiFi-R4CM-srv bin]<span class="hljs-meta"># ldd main </span><br>	linux-vdso.so<span class="hljs-number">.1</span> =&gt;  (<span class="hljs-number">0x00007ffedfda4000</span>)<br>	libhello.so =&gt; /lib64/libhello.<span class="hljs-built_in">so</span> (<span class="hljs-number">0x00007f41c0d8f000</span>)<br>	libstdc++.so<span class="hljs-number">.6</span> =&gt; /lib64/libstdc++.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f41c0874000</span>)<br>	libm.so<span class="hljs-number">.6</span> =&gt; /lib64/libm.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f41c0572000</span>)<br>	libgcc_s.so<span class="hljs-number">.1</span> =&gt; /lib64/libgcc_s.so<span class="hljs-number">.1</span> (<span class="hljs-number">0x00007f41c035c000</span>)<br>	libc.so<span class="hljs-number">.6</span> =&gt; /lib64/libc.so<span class="hljs-number">.6</span> (<span class="hljs-number">0x00007f41bff8e000</span>)<br>	/lib64/ld-linux-x86<span class="hljs-number">-64.</span>so<span class="hljs-number">.2</span> (<span class="hljs-number">0x00007f41c0b7c000</span>)<br></code></pre></td></tr></table></figure>
<p>链接静态库</p>
<p><code>TARGET_LINK_LIBRARIES(main libhello.a)</code></p>
<h3 id="特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH"><a href="#特殊的环境变量-CMAKE-INCLUDE-PATH-和-CMAKE-LIBRARY-PATH" class="headerlink" title="特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH"></a>特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH</h3><p>注意：这两个是环境变量而不是 cmake 变量，可以在linux的bash中进行设置</p>
<p>我们上面例子中使用了绝对路径INCLUDE_DIRECTORIES(/usr/include/hello)来指明include路径的位置</p>
<p>还可以使用另外一种方式，使用环境变量export CMAKE_INCLUDE_PATH=/usr/include/hello</p>
<p>补充：生产debug版本的方法：<br>cmake .. -DCMAKE_BUILD_TYPE=debug</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Cmake</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer Plus学习笔记7-13章</title>
    <url>/2023/07/21/c-primer-plus/</url>
    <content><![CDATA[<h3 id="第七章-函数-C-的编程模块"><a href="#第七章-函数-C-的编程模块" class="headerlink" title="第七章 函数-C++的编程模块"></a>第七章 函数-C++的编程模块</h3><p>函数的基本概念和应用：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">具体应用<br>按值传递，按地址传递<br>函数在数组中的应用<br>函数在结构体中的应用<br>函数在<span class="hljs-built_in">string</span>中的应用<br></code></pre></td></tr></table></figure>
<h4 id="1、使用C-函数三部曲"><a href="#1、使用C-函数三部曲" class="headerlink" title="1、使用C++函数三部曲"></a>1、使用C++函数三部曲</h4><p>提供函数定义：根据返回值来定义函数，在函数中用return返回（函数通过将返回值复制到指定的CPU寄存器或内存单元中将其返回）。</p>
<p>提供函数原型：函数原型描述了函数到编译器的接口，将函数的返回值的类型以及参数的类型和数量告诉编译器。</p>
<p>调用函数：传入实参调用函数。</p>
<h4 id="2、在函数中声明的变量"><a href="#2、在函数中声明的变量" class="headerlink" title="2、在函数中声明的变量"></a>2、在函数中声明的变量</h4><p>在函数中声明的变量包括参数都是该函数私有的，在函数调用时，计算机为这些变量分配内存，函数结束时，计算机将释放这些变量使用的内存。</p>
<h4 id="3、函数与数组"><a href="#3、函数与数组" class="headerlink" title="3、函数与数组"></a>3、函数与数组</h4><p>在将数组作为函数参数传递的时候，既可以用int arr[]，也可以用int * arr。</p>
<h4 id="4、指针和const"><a href="#4、指针和const" class="headerlink" title="4、指针和const"></a>4、指针和const</h4><p>常量指针和指针常量</p>
<p>方法1：让指针指向一个常量对象，防止该指针来修改所指向的值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 防止pt修改指向的值，但不能防止修改pt指针</span><br><span class="hljs-comment">// 可以使用age来修改自身的值</span><br><span class="hljs-built_in">int</span> age = <span class="hljs-number">18</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> * pt = &amp;age;<br></code></pre></td></tr></table></figure>
<ul>
<li>const 变量的地址可以赋给指向const的指针，但是不能赋值给常规指针。</li>
</ul>
<p>方法2：将指针本身声明为常量</p>
<h4 id="5、使用const的好处"><a href="#5、使用const的好处" class="headerlink" title="5、使用const的好处"></a>5、使用const的好处</h4><p>避免由于无意间修改数据而导致的编程错误。</p>
<p>使得函数能够处理const和非const实参，否则将只能接受非const数据。</p>
<p>例：在使用函数来对某一个数组进行显示时，可以在形参使用const修饰数组，以防止函数对原始数组的修改。</p>
<h3 id="第八章-函数探幽"><a href="#第八章-函数探幽" class="headerlink" title="第八章 函数探幽"></a>第八章 函数探幽</h3><p>函数更深的应用</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">内联函数<br></code></pre></td></tr></table></figure>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>常规函数和内联函数之间的区别在于C++编译器是如何将他们组合到程序中。对于常规函数的调用，会使用堆栈记录原始指令地址，随后跳转到目的函数中，执行结束后再返回原指令。对于内联函数的帝国用，编译器将使用相应的函数代码代替函数调用，在此过程并没有函数跳转调用的过程。</p>
<p>相比之下，内联函数少去了函数跳转的时间，使用空间换时间。</p>
<p>宏是通过文本替换来实现的。</p>
<h4 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h4><p>引用时已定义变量的一个别名。引用必须在声明的时候将其初始化。</p>
<p>引用作为参数传递可以使得被调用的函数访问调用函数中的变量。在传入参数中使用引用，就是为调用函数的变量新建了一个别名。</p>
<p>什么情况下会生产临时变量：</p>
<p>1、实参的类型正确，但不是左值</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">左值：可以取地址的，有名字的，非临时的变量就是左值<br>右值：无法直接取到地址，没有名字的，临时变量就是右值<br><br>新增右值引用的目的<br>实现移动语义<br></code></pre></td></tr></table></figure>
<p>2、实参类型不正确，但是可以转化为正确的类型</p>
<p>使用引用变量的场景</p>
<p>1、程序员能够修改调用函数中的数据对象</p>
<p>2、通过传递引用而不是整个数据对象，可以提高程序的运行速度</p>
<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>原来仅仅是返回类型不一样是不能用作函数重载的。重载必须满足的是特征标不同，即传入的参数不一致。</p>
<p>名称修饰：占位符</p>
<h4 id="函数模板：使用泛型来定义函数（通用编程）"><a href="#函数模板：使用泛型来定义函数（通用编程）" class="headerlink" title="函数模板：使用泛型来定义函数（通用编程）"></a>函数模板：使用泛型来定义函数（通用编程）</h4><blockquote>
<p>template <typename/class T>：定义模板以后使用模板定义数据</p>
</blockquote>
<p>当使用模板时，在调用模板函数的过程中，编译器会自动生成使用的模板类型的函数版本，但这一个过程对于程序员来说是透明的。</p>
<h4 id="显示具体化"><a href="#显示具体化" class="headerlink" title="显示具体化"></a>显示具体化</h4><p>在模板和具体化函数调用匹配产生冲突的时候，将优先使用具体化的函数进行匹配。</p>
<p>显式实例化：通过<type>在函数调用的时候显示的给出需要用到的模板类型，这样编译器在进行编译期间就不需要自己分析模板类型。</p>
<h4 id="编译器选择函数版本过程"><a href="#编译器选择函数版本过程" class="headerlink" title="编译器选择函数版本过程"></a>编译器选择函数版本过程</h4><p>1、创建候选函数列表</p>
<p>2、使用候选函数列表创建可行函数列表</p>
<p>3、确定是否有最佳可行函数</p>
<p>decltype：类型推导</p>
<blockquote>
<p>decltype(x+y) xpy = x + y</p>
<p>自动推导x+y的数据类型，并将其类型用于定义xpy，适合和模板进行共同使用。</p>
</blockquote>
<p>C++11后置返回类型：使用-&gt;将返回类型后置</p>
<p>sizeof和strlen之间的区别，指针变量是无法用sizeof统计出字符串长度的。</p>
<h3 id="第九章-内存模块与名称空间"><a href="#第九章-内存模块与名称空间" class="headerlink" title="第九章  内存模块与名称空间"></a>第九章  内存模块与名称空间</h3><h4 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h4><figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp">头文件包含内容<br><span class="hljs-number">1</span>、函数原型<br><span class="hljs-number">2</span>、使用<span class="hljs-meta">#<span class="hljs-keyword">define</span> 或 <span class="hljs-keyword">const</span>定义的符号常量</span><br><span class="hljs-number">3</span>、结构声明<br><span class="hljs-number">4</span>、类声明<br><span class="hljs-number">5</span>、模板声明<br><span class="hljs-number">6</span>、内联函数<br></code></pre></td></tr></table></figure>
<h4 id="存储持续性、作用域和链接性"><a href="#存储持续性、作用域和链接性" class="headerlink" title="存储持续性、作用域和链接性"></a>存储持续性、作用域和链接性</h4><p>数据存储方案</p>
<ul>
<li>自动存储持续性：函数参数，函数调用期间存在，函数执行结束释放</li>
<li>静态存储持续性：整个程序运行过程中都存在，static变量</li>
<li>线程存储持续性：生命周期和所属线程一样长</li>
<li>动态存储持续性：new存在，delete释放，用户管理。</li>
</ul>
<p>作用域：名称在文件中的可见范围</p>
<p>连接性：名称如何在不同单元中进行共享</p>
<p>C++中的auto：自动类型推导</p>
<p>变量只能定义一次，但可以多次应用，可以使用extern关键字对外部变量进行引用。</p>
<ul>
<li>说明符和限定符<ul>
<li>auto：自动类型推导</li>
<li>register：指示寄存器存储</li>
<li>static：用在作用域在整个文件的声明中时，表示内部链接性</li>
<li>extern：表明是引用声明，声明引用在其它地方的变量</li>
<li>thread_local：与线程的关系类似于静态变量于整个程序</li>
<li>mutable：可修改的const</li>
</ul>
</li>
<li>cv-限定符<ul>
<li>const</li>
<li>volatile：告诉编译器不要进行编译器优化，比如一个for循环计数</li>
</ul>
</li>
<li>mutable限定符<ul>
<li>即使为const也可以修改</li>
</ul>
</li>
</ul>
<p>内部链接性意味着每个文件都有自己的一组常量，而不是所有文件共享一组常量。</p>
<p>new定位运算符：能够指定要使用的位置，需要包含头文件new，</p>
<h4 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h4><p>声明区域：参数在其在进行中所在的区域。</p>
<p>潜在作用域：潜在作用域小于声明的区域。</p>
<p>名称空间可以是全局的，也可以位于另一个名称空间中，但不能够位于代码块中。默认情况下，在名称空间中声明的名称的链接性为外部的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">namespace</span> <span class="hljs-symbol">Jack</span>&#123;<br>	<span class="hljs-comment">//名称空间用到的变量和函数，类似于封装</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>using 和 using namespace：using可以使得某一个名称空间里面的函数或变量可用，using namespace 使得整个名称空间内的变量和函数都可用。</p>
<p>如果全局中含有某名称空间的同名的变量，引用该名称空间时将自动隐藏名称空间的该变量，而使用全局变量。</p>
<h3 id="第十章-对象和类"><a href="#第十章-对象和类" class="headerlink" title="第十章 对象和类"></a>第十章 对象和类</h3><p>面向对象的特性：抽象、封装和数据隐藏、多态、继承、代码的可重用性</p>
<h4 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h4><p>接口：接口是一个共享框架，供两个系统交互时使用。</p>
<p>访问控制字：public、private、protected，公有、私有、保护</p>
<p>结构体默认访问类型为public，类的默认访问类型为private</p>
<h4 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h4><blockquote>
<p>构造函数和析构函数都没有返回值类型</p>
</blockquote>
<p>构造函数</p>
<p>显示调用和隐式调用，每一个对象在创建的时候会自动调用构造函数，构造函数可以由用户给出，也可以使用默认的构造函数（不做任何操作）。</p>
<p>构造函数可以存在多个，能使用函数重载的方式来使用不同的构造函数。</p>
<p>析构函数</p>
<p>析构函数是在对象释放的时候自动调用的函数，用于释放新建的对象资源。</p>
<ul>
<li>C++11列表初始化方式</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Bozo</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * fname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> * lname);<br><br>Bozo bozette = &#123;<span class="hljs-string">&quot;Bozetta&quot;</span>, <span class="hljs-string">&quot;Biggens&quot;</span>&#125;;<br>Bozo fufu&#123;<span class="hljs-string">&quot;Fufu&quot;</span>, <span class="hljs-string">&quot;O&#x27;Dweeb&quot;</span>&#125;;<br>Bozo *pc = <span class="hljs-keyword">new</span> Bozo&#123;<span class="hljs-string">&quot;Popo&quot;</span>, <span class="hljs-string">&quot;Le Peu&quot;</span>&#125;;<br></code></pre></td></tr></table></figure>
<h4 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h4><p>this指针指向的是自身的地址，如果需要返回自身对象，需要使用*this，访问自身的成员也可以使用this-&gt;成员变量来进行访问。</p>
<h3 id="第十一章-使用类"><a href="#第十一章-使用类" class="headerlink" title="第十一章 使用类"></a>第十一章 使用类</h3><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><ul>
<li><p>不能重载的运算符</p>
<blockquote>
<p>sizeof、.（成员运算符）、.*(成员指针运算符)、::（作用域运算符）、?:（条件运算符）、typeid、const_cast、dynamic_cast、reinterpret_cast、static_cast</p>
</blockquote>
</li>
</ul>
<p>运算符重载是面向对象多态的一种表现，使用运算符重载能够使得编程更加灵活，例如实现两个对象相加，可以使用+运算符重载。</p>
<blockquote>
<p>operator运算符（）</p>
</blockquote>
<figure class="highlight excel"><table><tr><td class="code"><pre><code class="hljs excel">class <span class="hljs-built_in">Time</span>&#123;<br>	<span class="hljs-built_in">int</span> a;<br>	<span class="hljs-built_in">int</span> b;<br>publ<span class="hljs-symbol">ic:</span><br>	<span class="hljs-built_in">Time</span>(<span class="hljs-built_in">int</span> m_a, <span class="hljs-built_in">int</span> m_b)&#123;<br>		a = m_a;<br>		b = m_b;<br>	&#125;<br>	<br>	// 对 + 运算符进行重载<br>	<span class="hljs-built_in">Time</span> operator+(<span class="hljs-built_in">Time</span>&amp; <span class="hljs-symbol">t2</span>)&#123;<br>		<span class="hljs-built_in">Time</span> <span class="hljs-built_in">time</span>;<br>		time.a = a + <span class="hljs-symbol">t2</span>.a;<br>		time.b = b + <span class="hljs-symbol">t2</span>.b;<br>		return <span class="hljs-built_in">time</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元的三种类型：友元函数、友元类、友元成员函数。</p>
<p>将函数、类、成员函数设置为类的友元，可以赋予该函数与类的成员函数相同的访问权限。</p>
<ul>
<li><p>创建友元函数</p>
<p>将函数原型前面加上friend放在类声明中。</p>
<p>如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以使用友元函数来反转操作数的顺序。若不用友元函数访问，只能将一个参数传入到类的对象函数原型中，无法控制需要操作对象之间的顺序。</p>
</li>
</ul>
<blockquote>
<p>“&lt;&lt;” 运算符的重载</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 对&lt;&lt;运算符进行重载</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span> &#123;<br>	<span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Time&amp; t);<br>	<span class="hljs-type">int</span> hour;<br>	<span class="hljs-type">int</span> second;<br><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Time</span>(<span class="hljs-type">int</span> m_hour, <span class="hljs-type">int</span> m_second) &#123;<br>		hour = m_hour;<br>		second = m_second;<br>	&#125;<br>&#125;;<br><span class="hljs-comment">// 返回流对象，便于传递操作</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Time&amp; t) &#123;<br>	os &lt;&lt; t.hour &lt;&lt; <span class="hljs-string">&quot;   &quot;</span> &lt;&lt; t.second;<br>	<span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-function">Time <span class="hljs-title">time</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">40</span>)</span></span>;<br>	cout &lt;&lt; time &lt;&lt; endl;<br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;PAUSE&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>当重载的函数和目标对象不在一个作用域内时，需要使用域名控制符号来对其进行访问。</p>
<p>运算符重载，还可以更具特征标的数量不同再次进行重载。</p>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>构造函数可以使用隐式转换：隐式构造函数必须不能存在二义性</p>
<blockquote>
<p>在下面程序中，使用Stonewt st = 12;将默认隐式调用了构造函数Stonewt(double lbs)，对Stonewt的成员进行初始化。</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Stonewt</span> &#123;<br>	<span class="hljs-built_in">int</span> stone;<br>	<span class="hljs-built_in">double</span> pds;<br>	<span class="hljs-built_in">double</span> pounds;<br><br><span class="hljs-keyword">public</span>:<br>	Stonewt(<span class="hljs-built_in">double</span> lbs) &#123;<br>		stone = <span class="hljs-built_in">int</span>(lbs);<br>		pds = <span class="hljs-built_in">int</span>(lbs) % <span class="hljs-number">14</span> + lbs;<br>		pounds = lbs;<br>	&#125;<br>	Stonewt() &#123;<br>		stone = pds = pounds = <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123;<br>		cout &lt;&lt; stone &lt;&lt; endl;<br>		cout &lt;&lt; pds &lt;&lt; endl;<br>		cout &lt;&lt; pounds &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>	Stonewt st = <span class="hljs-number">12</span>;<br>	st.show();<br><br>	system(<span class="hljs-string">&quot;PAUSE&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果关闭隐式构造函数则使用：explicit Stonewt(double lbs);</p>
<h4 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h4><blockquote>
<p>格式：operator typename();</p>
<p>exp：operator double();</p>
</blockquote>
<p>如果在类里面定义了转化函数，可以将类强制转化成其它的数据类型。转化函数中返回需要进行转化的数据。</p>
<h3 id="第十二章-类的动态内存分配"><a href="#第十二章-类的动态内存分配" class="headerlink" title="第十二章  类的动态内存分配"></a>第十二章  类的动态内存分配</h3><h4 id="动态内存和类"><a href="#动态内存和类" class="headerlink" title="动态内存和类"></a>动态内存和类</h4><p>再动态分配内存中，对象的析构函数是必不可少的，有的时候必须要重载赋值运算符。</p>
<p>在类里面定义静态成员，意味着该类的所有对象能够共同享用这同一个静态成员变量。</p>
<p>将对象作为函数参数来传递而不是使用引用来传递，容易造成函数结束以后对象自动释放并调用析构函数的现象。</p>
<p>当使用一个对象初始化另一个对象的时候会调用拷贝构造函数。</p>
<ul>
<li><p>C++为一个对象自动提供的成员函数：</p>
<ul>
<li>默认构造函数：在对象创建时进行调用</li>
<li>默认析构函数：在对象销毁时调用</li>
<li><p>复制构造函数：用于将一个对象复制到新创建的对象中，默认复制构造函数用到的是浅拷贝。</p>
</li>
<li><p>赋值运算符重载：通常将一个对象使用等号赋值给另一个对象会用到，默认用的时浅拷贝</p>
</li>
<li>地址运算符重载</li>
<li>移动构造函数</li>
<li>移动赋值函数</li>
</ul>
</li>
<li><p>浅拷贝和深拷贝</p>
<p>在使用复制构造函数的过程中，默认进行的是浅拷贝，将一个对象的地址赋值给另一个需要初始化的对象。通过显性的修改复制构造函数的拷贝过程，可以实现深拷贝，即重新申请一块内存空间，将一个对象的数据放进去，让两个对象使用不同的两个地址空间。</p>
</li>
<li><p>C++11中引用nullptr表示空指针</p>
</li>
<li><p>可以将成员函数声明为静态的，声明过后</p>
<ul>
<li>不能通过对象调用静态成员函数，静态成员函数不能使用this指针</li>
<li>静态成员函数只能够使用静态数据成员</li>
</ul>
</li>
</ul>
<h4 id="使用new注意事项"><a href="#使用new注意事项" class="headerlink" title="使用new注意事项"></a>使用new注意事项</h4><ul>
<li>使用new后应该同样用delete进行释放</li>
<li>new和delete必须相互兼容，new对应于delete，new[]对应与delete[]</li>
<li>如果有多个构造函数，必须以相同的方式使用new</li>
<li>应定义一个复制构造函数，深拷贝一个对象初始化为另一个对象</li>
<li>应定义一个等号=运算符重载，通过深拷贝将一个对象赋值给另一个对象</li>
</ul>
<h4 id="有关返回对象的说明"><a href="#有关返回对象的说明" class="headerlink" title="有关返回对象的说明"></a>有关返回对象的说明</h4><ul>
<li><p>返回对象的引用、返回指向对象的const引用和返回const对象的区别</p>
<ul>
<li>1、返回对象将调用赋值构造函数，返回引用不会</li>
<li>2、引用指向的对象应该在调用函数执行时存在</li>
</ul>
</li>
<li><p>返回指向非const对象引用</p>
<blockquote>
<p>非const则说明可以对对象进行修改，具有传递性的操作必须返回非const对象引用</p>
</blockquote>
</li>
<li><p>当返回对象是被调用函数当中的局部变量，则不应该以引用来返回，而应该使用对象来返回，调用拷贝构造函数创建一个新的对象，比如算数运算符。</p>
</li>
</ul>
<p>若方法要返回局部对象，则应返回对象</p>
<p>若方法或函数要返回一个没有共有复制构造函数的类的对象，必须返回一个指向这种对象的引用</p>
<h3 id="第十三章-类继承"><a href="#第十三章-类继承" class="headerlink" title="第十三章  类继承"></a>第十三章  类继承</h3><p>通过继承可以完成的一些工作：</p>
<p>1、可以在已有类的基础上添加功能</p>
<p>2、可以给类添加数据</p>
<p>3、可以修改类的方法</p>
<p>总结，对于父类的一些功能的拓展。一般情况下会遵守开闭原则。</p>
<p>派生的类型：公有派生、私有派生、保护派生</p>
<p>公有派生：基类的公有成员称为派生类的公有成员。基类的私有部分称为派生类的一部分，但是只能够通过基类的公有和保护方法来进行访问。</p>
<p>父类指针指向子类对象， 通过这样的方式可以实现多态</p>
<p>基类指针可以在不进行显示类型转换的情况下指向派生类对象；</p>
<p>基类引用可以在不进行显示类型转化的情况下引用派生类对象；</p>
<h4 id="多态公有继承"><a href="#多态公有继承" class="headerlink" title="多态公有继承"></a>多态公有继承</h4><p>方法1、在派生类中重新定义基类的方法，通过在父类对象和子类对象中定义同样的方法，分别使用父类和子类对象的实例来调用来实现不同对象对同一对象接口调用达到多态。</p>
<p>方法2、使用虚方法，使用父类指针指向子类对象，在父类对象中使用虚函数，在子类对象中实现，通过一个父类指针指向子类对象来调用子类中的函数。</p>
<ul>
<li>虚析构函数的作用<ul>
<li>使用虚析构函数可以确保正确的析构函数序列被调用。</li>
</ul>
</li>
</ul>
<h4 id="动态联编和静态联编"><a href="#动态联编和静态联编" class="headerlink" title="动态联编和静态联编"></a>动态联编和静态联编</h4><p>将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编。</p>
<p>在编译过程中进行的联编称为静态联编。</p>
<p>在程序运行时进行的联编称为动态联编，有虚函数的代码需要在函数运行过程中才能够确认虚函数中具体要执行和完成的任务。</p>
<h4 id="虚函数的工作原理"><a href="#虚函数的工作原理" class="headerlink" title="虚函数的工作原理"></a>虚函数的工作原理</h4><p>编译器处理虚函数的方法是，为每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（vtbl）。虚函数表中存储了为类对象进行声明的虚函数的地址。</p>
<p>基类对象中包含一个指针，指向基类中所有虚函数表的地址表。派生类对象将包含一个指向对立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址，如果派生类没有定义虚函数，该虚函数表将保存函数原始版本的地址。</p>
<h4 id="访问控制：protected"><a href="#访问控制：protected" class="headerlink" title="访问控制：protected"></a>访问控制：protected</h4><p>派生类的成员可以直接访问基类的保护成员，但不能访问基类的私有成员，对于外部世界来说，保护成员的行为与私有成员相似，对于派生类来说，保护车关于的行为与公有成员相似。</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>C++可以通过纯虚函数提供未实现的函数，纯虚函数声明的结尾处为=0。</p>
<p>当类声明中包含纯虚函数时，则不能够创建该类的对象。因为需要通过继承的方式来实现纯虚函数中未定义的方法实现。</p>
<h4 id="继承和动态内存分配"><a href="#继承和动态内存分配" class="headerlink" title="继承和动态内存分配"></a>继承和动态内存分配</h4><p>1、如果在派生类中没有用到动态内存分配，则无需进行操作，析构函数也不需要修改。</p>
<p>2、如果派生类中有定义的指针需要动态分配内存的成员变量，则必须为派生类定义<strong>显式析构函数、复制（拷贝）构造函数和赋值（=重载）构造函数</strong>，在派生类的赋值构造函数和赋值构造函数中还必须显示的调用基类的构造函数。</p>
<p>在派生类中重定义基类的方法不是重载，将直接覆盖基类的原始方法。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>C++进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch使用方法</title>
    <url>/2023/03/02/pytorch-use/</url>
    <content><![CDATA[<h2 id="PyTorch基础语法"><a href="#PyTorch基础语法" class="headerlink" title="PyTorch基础语法"></a>PyTorch基础语法</h2><p>Pytorch是Facebook主导开发的，基于Python的科学计算包，主要有一下两个特点：</p>
<p>比NumPy更灵活，可以使用GPU的强大计算能力</p>
<p>开源高效的深度学习研究平台</p>
<ul>
<li><h3 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h3><blockquote>
<p>PyTorch中的Tensors可以使用GPU计算</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 可以返回填充了未初始化数据的张量</span><br>torch.empty(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 创建一个随机初始化矩阵</span><br>torch.rand(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 创建一个0填充的矩阵，指定数据类型为long：</span><br>torch.zeros(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, dtype=torch.long)<br><br><span class="hljs-comment"># 创建 Tensor 并使用现有数据初始化：</span><br>x = torch.tensor([<span class="hljs-number">5.5</span>, <span class="hljs-number">3</span>])<br>x<br><br><span class="hljs-comment">#根据现有张量创建新张量。这些方法将重用输入张量的属性，除非设置新的值进行覆盖</span><br>x = x.new_ones(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, dtype=torch.double)  <span class="hljs-comment"># new_* 方法来创建对象</span><br>x<br><br><span class="hljs-comment"># 覆盖 dtype，对象的 size 是相同的，只是值和类型发生了变化</span><br>x = torch.randn_like(x, dtype=torch.<span class="hljs-built_in">float</span>)<br>x<br><br><span class="hljs-comment"># 获得张量的size，返回值为tuple</span><br>x.size()<br></code></pre></td></tr></table></figure>
<ul>
<li><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#加法操作</span><br>y = torch.rand(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br>x + y<br><br>torch.add(x, y)<br><br><span class="hljs-comment"># 提供输出Tensor作为参数</span><br>result = torch.empty(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br>torch.add(x, y, out=result)<br>result<br><br><span class="hljs-comment"># 替换，将x加到y</span><br>y.add_(x)<br>y<br></code></pre></td></tr></table></figure>
<p>任何以下划线结尾的操作都会用结果替换原变量</p>
<p>可以使用与Numpy索引方式相同的操作来对张量进行操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># torch.view可以改变张量的维度和大小</span><br>x = torch.randn(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br>y = x.view(<span class="hljs-number">16</span>)<br>z = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)  <span class="hljs-comment"># size -1 从其他维度推断</span><br><br>x.size(), y.size(), z.size()<br><br><span class="hljs-comment"># 如果张量只有一个元素，使用 .item() 来得到 Python 数据类型的数值</span><br>x = torch.randn(<span class="hljs-number">1</span>)<br><br>x, x.item()<br></code></pre></td></tr></table></figure>
<blockquote>
<p>官方文档：<a href="https://pytorch.org/docs/stable/torch.html">torch — PyTorch 1.12 documentation</a></p>
</blockquote>
<ul>
<li><h3 id="NumPy转换"><a href="#NumPy转换" class="headerlink" title="NumPy转换"></a>NumPy转换</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># PyTorch张量转换为NumPy数组</span><br>a = torch.ones(<span class="hljs-number">5</span>)<br>a<br>b = a.numpy()<br>b<br><br><span class="hljs-comment"># 了解 NumPy 数组的值如何变化，a和b的数值都会加1</span><br>a.add_(<span class="hljs-number">1</span>)<br>a, b<br><br><span class="hljs-comment"># NumPy 数组转换成 PyTorch 张量时，可以使用 from_numpy 完成</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>a = np.ones(<span class="hljs-number">5</span>)<br>b = torch.from_numpy(a)<br>np.add(a, <span class="hljs-number">1</span>, out=a)<br>a, b<br></code></pre></td></tr></table></figure>
<p>所有的 Tensor 类型默认都是基于 CPU， CharTensor 类型不支持到 NumPy 的转换</p>
<ul>
<li><h3 id="CUDA张量"><a href="#CUDA张量" class="headerlink" title="CUDA张量"></a>CUDA张量</h3></li>
</ul>
<p>CUDA张量是能够再GPU设备在运算的张量。使用.to方法可以将Tensor移动到GPU设备中去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># is_available 函数判断是否有 GPU 可以使用</span><br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>)          <span class="hljs-comment"># torch.device 将张量移动到指定的设备中</span><br>    y = torch.ones_like(x, device=device)  <span class="hljs-comment"># 直接从 GPU 创建张量</span><br>    x = x.to(device)                       <span class="hljs-comment"># 或者直接使用 .to(&quot;cuda&quot;) 将张量移动到 cuda 中</span><br>    z = x + y<br>    <span class="hljs-built_in">print</span>(z)<br>    <span class="hljs-built_in">print</span>(z.to(<span class="hljs-string">&quot;cpu&quot;</span>, torch.double))       <span class="hljs-comment"># .to 也会对变量的类型做更改</span><br></code></pre></td></tr></table></figure>
<h2 id="Autograd自动求导"><a href="#Autograd自动求导" class="headerlink" title="Autograd自动求导"></a>Autograd自动求导</h2><blockquote>
<p>PyTorch中所有神经网络的核心是autograd</p>
</blockquote>
<p><code>autograd</code>为张量上的所有操作提供了自动求导。它是一个在运行时定义的框架，这意味着反向传播是根据你的代码来确定如何运行。</p>
<p><code>torch.Tensor</code> 是这个包的核心类。如果设置<code>.requires_grad</code>为<code>True</code>，那么将会追踪所有对于该张量的操作。当完成计算后通过调用<code>.backward()</code>会自动计算所有的梯度，这个张量的所有梯度将自动积累到<code>.grad</code>属性。这也就完成了自动求导的过程。</p>
<p>要组织张量追踪历史记录，可以调用<code>.detach()</code>方法将其与计算历史记录分离。为了防止跟踪历史记录（和使用内存），可以将代码块包装在<code>with tirch.no_grad():</code>语句中。这一点在评估模型时特别有用，因为模型可能具有<code>requires_grad=True</code>的可训练参数，但是并不需要计算梯度。</p>
<p>自动求导还有另一个重要的类<code>Function</code>。<code>Tensor</code>和<code>Function</code>互相连接并生成一个非循环图，存储了完整的计算历史。</p>
<p>如果需要计算导数，可以在<code>Tensor</code>上调用<code>.backward()</code>。如果<code>Tensor</code>是一个标量（即它只包含一个元素数据）则不需要为<code>backward()</code>指定任何参数。但是如果他又多个元素，则需要指定一个<code>gradient</code>参数来匹配张量的形状。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个张量并设置 requires_grad=True 用来追踪他的计算历史</span><br>x = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, requires_grad=<span class="hljs-literal">True</span>)<br>x<br><br><span class="hljs-comment"># 对张量进行操作，也就是计算过程</span><br>y = x + <span class="hljs-number">2</span><br>y<br><br><span class="hljs-comment"># 结果 y 已经被计算出来了，所以，grad_fn 已经被自动生成了</span><br>y.grad_fn<br><br><span class="hljs-comment"># 然后，再对 y 进行操作</span><br>z = y * y * <span class="hljs-number">3</span><br>out = z.mean()<br><br>z, out<br><br><span class="hljs-comment"># .requires_grad_( ... ) 可以改变现有张量的 requires_grad 属性。 如果没有指定的话，默认输入的 flag 是 False</span><br>a = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>a = ((a * <span class="hljs-number">3</span>) / (a - <span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(a.requires_grad)<br>a.requires_grad_(<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(a.requires_grad)<br>b = (a * a).<span class="hljs-built_in">sum</span>()<br><span class="hljs-built_in">print</span>(b.grad_fn)<br></code></pre></td></tr></table></figure>
<ul>
<li><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3></li>
</ul>
<p>通过反向传播打印对应结点的梯度，因为<code>out</code>是一个纯量Scalar，<code>out.backward()</code>等于<code>out.backward(torch.tensor(1))</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">out.backward()<br><br><span class="hljs-comment"># 打印其梯度</span><br>x.grad<br></code></pre></td></tr></table></figure>
<p>关于Autograd的更多操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">x = torch.randn(<span class="hljs-number">3</span>, requires_grad=<span class="hljs-literal">True</span>)<br><br>y = x * <span class="hljs-number">2</span><br><span class="hljs-keyword">while</span> y.data.norm() &lt; <span class="hljs-number">1000</span>:<br>    y = y * <span class="hljs-number">2</span><br><br>y<br><br>gradients = torch.tensor([<span class="hljs-number">0.1</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0001</span>], dtype=torch.<span class="hljs-built_in">float</span>)<br>y.backward(gradients)<br><br>x.grad<br><br><span class="hljs-comment"># 如果 .requires_grad=True 但是你又不希望进行 Autograd 的计算，那么可以将变量包裹在 with torch.no_grad() 中</span><br><span class="hljs-built_in">print</span>(x.requires_grad)<br><span class="hljs-built_in">print</span>((x ** <span class="hljs-number">2</span>).requires_grad)<br><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-built_in">print</span>((x ** <span class="hljs-number">2</span>).requires_grad)<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>autograd</code>和<code>Function</code>的官方文档：<a href="https://pytorch.org/docs/stable/autograd.html">Automatic differentiation package - torch.autograd — PyTorch 1.12 documentation</a></p>
</blockquote>
<h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>PyTorch中，我们可以使用<code>torch.nn</code>来构建神经网络</p>
<p><code>torch.nn</code>依赖<code>autograd</code>来定义模型并求导。<code>nn.Module</code>中包含了构建神经网络所需的各个层和<code>forward(input)</code>方法，该方法返回神经网络的输出。</p>
<p>​    神经网络的典型训练过程如下</p>
<p>1、定义包含可学习参数（权重）的神经网络模型</p>
<p>2、在数据集上迭代</p>
<p>3、通过神经网络处理输入</p>
<p>4、计算损失</p>
<p>5、将梯度反向传播回网络结点</p>
<p>6、更新网络的参数，一般可以使用梯度下降等最优化方法</p>
<p>​    PyTorch的<code>nn.Conv2d()</code>详解，该类作为二维卷积的实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">in_channels		<span class="hljs-comment"># 输入张量的channels数</span><br>out_channels	<span class="hljs-comment"># 期望的四维输出张量的channels数</span><br>kernel_size		<span class="hljs-comment"># 卷积核的大小，一般用5×5、3×3</span><br>stride=<span class="hljs-number">1</span>		<span class="hljs-comment"># 卷积核在图像窗口上每次平移的间隔，步长</span><br>padding=<span class="hljs-number">0</span>		<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
        <tag>PyTorch</tag>
        <tag>AI</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统学习笔记</title>
    <url>/2023/03/02/distributed-system/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="分布式系统的定义"><a href="#分布式系统的定义" class="headerlink" title="分布式系统的定义"></a>分布式系统的定义</h3><blockquote>
<p>分布式系统是若干独立计算机的集合，这些计算机对于用户来说，像是单个相关系统</p>
</blockquote>
<ul>
<li>重要特性<ul>
<li>各种计算机之间的差别以及计算机之间的通信方式的差别对用户是隐藏的</li>
<li>用户看不到分布式系统的内部组织结构</li>
<li>用户和应用程序无论在何时何地都能够以一种一致和同意的方式与分布式系统进行交互</li>
<li>分布式系统的拓展或者升级应该时相对比较容易的</li>
</ul>
</li>
</ul>
<h3 id="分布式系统的目标"><a href="#分布式系统的目标" class="headerlink" title="分布式系统的目标"></a>分布式系统的目标</h3><ul>
<li>使资源可访问（资源共享）</li>
<li>透明性</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221126155708747.png" class="" title="image-20221126155708747">
<img src="/2023/03/02/distributed-system/image-20221126155754925.png" class="" title="image-20221126155754925">
<ul>
<li><p>开放性（openess）</p>
<blockquote>
<p>根据一系列准则来提供服务，这些准则描述了所提供服务的语义和语法。</p>
<p>在分布式系统中，服务通常时通过接口指定的，接口时通过接口定义语言来描述的。</p>
<p>开放的分布式系统应该时可扩展的。</p>
</blockquote>
<ul>
<li>完整性：完成接口实现不可少的内容都已经规定好了</li>
<li>中立性：开发人员能够添加针对特定实现的细节</li>
<li>互操作性：来自不同厂商的系统或组件的两种实现能够在何种程度上共存并且协同工作</li>
<li>可移植性：如果分布式系统A开发了某个应用，并且另一个分布式系统B与A具有相同的接口，该程序在不做修改在B上执行的可行程度</li>
</ul>
</li>
<li><p>可扩展性（scale in distributed system）scalablity</p>
<blockquote>
<p>可扩展性通常可以从三个方面来度量，规模上可扩展（size）、地域上可扩展（geographical）、管理上可扩展（administrative）</p>
</blockquote>
<ul>
<li><p>规模上可拓展存在的问题</p>
<ul>
<li>受集中式的服务、数据以及算法限制</li>
<li>集中式算法与分布式算法的对比</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">分布式算法不同特性<br>1、没有任何计算机拥有关于系统状态的完整信息<br>2、计算机只根据本地信息做出决策<br>3、某台计算机的故障不会使算法奔溃<br>4、没有全局性时钟，来统一设定时间<br></code></pre></td></tr></table></figure>
</li>
<li><p>地域上可扩展存在的问题</p>
<ul>
<li>基于同步的通信，在请求服务的一方得到回应之前都是处于阻塞状态，在局域网中速度快，广域网中很慢</li>
<li>广域网中的通信是不可靠的，都是点对点的</li>
<li>如何对一个跨越多个独立管理域的分布式系统进行拓展</li>
</ul>
</li>
<li><p>管理上可扩展存在的问题</p>
<ul>
<li>资源使用（以及付费）、管理和安全问题上，不同的管理域之间有着相互冲突的问题</li>
</ul>
</li>
<li><p>拓展技术</p>
<blockquote>
<p>拓展技术基本上只有三种技术：隐藏通信等待时间、分布技术以及复制技术</p>
</blockquote>
<ul>
<li>隐藏通信等待时间：尽量避免远程服务对请求的响应，实质上是异步通信。也可以将服务器上的部分任务交由客户端完成。</li>
<li>分布技术： 把某个组件分割成多个部分，再将他们分散到系统中，如DNS。</li>
<li>复制技术：会产生一致性问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分布式系统的类型"><a href="#分布式系统的类型" class="headerlink" title="分布式系统的类型"></a>分布式系统的类型</h3><blockquote>
<p>分布式计算系统、分布式信息系统、分布式嵌入系统</p>
</blockquote>
<ul>
<li><p>分布式计算系统（高性能的分布式系统）</p>
<ul>
<li><p>集群计算系统</p>
<blockquote>
<p>同构性：集群中的计算机大多数是相同的。相同的操作系统，同一网络。</p>
</blockquote>
<ul>
<li>单个主节点，多个从节点，主节点可访问控制群（从节点）</li>
<li>主节点：负责对特定并行程序的结点定位，维护已经提交的工作队列，为系统用户提供接口</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221130091729650.png" class="" title="image-20221130091729650">
</li>
<li><p>网格计算系统</p>
<blockquote>
<p>具有高度的异构性：硬件，操作系统，网络，管理域和安全策略都不尽相同</p>
</blockquote>
<ul>
<li>解决异构性的方式：虚拟组织</li>
<li>光纤层：在特定站点提供对局部资源的接口</li>
<li>连接层：由通信协议组成，用于支持网格事务处理</li>
<li>资源层：负责管理单个资源</li>
<li>汇集层：负责处理对多个资源的访问</li>
<li>应用层：由应用程序组成，在虚拟组织中运行</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221130092344725.png" class="" title="image-20221130092344725">
</li>
</ul>
</li>
<li><p>分布式信息系统</p>
</li>
<li><p>分布式普适系统</p>
</li>
</ul>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="体系结构的样式"><a href="#体系结构的样式" class="headerlink" title="体系结构的样式"></a>体系结构的样式</h3><blockquote>
<p>体系结构样式是根据组件，组件之间互相连接方式、组件之间的数据交换以及这些元素如何集成到一个系统中来定义的。</p>
</blockquote>
<ul>
<li><p>分层体系结构</p>
</li>
<li><p>基于对象的体系结构</p>
<ul>
<li>每个对象对应一个组件，组件通过远程过程调用机制来连接</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221130094553260.png" class="" title="image-20221130094553260">
</li>
<li><p>以数据为中心的体系结构</p>
<ul>
<li>进程通信需要通过一个公用仓库</li>
</ul>
</li>
<li><p>基于事件的体系结构</p>
<ul>
<li>进程发布事件，中间件确保订阅了这些事件的进程接收它们。去耦合强。</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221130101949954.png" class="" title="image-20221130101949954">
</li>
</ul>
<h3 id="系统体系结构"><a href="#系统体系结构" class="headerlink" title="系统体系结构"></a>系统体系结构</h3><ul>
<li><p>集中式体系结构（客户—服务器）</p>
<ul>
<li><p>应用分层</p>
<ul>
<li>应用层：提供与用户交互的接口</li>
<li>处理层：处理用户的请求，实现与数据的交互</li>
<li>数据层：存储数据，如，文件系统，数据库</li>
</ul>
</li>
<li><p>多层体系结构</p>
<ul>
<li>两层体系结构：客户机和服务器<ul>
<li>根据将客户机和服务器实现的不同功能可以分为以下5种，d和e较为普遍</li>
</ul>
</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221130101048848.png" class="" title="image-20221130101048848">
<ul>
<li><p>三层体系结构：用户接口、应用程序服务器、数据库服务器</p>
<img src="/2023/03/02/distributed-system/image-20221130102217372.png" class="" title="image-20221130102217372">
</li>
</ul>
</li>
</ul>
</li>
<li><p>非集中式体系结构（回头听一听课）点对点</p>
<p>垂直分布性（分层）：按逻辑把不同组件放在不同机器上</p>
<p>水平分布性：客户和服务器可能在物理上被分割成逻辑上相等的几个部分，但每个部分都操作在整个数据集中自己共享的部分，从而实现负载均衡。例如点对点系统</p>
<ul>
<li><p>结构化的点对点体系结构</p>
<ul>
<li>Chord系统分布式哈希表（后面章节）理解加入和退出</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221130140722941.png" class="" title="image-20221130140722941">
<ul>
<li>CAN：上下文可编制网络（后面章节）</li>
</ul>
</li>
<li><p>非结构化点对点体系结构</p>
<blockquote>
<p>主要依靠随机化算法来构造覆盖网络，每个节点维护一个邻接点列表，列表由随机的方法来构造。使用泛洪法来查找。</p>
</blockquote>
</li>
<li><p>覆盖网络的拓扑管理</p>
</li>
<li><p>超级对等体</p>
</li>
</ul>
</li>
<li><p>混合体系结构</p>
<blockquote>
<p>特殊的分布式系统，将客户服务器体系结构和非集中式体系结构组合在一起</p>
</blockquote>
<ul>
<li><p>边界服务器系统</p>
</li>
<li><p>协作分布式系统</p>
<ul>
<li><p>文件共享系统</p>
<blockquote>
<p>是一种点对点的文件下载系统，一个用户从其他用户下载文件块，知道所下载的文件块能够组装成完整的文件。一旦结点确定了从哪里可以下载文件块，下载结点将被强制为其他节点提供帮助。瓶颈期在于跟踪器。</p>
</blockquote>
</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221130143607842.png" class="" title="image-20221130143607842">
<ul>
<li>协作内容分布式网络Globule</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="体系结构与中间件"><a href="#体系结构与中间件" class="headerlink" title="体系结构与中间件"></a>体系结构与中间件</h3><blockquote>
<p>中间件具有一定程度的透明性，一定程度上向应用程序隐藏了数据处理和控制的分布性</p>
</blockquote>
<ul>
<li><p>中断器</p>
<blockquote>
<p>是一种软件结构，能中断正常的控制流，从而允许其他代码运行。</p>
</blockquote>
<ul>
<li>请求级中断器：为每个副本调用invoke函数</li>
<li>消息级中断器：协助把消息传递接口激活转移给目标对象</li>
</ul>
</li>
<li><p>自适应软件常见方法（基本技术）</p>
<ul>
<li>要点分离</li>
<li>计算映像：程序检查自己</li>
<li>基于组件的设计：通过组件的不同组合来支持自适应</li>
</ul>
</li>
</ul>
<h3 id="分布式系统的自我管理"><a href="#分布式系统的自我管理" class="headerlink" title="分布式系统的自我管理"></a>分布式系统的自我管理</h3><blockquote>
<p>以高级反馈控制系统的形式来组织分布式系统，允许自动自适应变化。称为自治计算或自主系统。</p>
</blockquote>
<p>自适应的多样性：自我管理、自我恢复、自我配置、自我优化</p>
<ul>
<li><p>反馈控制模型：通过反馈控制循环实现</p>
<ul>
<li>形成反馈控制循环的三个元素<ul>
<li>系统本身需要被监视：对系统的各个方面进行测量（尺度预测组件）</li>
<li>分析上述测量值：控制循环的核心部分，包含决定自适应的算法（反馈分析组件）</li>
<li>其他组件</li>
</ul>
</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221130151005907.png" class="" title="image-20221130151005907">
</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote>
<p>就粒度而言，将每个进程细分为若干控制线程的形式更加合适，可以使构建分布式应用程序变得更加方便，并可获得更好的性能。</p>
</blockquote>
<ul>
<li><p>线程简介</p>
<blockquote>
<p>线程上下文中一般值包含CPU上下文以及某些其他线程管理信息。</p>
</blockquote>
<ul>
<li><p>非分布式系统中线程用法，好处</p>
<ul>
<li>多线程的系统中，线程阻塞不会造成进程阻塞</li>
<li>在多处理系统上执行多线程程序时，可以使用并行操作技术</li>
<li>线程之间的上下文切换小</li>
</ul>
</li>
<li><p>线程的实现</p>
<blockquote>
<p>一般以线程包的形式提供，这种包中含有创建和销毁线程的操作。分为用户及线程和内核级线程。</p>
</blockquote>
<ul>
<li>用户级线程的好处<ul>
<li>创建和销毁线程开销小</li>
<li>可以通过为数不多的几条指令实现线程上下文切换</li>
</ul>
</li>
<li>用户及线程的缺陷<ul>
<li>对引起阻塞的系统调用的调用将会立即阻塞该线程所属的整个进程</li>
</ul>
</li>
<li>轻量级进程：使用用户及线程和内核级线程的混合形式</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式系统中的线程</p>
<ul>
<li><p>多线程客户</p>
<blockquote>
<p>隐藏通信事件延迟的方法：启动通信后立即进行其他工作</p>
</blockquote>
<ul>
<li>web浏览器显示HTML页面</li>
</ul>
</li>
<li><p>多线程服务器</p>
<ul>
<li>能够保留顺序处理的思路，使用阻塞性的系统调用，并且仍能够达到并行处理的目的</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221201100317779.png" class="" title="image-20221201100317779">
<p>分发器线程：读取文件操作请求</p>
<p>工作者线程：处理请求</p>
</li>
</ul>
</li>
</ul>
<h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><blockquote>
<p>虚拟化的本质是拓展或替换一个现存界面来模仿另一个系统的行为。</p>
</blockquote>
<ul>
<li><p>虚拟化在分布式系统中的作用</p>
<ul>
<li>旧有软件的维护，跟不上下层平台更新的步伐，硬件更新速度太快，需要软件兼容。通过移植旧有软件的底层接口到新平台，虚拟化可以帮助解决这个问题</li>
<li>虚拟化便于减少服务器和硬件机器的种类和数目，提供了高度的移植性和灵活性</li>
</ul>
</li>
<li><p>虚拟机体系结构</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss">在四个不同层次提供四个不同界面<br>由机器指令组成，可由任何程序激起的硬件软件界面<br>由机器指令组成，只有特权程序才可激起的硬件软件界面<br>由操作系统提供的系统调用（<span class="hljs-keyword">system</span> <span class="hljs-keyword">call</span>）组成的界面<br>由库调用组成的界面，通常形成了所谓的应用程序编程接口（API）<br></code></pre></td></tr></table></figure>
<img src="/2023/03/02/distributed-system/image-20221201101403269.png" class="" title="image-20221201101403269">
</li>
</ul>
<ul>
<li><p>虚拟化的两种方式</p>
<img src="/2023/03/02/distributed-system/image-20221201101451311.png" class="" title="image-20221201101451311">
<ul>
<li>构建一个运行时的系统，提供一套抽象指令集来执行程序（进程虚拟机）</li>
<li>提供一种系统，如VMware（虚拟机监视器）</li>
</ul>
</li>
</ul>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul>
<li><p>客户端软件与分布式透明性</p>
<blockquote>
<p>理论上来说，客户端不应该察觉到它与远程进程的通信，而服务器来说，分布常常不那么透明</p>
</blockquote>
<ul>
<li><p>许多分布式系统利用客户端解决方案来实现复制透明性</p>
<ul>
<li>调用请求转发给每一个服务器发送副本来达到复制透明性</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221201110722218.png" class="" title="image-20221201110722218">
</li>
<li><p>故障透明性，一般是通过客户中间件完成</p>
</li>
</ul>
</li>
</ul>
<h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><ul>
<li><p>常见的设计问题</p>
<blockquote>
<p>服务器的组织方式：等待来自客户的请求，随后负责处理该请求，等待下一个请求</p>
</blockquote>
<p>服务器的不同组织结构</p>
<ul>
<li><p>迭代服务器：自己处理请求，并且在必要的情况下将响应返回给发出请求的客户</p>
</li>
<li><p>并发服务器：并不自己处理请求，而是将请求传递给某个独立线程或其他进程来处理，只用于等待请求。如：多线程服务器。</p>
</li>
<li><p>超级服务器：用于负责监听所有与服务关联的端口，缓解了每一个服务器都要对端口监听的浪费。</p>
<img src="/2023/03/02/distributed-system/image-20221201111903470.png" class="" title="image-20221201111903470">
</li>
<li><p>状态无关服务器：不保存客户的状态信息且不将自身状态告知客户</p>
<ul>
<li>好处<ul>
<li>不需要采取任何特殊措施来使得奔溃的服务器恢复，重启即可</li>
</ul>
</li>
</ul>
</li>
<li><p>状态相关服务器：一直保存客户端的信息直到显式的删除</p>
<ul>
<li>好处：<ul>
<li>性能能够提升</li>
</ul>
</li>
<li>缺陷：<ul>
<li>如果服务器崩溃，就必须恢复客户端的状态表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>服务器集群</p>
<blockquote>
<p>服务器集群式一组经网络连接的机器，每台机器运行一个或多个服务器</p>
</blockquote>
<ul>
<li><p>常见的组织</p>
<ul>
<li><p>多数情况下逻辑上由三层组成</p>
<img src="/2023/03/02/distributed-system/image-20221201151303341.png" class="" title="image-20221201151303341">
<ul>
<li><p>（逻辑上的）交换机：分配客户请求给服务器</p>
<ul>
<li>作为服务器集群的入口，提供唯一的网络地址</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221201152139305.png" class="" title="image-20221201152139305">
<ul>
<li>交换机收到tcp连接请求，将请求分发给最佳服务器，服务器发送应答信号，并嵌入交换器的IP</li>
</ul>
</li>
<li><p>专用的应用/计算处理服务器：提供高性能计算能力</p>
</li>
<li><p>文件和数据库服务器（数据存取是瓶颈）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>分布式服务器</p>
<blockquote>
<p>分布式服务器是指可动态变化的集群，它的访问点也可以变化，但对外却表现为一台强有力的单台机器。</p>
</blockquote>
<ul>
<li>基本思想：可靠、高性能、稳定</li>
<li>如何实现一个稳定访问点<ul>
<li>使用宿主代理（宿主网络的特别的路由器）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>管理服务器集群的方法</p>
<ul>
<li>通用方法<ul>
<li>把传统的单台计算机管理功能拓展到服务器集群，从远程客户登录到集群的一个节点并执行本地管理命令</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="代码迁移"><a href="#代码迁移" class="headerlink" title="代码迁移"></a>代码迁移</h3><blockquote>
<p>传递程序，甚至传递正在执行中的程序。</p>
</blockquote>
<ul>
<li><p>代码迁移方案</p>
<blockquote>
<p>代码迁移是以进程迁移的形式进行的，代码迁移会带来巨大的开销</p>
</blockquote>
<ul>
<li><p>进行代码迁移的好处</p>
<ul>
<li>如果把进程由负载较重的机器上转移负载较轻的机器上，能提升系统的整体性能</li>
<li>灵活性，如果代码可以在不同的机器之间移动，就可以动态的配置分布式系统</li>
</ul>
</li>
<li><p>代码迁移模型</p>
<p>进程包含3段：代码段（包含正在运行程序的所有指令），资源段（包含外部资源的指针），执行段（存储进程当前状态）</p>
<ul>
<li>弱可移动性：只传输代码段以及初始化数据<ul>
<li>传输的程序总是从预先定义的位置开始执行。较简单</li>
</ul>
</li>
<li>强可移动性：可以传输执行段<ul>
<li>可以先停止运行中的进程，然后将它移到另一台机器上去，再从中断的位置继续执行</li>
</ul>
</li>
</ul>
<p>另一种分类方式</p>
<ul>
<li>发送者启动迁移：由正在执行该代码的机器启动迁移</li>
<li>接收者启动迁移：代码迁移主动权掌握在目标机器手里</li>
</ul>
<img src="/2023/03/02/distributed-system/image-20221201160233164.png" class="" title="image-20221201160233164">
</li>
</ul>
</li>
</ul>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><blockquote>
<p>四个广泛使用的通信模型：远程过程调用（RPC，remote procedure call）、远程方法调用（RMI，remote method invocation）、面向消息的中间件（MOM，message-oriented middleware）、流（stream）</p>
<p>RPC的目的在于将消息传递的大部分复杂性隐藏起来，比较适合客户-服务器应用程序。</p>
</blockquote>
<ul>
<li><p>基础知识</p>
<ul>
<li>分层协议<ul>
<li>OSI七层模型：略</li>
<li>中间件协议：中间件是一种应用程序，位于应用层中</li>
</ul>
</li>
<li>通信类型<ul>
<li>持久通信：提交传输的消息一直由通信中间件存储，直到消息被传送给接收方</li>
<li>瞬时通信：通信系统只有在发送和接受应用程序正在运行时才能存储消息</li>
<li>异步通信（asynchronous）：发送方在提交要传输的消息后立即往下进行</li>
<li>同步通信（synchronous）：发送方将被阻塞，直到其请求被接受</li>
</ul>
</li>
</ul>
</li>
<li><p>远程过程调用</p>
<blockquote>
<p>当机器A上的进程调用机器B上的进程是，A上的调用进程被挂起，而B上的被调用的进程开始执行，调用方可以通过使用参数将信息传给被调用放，然后通过传回的结果得到信息。编程人员看不到任何消息传递过程，这种方法称为远程过程调用</p>
</blockquote>
<p>复杂性：地址空间不同、参数和结果的传递、机器如果发生崩溃</p>
<ul>
<li>基本的RPC操作</li>
</ul>
</li>
</ul>
<h2 id="命名系统-Naming"><a href="#命名系统-Naming" class="headerlink" title="命名系统 - Naming"></a>命名系统 - Naming</h2><blockquote>
<p>命名是在分布式中表示这个实体，且要访问到这个实体。</p>
</blockquote>
<ul>
<li>访问点：用来实体的一种特殊实体。</li>
<li>地址：访问点的名称。</li>
</ul>
<p>所以<strong>访问点</strong>就是实体的<strong>地址</strong>。</p>
<h3 id="DHT"><a href="#DHT" class="headerlink" title="DHT"></a>DHT</h3><p>全称是Distributed Hash Tables，是P2P环境下最经典的解决方案</p>
<h3 id="Chord"><a href="#Chord" class="headerlink" title="Chord"></a>Chord</h3><p>使用一个m位的标识符空间，把<strong>随机选择</strong>的标识符赋给结点，并把键值赋值给特定实体（任意的东西，比如文件、进程）。</p>
<p><strong>构造Finger table算法：</strong></p>
<p>每个Chord结点维护一个最多有m个实体的指状表(Finger table)，如果用$FT_p[i]$表示结点$p$的指状表，那么有：</p>
<script type="math/tex; mode=display">
FT_p[i] = succ(p+2^{(i-1)})</script><p>$-p$是当前结点$-i$是指状表的$index-succ(k)$表示k（若结点k存在）或k的下一个<strong>存在</strong>的结点，即$succ(k)&gt;=k$</p>
<p>例：</p>
<img src="/2023/03/02/distributed-system/image-20240302163915592.png" class="" title="image-20240302163915592">
<p>根据$FT_p[i] = succ(p+2^{(i-1)})$公式，构造结点p=4的Finger table：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">i</th>
<th style="text-align:center">$FT_p[i]$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">succ(4+1)=9</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">succ(4+2)=9</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">succ(4+4)=9</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">succ(4+8)=14</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">succ(4+16)=20</td>
</tr>
</tbody>
</table>
</div>
<p><strong>解析算法：</strong></p>
<p>目标：从节点p开始解析key=k的结点</p>
<p>搜索节点p的Finger table，从上依次向下搜索，如果一个结点q满足：</p>
<script type="math/tex; mode=display">
q=FT_p[j]<=k<FT_p[j+1]</script><p>那么就将该请求转发给结点q；</p>
<p>如果p的Finger table第一个结点就比k还大，即：</p>
<script type="math/tex; mode=display">
p<k<FT_p[1]</script><p>那么就转发给$FT_p[1]$结点，此节点负责结点k，将k的地址返回给结点p。</p>
<p><strong>例：</strong></p>
<p>还是上面那个图</p>
<p>从结点1开始解析k=26：</p>
<ol>
<li>结点1的指状表里，$FT_1[5]$=18≤26，将请求转发给18；</li>
<li>结点18的指状表里，$FT_{18}[2]$=20≤26&lt;$FT_{18}[3]$=28，将请求转发给20；</li>
<li>结点20的指状表里，$FT_{20}[1]$=21≤26&lt;$FT_{20}[2]$=28，将请求转发给21；</li>
<li>结点21的指状表里，21&lt;26&lt;$FT_{21}[1]$=28，将请求转发给28，该结点负责解析k=26；</li>
</ol>
<p>从结点28开始解析k=12：</p>
<ol>
<li>结点28的指状表里，$FT_{28}[4]$=4≤12&lt;$FT_{28}[5]$=14，将请求转发给4；</li>
<li>结点4的指状表里，$FT_{4}[4]$=9≤12&lt;$FT_{4}[4]$=14，将请求转发给9；</li>
<li>结点9的指状表里，$FT_{9}[2]$=11≤12&lt;$FT_{9}[3]$=14，将请求转发给11；</li>
<li>结点11的指状表里，11&lt;12&lt;$FT_{11}[1]$=14，将请求转发给14，该结点负责解析k=12；</li>
</ol>
<h3 id="HLS"><a href="#HLS" class="headerlink" title="HLS"></a>HLS</h3><p>网络被划分为一组域。每个域D都有关联的目录节点dir(D)，dir(D)会跟踪域中的实体，形成一颗目录结点树。</p>
<h3 id="HLS结构"><a href="#HLS结构" class="headerlink" title="HLS结构"></a>HLS结构</h3><p>看下面这个图来解释一下HLS吧：</p>
<img src="/2023/03/02/distributed-system/image-20240302165702511.png" class="" title="image-20240302165702511">
<p>为了跟踪实体E的位置，实体E位于域S中，所以域S的目录结点N含有E在该域中的位置信息。</p>
<p>而在比域S更高一级的域T中，域T的目录结点N’也有实体E的位置信息，但是这个位置信息只有N的指针，也就是要找实体E，就先去找到其子域的目录结点N，然后通过目录节点N找到E。</p>
<p>同理，在比域T更大的域中，那个域的目录节点也有实体E的位置信息，不过这个位置信息只有N’的指针，要找实体E，就要先找N’，然后找到N，最后找到E。</p>
<p>所以顶级域的目录结点，即根（目录）节点，包括全部实体位置信息。</p>
<h3 id="如果一个实体有多个地址"><a href="#如果一个实体有多个地址" class="headerlink" title="如果一个实体有多个地址"></a>如果一个实体有多个地址</h3><p>实体可以拥有多个地址，比如被复制了，实体在域D1和域D2中都有地址，那么同时包含D1和D2的最小域目录结点将有两个指针，每个指针都指向一个包含地址的子域。</p>
<img src="/2023/03/02/distributed-system/image-20240302165713656.png" class="" title="image-20240302165713656">
<h3 id="HLS查询操作"><a href="#HLS查询操作" class="headerlink" title="HLS查询操作"></a>HLS查询操作</h3><img src="/2023/03/02/distributed-system/image-20240302165721466.png" class="" title="image-20240302165721466">
<p>现在希望能定位实体E的位置信息，那么就向当前域的目录结点发送查找请求：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">if</span> 目录结点找到了实体E的位置信息:<br>	<span class="hljs-keyword">if</span> 找到的是子域目录结点的地址<br>		把查找请求转发给子域的目录结点<br>	<span class="hljs-keyword">else</span> <br>		找到了叶节点，把地址返回给请求的客户<br><span class="hljs-keyword">else</span><br>	把查找请求转发给父节点<br></code></pre></td></tr></table></figure>
<p>最差情况是一直找不到，向上转发直到根节点。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能实验-基于LSTM+CTC的验证码</title>
    <url>/2023/02/18/AI-lab03/</url>
    <content><![CDATA[<h2 id="实验4-基于LSTM-CTC的验证码"><a href="#实验4-基于LSTM-CTC的验证码" class="headerlink" title="实验4-基于LSTM+CTC的验证码"></a>实验4-基于LSTM+CTC的验证码</h2><h3 id="1、实验目的"><a href="#1、实验目的" class="headerlink" title="1、实验目的"></a>1、实验目的</h3><ul>
<li>会利用循环网络模型解决序列数据的相关问题</li>
</ul>
<h3 id="2、实验内容"><a href="#2、实验内容" class="headerlink" title="2、实验内容"></a>2、实验内容</h3><ul>
<li>使用循环网络，自主实现效验码中多个数字字符的识别，并使用深度学习框架完成模型的训练</li>
</ul>
<h3 id="3、实验步骤"><a href="#3、实验步骤" class="headerlink" title="3、实验步骤"></a>3、实验步骤</h3><blockquote>
<p>实验一共分为两个实践，第一个实践是CAPTCHA识别实践，第二个实践是基于LSTM+CTC的验证码识别是实践，本次实验第一个实践在CPU上完成，第二个实践则在GPU上完成</p>
</blockquote>
<h4 id="3-1-CAPTCHA识别实践"><a href="#3-1-CAPTCHA识别实践" class="headerlink" title="3.1 CAPTCHA识别实践"></a>3.1 CAPTCHA识别实践</h4><ul>
<li><p>获取数据集</p>
<blockquote>
<p>tqdm用于显示进度条，captcha用于生成验证码数据集，一共生成100000个验证码图片</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取数据集</span><br><span class="hljs-keyword">from</span> captcha.image <span class="hljs-keyword">import</span> ImageCaptcha<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> os<br><br>H, W, C = <span class="hljs-number">100</span>, <span class="hljs-number">120</span>, <span class="hljs-number">3</span><br>N_LABELS = <span class="hljs-number">10</span><br>D = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_captcha_images</span>(<span class="hljs-params">datasets_path, num_images, width=<span class="hljs-number">200</span>, height=<span class="hljs-number">100</span></span>):<br>    images_path = os.path.join(datasets_path, <span class="hljs-string">&#x27;image&#x27;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(images_path):<br>        os.makedirs(images_path)<br>        <br>    label_file =  <span class="hljs-built_in">open</span>(os.path.join(datasets_path, <span class="hljs-string">&#x27;labels.txt&#x27;</span>), <span class="hljs-string">&#x27;w&#x27;</span>)<br>    image = ImageCaptcha(width=width, height=height)<br>    alphabet = <span class="hljs-string">&#x27;0123456789&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(num_images)):<br>        <span class="hljs-comment"># 生成随机4位数字的效验码内容</span><br>        captcha_text = random.choices(alphabet, k=<span class="hljs-number">4</span>)<br>        label = <span class="hljs-string">&#x27;&#x27;</span>.join(captcha_text)<br>        <span class="hljs-comment"># 文件名与输出路径</span><br>        image_filename = <span class="hljs-string">f&#x27;%d.&#x27;</span> % i + <span class="hljs-string">&#x27;jpg&#x27;</span><br>        output_path = os.path.join(images_path, image_filename)<br>        <span class="hljs-comment"># 保存图片和写入标签</span><br>        image.write(label, output_path)<br>        label_file.write(image_filename + <span class="hljs-string">&#x27;,&#x27;</span> + label + <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    label_file.close()<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成以后将改行设为注释</span><br><span class="hljs-comment"># generate_captcha_images(&#x27;train1&#x27;, 100000, width=120, height=100)</span><br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111212922711.png" class="" title="image-20230111212922711">
</li>
<li><p>获取图片对应的标签值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取图片对应的标签值</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> os<br><br>filenames_file = os.listdir(<span class="hljs-string">&#x27;train1/image/&#x27;</span>)<br>label_file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;train1/labels.txt&#x27;</span>)<br><br>filenames = []<br>labels = []<br><br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> label_file:<br>    line_split = line.strip().split(<span class="hljs-string">&#x27;,&#x27;</span>)<br>    filename, label = line_split[<span class="hljs-number">0</span>], line_split[<span class="hljs-number">1</span>]<br>    filenames.append(filename)<br>    labels.append(label)<br>    <br><span class="hljs-comment"># 将文件名和标签一一对应</span><br>df = pd.DataFrame(&#123;<br>    <span class="hljs-string">&#x27;filename&#x27;</span>:filenames,<br>    <span class="hljs-string">&#x27;label&#x27;</span>:labels<br>&#125;)<br><br>df.head(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111213029737.png" class="" title="image-20230111213029737">
</li>
<li><p>划分训练集和测试集</p>
<blockquote>
<p>按照8训练集：2训练集的比例进行划分</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 划分数据集</span><br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br>df_train, df_valid = train_test_split(df, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br>df_train = df_train.reset_index(drop=<span class="hljs-literal">True</span>)<br>df_valid = df_valid.reset_index(drop=<span class="hljs-literal">True</span>)<br><br>total_train = df_train.shape[<span class="hljs-number">0</span>]<br>total_valid = df_valid.shape[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>
</li>
<li><p>构造data_generator</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构造data_generator</span><br><span class="hljs-keyword">from</span> tensorflow.keras.utils <span class="hljs-keyword">import</span> to_categorical<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data_generator</span>(<span class="hljs-params">df, num, for_training, batch_size=<span class="hljs-number">16</span></span>):<br>    images, labels = [], []<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>            r = df.iloc[i]<br>            file, label = os.path.join(<span class="hljs-string">&#x27;train1&#x27;</span>, <span class="hljs-string">&#x27;image&#x27;</span>, r[<span class="hljs-string">&#x27;filename&#x27;</span>]), r[<span class="hljs-string">&#x27;label&#x27;</span>]<br>            im = Image.<span class="hljs-built_in">open</span>(file)<br>            im = np.array(im) / <span class="hljs-number">255.0</span><br>            images.append(np.array(im))<br>            labels.append(np.array([np.array(to_categorical(<span class="hljs-built_in">int</span>(i), N_LABELS)) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> label]))<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(images) &gt; batch_size:<br>                <span class="hljs-keyword">yield</span> np.array(images), np.array(labels)<br>                images, labels = [], []<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> for_training:<br>                <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>查看所生成的数据样例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看生成数据样例</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> get_data_generator(df_train, total_train, <span class="hljs-literal">True</span>):<br>    X, y = v<br>    <span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(X.shape, y.shape)<br>plt.imshow(X[<span class="hljs-number">0</span>], interpolation=<span class="hljs-string">&#x27;nearest&#x27;</span>)<br><span class="hljs-built_in">print</span>(y[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111213218547.png" class="" title="image-20230111213218547">
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">64</span><br>valid_batch_size = <span class="hljs-number">64</span><br>train_gen = get_data_generator(df_train, total_train, for_training=<span class="hljs-literal">True</span>, batch_size=batch_size)<br>valid_gen = get_data_generator(df_valid, total_valid, for_training=<span class="hljs-literal">True</span>, batch_size=valid_batch_size)<br></code></pre></td></tr></table></figure>
</li>
<li><p>构建网络，定义损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构建网络</span><br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> Input<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Conv2D, PReLU, MaxPooling2D, Flatten, Dense, Reshape, Softmax<br><br>model = Sequential()<br><br>model.add(Input(shape=(H, W, C)))<br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)))<br>model.add(PReLU())<br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), strides=<span class="hljs-number">2</span>))<br><br>model.add(Conv2D(<span class="hljs-number">64</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)))<br>model.add(PReLU())<br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), strides=<span class="hljs-number">2</span>))<br><br>model.add(Conv2D(<span class="hljs-number">128</span>, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>,)))<br>model.add(PReLU())<br>model.add(MaxPooling2D((<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), strides=<span class="hljs-number">2</span>))<br><br>model.add(Flatten())<br>model.add(Dense(D * N_LABELS))<br>model.add(Reshape([D, N_LABELS]))<br><br>model.add(Softmax())<br><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;Adam&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>], loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看网络结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">model.summary()<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111213428993.png" class="" title="image-20230111213428993">
</li>
<li><p>开始训练</p>
<blockquote>
<p>一共完成5个epoches，每个epoches含有1250步</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">histort = model.fit(train_gen,<br>                   steps_per_epoch=total_train//batch_size,<br>                   epochs=<span class="hljs-number">5</span>,<br>                   validation_data=valid_gen,<br>                   validation_steps=total_valid//valid_batch_size)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111213530417.png" class="" title="image-20230111213530417">
</li>
<li><p>测试验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">test = get_data_generator(df_valid, total_valid, <span class="hljs-literal">True</span>)<br>X_test, y_test = <span class="hljs-built_in">next</span>(test)<br><br>plt.imshow(X_test[<span class="hljs-number">0</span>], interpolation=<span class="hljs-string">&#x27;nearest&#x27;</span>)<br><span class="hljs-built_in">print</span>(y[<span class="hljs-number">0</span>])<br><br>y_pred = model.predict_on_batch(X_test)<br>y_true = tf.math.argmax(y_test, axis=-<span class="hljs-number">1</span>)<br>y_pred = tf.math.argmax(y_pred, axis=-<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;y_true:&#x27;</span>, y_true[<span class="hljs-number">0</span>].numpy())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;y_pred:&#x27;</span>, y_pred[<span class="hljs-number">0</span>].numpy())<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111215240888.png" class="" title="image-20230111215240888">
</li>
</ul>
<h4 id="3-2-基于LSTM-CTC的验证码识别"><a href="#3-2-基于LSTM-CTC的验证码识别" class="headerlink" title="3.2 基于LSTM+CTC的验证码识别"></a>3.2 基于LSTM+CTC的验证码识别</h4><ul>
<li><p>导入相关库函数，定义常量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入必要的库</span><br><span class="hljs-keyword">from</span> captcha.image <span class="hljs-keyword">import</span> ImageCaptcha<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-keyword">import</span> tensorflow.keras.backend <span class="hljs-keyword">as</span> K<br><span class="hljs-keyword">import</span> string<br><br>%matplotlib inline<br>%config InlineBackend.figure_format = <span class="hljs-string">&#x27;retina&#x27;</span><br><br>characters = string.digits + string.ascii_uppercase<br><span class="hljs-built_in">print</span>(characters)<br><br>width = <span class="hljs-number">128</span><br>height = <span class="hljs-number">64</span><br>n_len = <span class="hljs-number">4</span><br>n_class = <span class="hljs-built_in">len</span>(characters) + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>定义CTC损失函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义CTC Loss</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ctc_lambda_func</span>(<span class="hljs-params">args</span>):<br>    y_pred, labels, input_length, label_length = args<br>    <span class="hljs-keyword">return</span> K.ctc_batch_cost(labels, y_pred, input_length, label_length)<br></code></pre></td></tr></table></figure>
</li>
<li><p>定义网络结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">input_tensor = Input((height, width, <span class="hljs-number">3</span>))<br>x = input_tensor<br><span class="hljs-keyword">for</span> i, n_cnn <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>]):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_cnn):<br>        x = Conv2D(<span class="hljs-number">32</span>*<span class="hljs-number">2</span>**<span class="hljs-built_in">min</span>(i, <span class="hljs-number">3</span>), kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>, kernel_initializer=<span class="hljs-string">&#x27;he_uniform&#x27;</span>)(x)<br>        x = BatchNormalization()(x)<br>        x = Activation(<span class="hljs-string">&#x27;relu&#x27;</span>)(x)<br>    x = MaxPooling2D(<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">3</span> <span class="hljs-keyword">else</span> (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))(x)<br>x = Permute((<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>))(x)<br>x = TimeDistributed(Flatten())(x)<br><br>rnn_size = <span class="hljs-number">128</span><br>x = Bidirectional(GRU(rnn_size, return_sequences=<span class="hljs-literal">True</span>))(x)<br>x = Bidirectional(GRU(rnn_size, return_sequences=<span class="hljs-literal">True</span>))(x)<br>x = Dense(n_class, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>)(x)<br><br>base_model = Model(inputs=input_tensor, outputs=x)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">labels = Input(name=<span class="hljs-string">&#x27;the_labels&#x27;</span>, shape=[n_len], dtype=<span class="hljs-string">&#x27;float32&#x27;</span>)<br>input_length = Input(name=<span class="hljs-string">&#x27;input_length&#x27;</span>, shape=[<span class="hljs-number">1</span>], dtype=<span class="hljs-string">&#x27;int64&#x27;</span>)<br>label_length = Input(name=<span class="hljs-string">&#x27;label_length&#x27;</span>, shape=[<span class="hljs-number">1</span>], dtype=<span class="hljs-string">&#x27;int64&#x27;</span>)<br>loss_out = Lambda(ctc_lambda_func, output_shape=(<span class="hljs-number">1</span>,), name=<span class="hljs-string">&#x27;ctc&#x27;</span>)([x, labels, input_length, label_length])<br><br>model = Model(inputs=[input_tensor, labels, input_length, label_length], outputs=loss_out)<br></code></pre></td></tr></table></figure>
</li>
<li><p>生成数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据生成</span><br><span class="hljs-keyword">from</span> tensorflow.keras.utils <span class="hljs-keyword">import</span> <span class="hljs-type">Sequence</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CaptchaSequence</span>(<span class="hljs-title class_ inherited__">Sequence</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, characters, batch_size, steps, n_len=<span class="hljs-number">4</span>, width=<span class="hljs-number">128</span>, height=<span class="hljs-number">64</span>,</span><br><span class="hljs-params">                 input_length=<span class="hljs-number">16</span>, label_length=<span class="hljs-number">4</span></span>):<br>        self.characters = characters<br>        self.batch_size = batch_size<br>        self.steps = steps<br>        self.n_len = n_len<br>        self.width = width<br>        self.height = height<br>        self.input_length = input_length<br>        self.label_length = label_length<br>        self.n_class = <span class="hljs-built_in">len</span>(characters)<br>        self.generator = ImageCaptcha(width=width, height=height)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self.steps<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        X = np.zeros((self.batch_size, self.height, self.width, <span class="hljs-number">3</span>), dtype=np.float32)<br>        y = np.zeros((self.batch_size, self.n_len), dtype=np.uint8)<br>        input_length = np.ones(self.batch_size)*self.input_length<br>        label_length = np.ones(self.batch_size)*self.label_length<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.batch_size):<br>            rand_str = <span class="hljs-string">&#x27;&#x27;</span>.join([random.choice(self.characters) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.n_len)])<br>            X[i] = np.array(self.generator.generate_image(rand_str))/<span class="hljs-number">255.0</span><br>            y[i] = [self.characters.find(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> rand_str]<br>        <span class="hljs-keyword">return</span> [X, y, input_length, label_length], np.ones(self.batch_size)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看生成的图片</span><br>data = CaptchaSequence(characters, batch_size=<span class="hljs-number">1</span>, steps=<span class="hljs-number">1</span>)<br>[X_test, y_test, _, _], _ = data[<span class="hljs-number">0</span>]<br>plt.imshow(X_test[<span class="hljs-number">0</span>])<br>plt.title(<span class="hljs-string">&#x27;&#x27;</span>.join([characters[x] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> y_test[<span class="hljs-number">0</span>]]))<br><span class="hljs-built_in">print</span>(input_length, label_length)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111221331595.png" class="" title="image-20230111221331595">
</li>
<li><p>准确率回调</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 准确率回调函数</span><br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">model, batch_size=<span class="hljs-number">128</span>, steps=<span class="hljs-number">20</span></span>):<br>    batch_acc = <span class="hljs-number">0</span><br>    valid_data = CaptchaSequence(characters, batch_size, steps)<br>    <span class="hljs-keyword">for</span> [X_test, y_test, _, _], _ <span class="hljs-keyword">in</span> valid_data:<br>        y_pred = base_model.predict(X_test)<br>        shape = y_pred.shape<br>        out = K.get_value(K.ctc_decode(y_pred, input_length=np.ones(shape[<span class="hljs-number">0</span>])*shape[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])[:, :<span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">if</span> out.shape[<span class="hljs-number">1</span>] == <span class="hljs-number">4</span>:<br>            batch_acc += (y_test == out).<span class="hljs-built_in">all</span>(axis=<span class="hljs-number">1</span>).mean()<br>            <br>    <span class="hljs-keyword">return</span> batch_acc / steps<br>    <br><span class="hljs-keyword">from</span> tensorflow.keras.callbacks <span class="hljs-keyword">import</span> Callback<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Evaluate</span>(<span class="hljs-title class_ inherited__">Callback</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.accs = []<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_epoch_end</span>(<span class="hljs-params">self, epoch, logs=<span class="hljs-literal">None</span></span>):<br>        logs = logs <span class="hljs-keyword">or</span> &#123;&#125;<br>        acc = evaluate(base_model)<br>        logs[<span class="hljs-string">&#x27;val_acc&#x27;</span>] = acc<br>        self.accs.append(acc)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nacc:<span class="hljs-subst">&#123;acc*<span class="hljs-number">100</span>:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p>训练模型</p>
<blockquote>
<p>由于使用了EarlyStopping，当训练到第13个epoch时，损失值的减少已经小于1e-3，所以会提前停止训练</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练</span><br><span class="hljs-keyword">from</span> tensorflow.keras.callbacks <span class="hljs-keyword">import</span> EarlyStopping, CSVLogger, ModelCheckpoint<br><span class="hljs-keyword">from</span> tensorflow.keras.optimizers <span class="hljs-keyword">import</span> *<br><br>train_data = CaptchaSequence(characters, batch_size=<span class="hljs-number">128</span>, steps=<span class="hljs-number">1000</span>)<br>valid_data = CaptchaSequence(characters, batch_size=<span class="hljs-number">128</span>, steps=<span class="hljs-number">100</span>)<br><br>callbacks = [EarlyStopping(patience=<span class="hljs-number">5</span>), Evaluate(),<br>             CSVLogger(<span class="hljs-string">&#x27;ctc.csv&#x27;</span>), ModelCheckpoint(<span class="hljs-string">&#x27;ctc_best.h5&#x27;</span>, save_best_only=<span class="hljs-literal">True</span>)]<br><br>model.<span class="hljs-built_in">compile</span>(loss=&#123;<span class="hljs-string">&#x27;ctc&#x27;</span>: <span class="hljs-keyword">lambda</span> y_true, y_pred: y_pred&#125;, optimizer=Adam(<span class="hljs-number">1e-3</span>, amsgrad=<span class="hljs-literal">True</span>))<br><br><span class="hljs-comment"># 查看GPU设备</span><br>tf.config.experimental.list_physical_devices(<span class="hljs-string">&#x27;GPU&#x27;</span>)<br><br><span class="hljs-keyword">with</span> tf.device(<span class="hljs-string">&#x27;GPU:0&#x27;</span>):<br>    model.fit(train_data, epochs=<span class="hljs-number">100</span>, validation_data=valid_data, workers=<span class="hljs-number">4</span>,<br>              callbacks=callbacks)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111221612234.png" class="" title="image-20230111221612234">
</li>
<li><p>提高精度，再次训练</p>
<blockquote>
<p>这一次在第24epoch时停止了训练</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提前停止了，继续载入参数训练一会</span><br>model.load_weights(<span class="hljs-string">&#x27;ctc_best.h5&#x27;</span>)<br><br>callbacks = [EarlyStopping(patience=<span class="hljs-number">5</span>), Evaluate(),<br>             CSVLogger(<span class="hljs-string">&#x27;ctc.csv&#x27;</span>, append=<span class="hljs-literal">True</span>), ModelCheckpoint(<span class="hljs-string">&#x27;ctc_best.h5&#x27;</span>, save_best_only=<span class="hljs-literal">True</span>)]<br><br>model.<span class="hljs-built_in">compile</span>(loss=&#123;<span class="hljs-string">&#x27;ctc&#x27;</span>: <span class="hljs-keyword">lambda</span> y_true, y_pred: y_pred&#125;, optimizer=Adam(<span class="hljs-number">1e-4</span>, amsgrad=<span class="hljs-literal">True</span>))<br><br><span class="hljs-keyword">with</span> tf.device(<span class="hljs-string">&#x27;GPU:0&#x27;</span>):<br>    model.fit(train_data, epochs=<span class="hljs-number">100</span>, validation_data=valid_data, workers=<span class="hljs-number">4</span>,<br>              callbacks=callbacks)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111221801614.png" class="" title="image-20230111221801614">
</li>
<li><p>模型测试</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型测试</span><br>model.load_weights(<span class="hljs-string">&#x27;ctc_best.h5&#x27;</span>)<br>characters2 = characters + <span class="hljs-string">&#x27; &#x27;</span><br>[X_test, y_test, _, _], _ = data[<span class="hljs-number">0</span>]<br>y_pred = base_model.predict(X_test)<br>out = K.get_value(K.ctc_decode(y_pred, input_length=np.ones(y_pred.shape[<span class="hljs-number">0</span>])*y_pred.shape[<span class="hljs-number">1</span>], )[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])[:, :<span class="hljs-number">4</span>]<br>out = <span class="hljs-string">&#x27;&#x27;</span>.join([characters[x] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> out[<span class="hljs-number">0</span>]])<br>y_true = <span class="hljs-string">&#x27;&#x27;</span>.join([characters[x] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> y_test[<span class="hljs-number">0</span>]])<br><br>plt.imshow(X_test[<span class="hljs-number">0</span>])<br>plt.title(<span class="hljs-string">&#x27;pred:&#x27;</span> + <span class="hljs-built_in">str</span>(out) + <span class="hljs-string">&#x27;\ntrue&#x27;</span> + <span class="hljs-built_in">str</span>(y_true))<br><br>argmax = np.argmax(y_pred, axis=<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>]<br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(argmax, <span class="hljs-string">&#x27;&#x27;</span>.join([characters2[x] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> argmax])))<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111221851068.png" class="" title="image-20230111221851068">
</li>
<li><p>计算总体准确度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算模型总体准确度</span><br>evaluate(base_model)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111221914620.png" class="" title="image-20230111221914620">
</li>
<li><p>保存模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存模型</span><br>base_model.save(<span class="hljs-string">&#x27;ctc.h5&#x27;</span>, include_optimizer=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><p>可视化训练曲线</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可视化训练曲线</span><br>df = pd.read_csv(<span class="hljs-string">&#x27;ctc.csv&#x27;</span>)<br>df[[<span class="hljs-string">&#x27;loss&#x27;</span>, <span class="hljs-string">&#x27;val_loss&#x27;</span>]].plot()<br></code></pre></td></tr></table></figure>
<img src="/2023/02/18/AI-lab03/image-20230111221947792.png" class="" title="image-20230111221947792">
</li>
</ul>
<h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h3><ul>
<li><p>对LSTM的理解</p>
<p>Long Short Term Memory networks（以下简称LSTMs），一种特殊的RNN网络，该网络设计出来是为了解决长依赖问题。</p>
<p>所有循环神经网络都具有神经网络的重复模块链的形式。 在标准的RNN中，该重复模块将具有非常简单的结构，例如单个tanh层。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6983308-2f0d4a87883d2c8c.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="img"></p>
<p>LSTMs也具有这种链式结构，但是它的重复单元不同于标准RNN网络里的单元只有一个网络层，它的内部有四个网络层。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6983308-169c41fa64ff202f.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp" alt="img"></p>
</li>
<li><p>对CTC的理解</p>
<p>CTC（Connectionist Temporal Classifier，联接时间分类器），主要用于解决输入特征与输出标签的对齐问题。由于文字的不同间隔或变形等问题，导致同个文字有不同的表现形式，但实际上都是同一个文字。在识别时会将输入图像分块后再去识别，得出每块属于某个字符的概率（无法识别的标记为特殊字符”-”）。由于字符变形等原因，导致对输入图像分块识别时，相邻块可能会识别为同个结果，字符重复出现。因此，通过CTC来解决对齐问题，模型训练后，对结果中去掉间隔字符、去掉重复字符（如果同个字符连续出现，则表示只有1个字符，如果中间有间隔字符，则表示该字符出现多次。</p>
</li>
<li><p>实验所涉及的问题</p>
<ul>
<li><p>问题1：两个实验运用的模型有什么差别？</p>
<p>第一个实验的模型单纯的运用了卷积神经网络，而第二个实验的模型还用到了LSTM+CTC的机制。</p>
</li>
<li><p>问题2：第二个实验运用的模型更适合哪一类任务？</p>
<p>第二个实验更适合解决对于序列任务的识别，特征之间有依赖关系的这一类任务。</p>
</li>
<li><p>问题3：LSTM为什么能够适用于这一类任务？</p>
<p>LSTM网络能通过一种被称为门的结构对细胞状态进行删除或者添加信息。门能够有选择性的决定让哪些信息通过，包含记忆门：决定给细胞状态添加哪些新的信息，遗忘门：选择忘记旧细胞信息的一部分，输出门：决定最终的输出。</p>
</li>
<li><p>问题4：对CTC的理解，CTC有什么作用？</p>
<p>主要用于解决输入特征与输出标签的对齐问题，在本次实验中，图片识别过程中，会将一些无关的特征识别成空白，同时对输出标签进行定长后再提取最终信息。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能实验-花卉图像分类实验</title>
    <url>/2023/02/12/AI-lab02/</url>
    <content><![CDATA[<h2 id="实验二、花卉图像分类实验"><a href="#实验二、花卉图像分类实验" class="headerlink" title="实验二、花卉图像分类实验"></a>实验二、花卉图像分类实验</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><blockquote>
<p>1、掌握如何使用MindSpore进行卷积神经网络的开发</p>
<p>2、了解如何使用MindSpore进行花卉图片分类任务的训练</p>
<p>3、了解如何使用MindSpore进行花卉图片分类任务的测试</p>
</blockquote>
<h3 id="二、实验步骤"><a href="#二、实验步骤" class="headerlink" title="二、实验步骤"></a>二、实验步骤</h3><ul>
<li><p><strong>华为云环境的配置</strong></p>
<blockquote>
<p>使用ModelArts，并建立Notebook</p>
</blockquote>
<ul>
<li>进入ModelArts</li>
</ul>
<img src="/2023/02/12/AI-lab02/image-20230108225530690.png" class="" title="image-20230108225530690">
<ul>
<li>点击管理控制台</li>
</ul>
<img src="/2023/02/12/AI-lab02/image-20230108225641834.png" class="" title="image-20230108225641834">
<ul>
<li>创建Notebook</li>
</ul>
<img src="/2023/02/12/AI-lab02/image-20230108225724739.png" class="" title="image-20230108225724739">
<ul>
<li>本次实验选择的是以下配置</li>
</ul>
<blockquote>
<p>mindspore1.7.0-cuda10.1-py3.7-ubuntu18.04</p>
<p>GPU: 1*V100(32GB)|CPU: 8核 64GB</p>
<p>在华为的GPU上运行</p>
</blockquote>
<img src="/2023/02/12/AI-lab02/image-20230108225829669.png" class="" title="image-20230108225829669">
<ul>
<li>创建过后便可从列表中进行相关操作</li>
</ul>
<img src="/2023/02/12/AI-lab02/image-20230108230000075.png" class="" title="image-20230108230000075">
</li>
<li><p><strong>实验步骤</strong></p>
<ul>
<li>导入相关函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> easydict <span class="hljs-keyword">import</span> EasyDict <span class="hljs-keyword">as</span> edict<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> mindspore<br><span class="hljs-keyword">import</span> mindspore.dataset <span class="hljs-keyword">as</span> ds<br><span class="hljs-keyword">import</span> mindspore.dataset.vision.c_transforms <span class="hljs-keyword">as</span> CV<br><span class="hljs-keyword">import</span> mindspore.dataset.transforms.c_transforms <span class="hljs-keyword">as</span> C<br><span class="hljs-keyword">from</span> mindspore.common <span class="hljs-keyword">import</span> dtype <span class="hljs-keyword">as</span> mstype<br><span class="hljs-keyword">from</span> mindspore <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> mindspore.common.initializer <span class="hljs-keyword">import</span> TruncatedNormal<br><span class="hljs-keyword">from</span> mindspore <span class="hljs-keyword">import</span> context<br><span class="hljs-keyword">from</span> mindspore.train <span class="hljs-keyword">import</span> Model<br><span class="hljs-keyword">from</span> mindspore.train.callback <span class="hljs-keyword">import</span> ModelCheckpoint, CheckpointConfig, LossMonitor, TimeMonitor<br><span class="hljs-keyword">from</span> mindspore.train.serialization <span class="hljs-keyword">import</span> load_checkpoint, load_param_into_net<br><span class="hljs-keyword">from</span> mindspore <span class="hljs-keyword">import</span> Tensor、<br><br><span class="hljs-comment"># 设置Mindspore的执行模式和设备</span><br>context.set_context(mode=context.GRAPH_MODE, device_target=<span class="hljs-string">&quot;GPU&quot;</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li>定义实验中使用的变量</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">cfg = edict(&#123;<br>    <span class="hljs-string">&#x27;data_path&#x27;</span>:<span class="hljs-string">&#x27;flower_photos&#x27;</span>,<br>    <span class="hljs-string">&#x27;data_size&#x27;</span>:<span class="hljs-number">3670</span>,<br>    <span class="hljs-string">&#x27;image_width&#x27;</span>:<span class="hljs-number">100</span>,<br>    <span class="hljs-string">&#x27;image_height&#x27;</span>:<span class="hljs-number">100</span>,<br>    <span class="hljs-string">&#x27;batch_size&#x27;</span>:<span class="hljs-number">32</span>,<br>    <span class="hljs-string">&#x27;channel&#x27;</span>:<span class="hljs-number">3</span>,<br>    <span class="hljs-string">&#x27;num_class&#x27;</span>:<span class="hljs-number">5</span>,<br>    <span class="hljs-string">&#x27;weight_decay&#x27;</span>:<span class="hljs-number">0.01</span>,<br>    <span class="hljs-string">&#x27;lr&#x27;</span>:<span class="hljs-number">0.0001</span>,<br>    <span class="hljs-string">&#x27;dropout_radio&#x27;</span>:<span class="hljs-number">0.5</span>,<br>    <span class="hljs-string">&#x27;epoch_size&#x27;</span>:<span class="hljs-number">400</span>,<br>    <span class="hljs-string">&#x27;sigma&#x27;</span>:<span class="hljs-number">0.01</span>,<br>    <br>    <span class="hljs-string">&#x27;save_checkpoint_steps&#x27;</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;keep_checkpoint_max&#x27;</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;output_directory&#x27;</span>:<span class="hljs-string">&#x27;./&#x27;</span>,<br>    <span class="hljs-string">&#x27;output_prefix&#x27;</span>:<span class="hljs-string">&quot;checkpoint_classification&quot;</span><br>&#125;)<br></code></pre></td></tr></table></figure>
<ul>
<li>下载并解压数据</li>
</ul>
<blockquote>
<p>数据来源于qq群提供的下载链接<a href="https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz">https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 解压数据集，运行一次即可</span><br><span class="hljs-comment"># !wget https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz</span><br><span class="hljs-comment"># !tar -zxvf flower_photos.tgz</span><br></code></pre></td></tr></table></figure>
<ul>
<li>数据处理</li>
</ul>
<blockquote>
<p>包含数据预处理和训练集和测试集的划分</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">de_dataset = ds.ImageFolderDataset(cfg.data_path,<br>                                   class_indexing=&#123;<span class="hljs-string">&#x27;daisy&#x27;</span>:<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;dandelion&#x27;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;roses&#x27;</span>:<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;sunflowers&#x27;</span>:<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;tulips&#x27;</span>:<span class="hljs-number">4</span>&#125;)<br><br>transform_img = CV.RandomCropDecodeResize([cfg.image_width,cfg.image_height],scale=(<span class="hljs-number">0.08</span>,<span class="hljs-number">1.0</span>),ratio=(<span class="hljs-number">0.75</span>,<span class="hljs-number">1.333</span>))<br><br>hwc2chw_op = CV.HWC2CHW()<br><br>type_cast_op = C.TypeCast(mstype.float32)<br><br>de_dataset = de_dataset.<span class="hljs-built_in">map</span>(input_columns=<span class="hljs-string">&#x27;image&#x27;</span>, num_parallel_workers=<span class="hljs-number">8</span>, operations=transform_img)<br>de_dataset = de_dataset.<span class="hljs-built_in">map</span>(input_columns=<span class="hljs-string">&#x27;image&#x27;</span>, num_parallel_workers=<span class="hljs-number">8</span>, operations=hwc2chw_op)<br>de_dataset = de_dataset.<span class="hljs-built_in">map</span>(input_columns=<span class="hljs-string">&#x27;image&#x27;</span>, num_parallel_workers=<span class="hljs-number">8</span>, operations=type_cast_op)<br>de_dataset = de_dataset.shuffle(buffer_size=cfg.data_size)<br><br><span class="hljs-comment"># 划分训练集和测试集</span><br>(de_train, de_test) = de_dataset.split([<span class="hljs-number">0.8</span>,<span class="hljs-number">0.2</span>])<br>de_train = de_train.batch(cfg.batch_size, drop_remainder=<span class="hljs-literal">True</span>)<br><br>de_test = de_test.batch(cfg.batch_size, drop_remainder=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;训练数据集数量：&#x27;</span>, de_train.get_dataset_size()*cfg.batch_size)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试数据集数量：&#x27;</span>, de_test.get_dataset_size()*cfg.batch_size)<br><br>data_next = de_dataset.create_dict_iterator(output_numpy=<span class="hljs-literal">True</span>).__next__()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;通道数/图像长/宽：&#x27;</span>, data_next[<span class="hljs-string">&#x27;image&#x27;</span>].shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;一张图像的标签样式:&#x27;</span>, data_next[<span class="hljs-string">&#x27;label&#x27;</span>])<br><span class="hljs-built_in">print</span>(data_next[<span class="hljs-string">&#x27;image&#x27;</span>][<span class="hljs-number">0</span>,...].shape)<br><br>plt.figure()<br>plt.imshow(data_next[<span class="hljs-string">&#x27;image&#x27;</span>][<span class="hljs-number">1</span>,...])<br>plt.colorbar()<br>plt.grid(<span class="hljs-literal">False</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>
<img src="/2023/02/12/AI-lab02/image-20230108230820413.png" class="" title="image-20230108230820413">
<ul>
<li>定义CNN图像识别网络</li>
</ul>
<blockquote>
<p>定义的网络包含4个卷积层，4个池化层，2个全连接层</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Identification_Net</span>(nn.Cell):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, num_class=<span class="hljs-number">5</span>, channel=<span class="hljs-number">3</span>, dropout_ratio=<span class="hljs-number">0.5</span>, trun_sigma=<span class="hljs-number">0.01</span></span>):<br>        <span class="hljs-built_in">super</span>(Identification_Net, self).__init__()<br>        self.num_class = num_class<br>        self.channel = channel<br>        self.dropout_ratio = dropout_ratio<br>        <span class="hljs-comment"># 卷积层</span><br>        self.conv1 = nn.Conv2d(self.channel, <span class="hljs-number">32</span>,<br>                               kernel_size=<span class="hljs-number">5</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>,<br>                               has_bias=<span class="hljs-literal">True</span>, pad_mode=<span class="hljs-string">&#x27;same&#x27;</span>,<br>                               weight_init=TruncatedNormal(sigma=trun_sigma), bias_init=<span class="hljs-string">&#x27;zeros&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 设置Relu激活函数</span><br>        self.relu = nn.ReLU()<br>        <br>        <span class="hljs-comment"># 设置最大池化层</span><br>        self.max_pool2d = nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>, stride=<span class="hljs-number">2</span>, pad_mode=<span class="hljs-string">&#x27;valid&#x27;</span>)<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>,<br>                               kernel_size=<span class="hljs-number">5</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>,<br>                               has_bias=<span class="hljs-literal">True</span>, pad_mode=<span class="hljs-string">&#x27;same&#x27;</span>,<br>                               weight_init=TruncatedNormal(sigma=trun_sigma), bias_init=<span class="hljs-string">&#x27;zeros&#x27;</span>)<br>        self.conv3 = nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>,<br>                               kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>,<br>                               has_bias=<span class="hljs-literal">True</span>, pad_mode=<span class="hljs-string">&#x27;same&#x27;</span>,<br>                               weight_init=TruncatedNormal(sigma=trun_sigma), bias_init=<span class="hljs-string">&#x27;zeros&#x27;</span>)<br>        self.conv4 = nn.Conv2d(<span class="hljs-number">128</span>, <span class="hljs-number">128</span>,<br>                               kernel_size=<span class="hljs-number">5</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">0</span>,<br>                               has_bias=<span class="hljs-literal">True</span>, pad_mode=<span class="hljs-string">&#x27;same&#x27;</span>,<br>                               weight_init=TruncatedNormal(sigma=trun_sigma), bias_init=<span class="hljs-string">&#x27;zeros&#x27;</span>)<br>        <br>        self.flatten = nn.Flatten()<br>        self.fc1 = nn.Dense(<span class="hljs-number">6</span>*<span class="hljs-number">6</span>*<span class="hljs-number">128</span>, <span class="hljs-number">1024</span>, weight_init=TruncatedNormal(sigma=trun_sigma),bias_init=<span class="hljs-number">0.1</span>)<br>        self.dropout = nn.Dropout(self.dropout_ratio)<br>        self.fc2 = nn.Dense(<span class="hljs-number">1024</span>, <span class="hljs-number">512</span>, weight_init=TruncatedNormal(sigma=trun_sigma),bias_init=<span class="hljs-number">0.1</span>)<br>        self.fc3= nn.Dense(<span class="hljs-number">512</span>, self.num_class, weight_init=TruncatedNormal(sigma=trun_sigma),bias_init=<span class="hljs-number">0.1</span>)<br>        <br>    <span class="hljs-comment"># 构建模型</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self, x</span>):<br>        x = self.conv1(x)<br>        x = self.relu(x)<br>        x = self.max_pool2d(x)<br>        x = self.conv2(x)<br>        x = self.relu(x)<br>        x = self.max_pool2d(x)<br>        x = self.conv3(x)<br>        x = self.max_pool2d(x)<br>        x = self.conv4(x)<br>        x = self.max_pool2d(x)<br>        x = self.flatten(x)<br>        x = self.fc1(x)<br>        x = self.relu(x)<br>        x = self.dropout(x)<br>        x = self.fc2(x)<br>        x = self.relu(x)<br>        x = self.dropout(x)<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure>
<ul>
<li>模型训练和预测</li>
</ul>
<blockquote>
<p>使用交叉熵损失函数，epoch_size为400，batch_size为32，学习率为0.0001，sigma为0.01</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">net = Identification_Net(num_class=cfg.num_class, channel=cfg.channel, dropout_ratio=cfg.dropout_radio)<br><br>net_loss = nn.SoftmaxCrossEntropyWithLogits(sparse=<span class="hljs-literal">True</span>, reduction=<span class="hljs-string">&quot;mean&quot;</span>)<br><br>fc_weghit_params = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-string">&#x27;fc&#x27;</span> <span class="hljs-keyword">in</span> x.name <span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;weight&#x27;</span> <span class="hljs-keyword">in</span> x.name, net.trainable_params()))<br>other_params=<span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x:<span class="hljs-string">&#x27;fc&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> x.name <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;weight&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> x.name, net.trainable_params()))<br><br>group_params = [&#123;<span class="hljs-string">&#x27;params&#x27;</span>:fc_weghit_params, <span class="hljs-string">&#x27;weight_decay&#x27;</span>:cfg.weight_decay&#125;,<br>                &#123;<span class="hljs-string">&#x27;params&#x27;</span>:other_params&#125;,<br>                &#123;<span class="hljs-string">&#x27;order_params&#x27;</span>:net.trainable_params()&#125;]<br><br>net_opt = nn.Adam(group_params, learning_rate=cfg.lr, weight_decay=<span class="hljs-number">0.0</span>)<br><br>model = Model(net, loss_fn=net_loss, optimizer=net_opt, metrics=&#123;<span class="hljs-string">&#x27;acc&#x27;</span>&#125;)<br><br>loss_cb = LossMonitor(per_print_times=de_train.get_dataset_size()*<span class="hljs-number">10</span>)<br>config_ck = CheckpointConfig(save_checkpoint_steps=cfg.save_checkpoint_steps,<br>                             keep_checkpoint_max=cfg.keep_checkpoint_max)<br>ckpoint_cb = ModelCheckpoint(prefix=cfg.output_prefix, directory=cfg.output_directory, config= config_ck)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=================开始训练==================&quot;</span>)<br><br>model.train(cfg.epoch_size, de_train, callbacks=[loss_cb, ckpoint_cb], dataset_sink_mode=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 使用测试集评估模型，打印总体准确率</span><br>metric = model.<span class="hljs-built_in">eval</span>(de_test)<br><span class="hljs-built_in">print</span>(metric)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>总体准确率为0.9432</p>
</blockquote>
<img src="/2023/02/12/AI-lab02/image-20230108232000280.png" class="" title="image-20230108232000280">
<ul>
<li>对具体样本进行预测</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>CKPT = os.path.join(cfg.output_directory, cfg.output_prefix+<br>                    <span class="hljs-string">&#x27;-&#x27;</span>+<span class="hljs-built_in">str</span>(cfg.epoch_size)+<span class="hljs-string">&#x27;_&#x27;</span>+<span class="hljs-built_in">str</span>(de_train.get_dataset_size())+<span class="hljs-string">&#x27;.ckpt&#x27;</span>)<br><br>net = Identification_Net(num_class=cfg.num_class,channel=cfg.channel,dropout_ratio=cfg.dropout_radio)<br><br>load_checkpoint(CKPT, net=net)<br><br>model = Model(net)<br><br>class_names = &#123;<span class="hljs-number">0</span>:<span class="hljs-string">&#x27;daisy&#x27;</span>, <span class="hljs-number">1</span>:<span class="hljs-string">&#x27;dandelion&#x27;</span>, <span class="hljs-number">2</span>:<span class="hljs-string">&#x27;roses&#x27;</span>, <span class="hljs-number">3</span>:<span class="hljs-string">&#x27;sunflowers&#x27;</span>, <span class="hljs-number">4</span>:<span class="hljs-string">&#x27;tulips&#x27;</span>&#125;<br>test_ = de_test.create_dict_iterator().__next__()<br><br>test = Tensor(test_[<span class="hljs-string">&#x27;image&#x27;</span>], mindspore.float32)<br><br>predictions = model.predict(test)<br>predictions = predictions.asnumpy()<br>true_label = test_[<span class="hljs-string">&#x27;label&#x27;</span>].asnumpy()<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>    p_np = predictions[i, :]<br>    pre_label = np.argmax(p_np)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;个sample预测结果：&#x27;</span>, class_names[pre_label], <span class="hljs-string">&#x27;真实结果：&#x27;</span>, class_names[true_label[i]])<br></code></pre></td></tr></table></figure>
<img src="/2023/02/12/AI-lab02/image-20230108232106204.png" class="" title="image-20230108232106204">
<ul>
<li>模型保存</li>
</ul>
<img src="/2023/02/12/AI-lab02/image-20230108232154796.png" class="" title="image-20230108232154796">
</li>
</ul>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>​        实验利用华为云平台完成了对于花卉分类实验，首先第一方面，对华为云平台以及华为开发的MindSpore深度学习框架有了进一步的了解。在华为云平台上可以为我们提供一些项目开发平台，具有一套完整的开发体系，如：OBS用于存储对象，ModelArts用于AI开发，训练模型等等。能够提供一些相对来说比较适宜的计算机算力，华为的GPU以及Ascend都可以通过云开发平台很好的运用。同时，对于MindSpore来说，和Tensorflow，Pytorch这一类框架一样，都是以Tensor张量做为数据基础，通过MindSpore能够很好的搭建相关网络，完成训练，梯度下降，等等运算。</p>
<p>​        本次实验解决的是花卉分类问题，是一个多分类的问题，对于多分类的问题了解更为深刻，多分类问题和二分类问题不一样的是，多分类问题会使用交叉熵损失函数，并在输出之前使用softmax函数进行处理，目的是将预测值映射为一个概率值，对比概率值最大的即作为最后的输出结果。同时对于卷积层，池化层，全连接层，这一些在图像处理当中常用到的网络加深了理解，通俗来讲，卷积层目的在于特征提取，池化层的目的在于优化参数，全连接层的目的则是特征整合。而在完成深度学习的过程中，重要的一点还有参数的设置，参数的设置，对于训练时长，训练效果也有较大的影响。</p>
<h4 id="四、实验中遇到的一些问题"><a href="#四、实验中遇到的一些问题" class="headerlink" title="四、实验中遇到的一些问题"></a>四、实验中遇到的一些问题</h4><ul>
<li><p>应该选择Relu函数还是Sigmoid函数？</p>
<p>解决方案：本次实验使用的时Relu函数做为激活函数，相对于Sigmoid来说，Relu函数不存在梯度消失的问题，能够尽可能多的进行迭代，降低损失值。</p>
</li>
</ul>
<h4 id="五、实验验收过程中问到的相关问题"><a href="#五、实验验收过程中问到的相关问题" class="headerlink" title="五、实验验收过程中问到的相关问题"></a>五、实验验收过程中问到的相关问题</h4><ul>
<li><p>问题1：该实验解决的是一个什么问题？设计的网络输出的向量是一个几维的？</p>
<p>回答：本次实验解决的是一个多分类问题，再具体来说，是一个五分类问题，完成的是识别给出的图片属于已知五类花卉中的哪一种，因此输出的向量是5维的。</p>
</li>
<li><p>问题2：该实验使用的是什么损失函数？</p>
<p>回答：使用的是交叉熵损失函数，在交叉熵前面会有一个softmax处理，softmax的处理过程就是将输入的数据映射到（0，1）之间的范围当中，并且使得输出的所有值累加和为1，从某种意义上来说，这也是相当于一种概率。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能实验-基于tensorflow的猫狗分类</title>
    <url>/2023/02/02/AI-lab01/</url>
    <content><![CDATA[<h2 id="实验三、基于tensorflow的猫狗分类"><a href="#实验三、基于tensorflow的猫狗分类" class="headerlink" title="实验三、基于tensorflow的猫狗分类"></a>实验三、基于tensorflow的猫狗分类</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><ul>
<li>掌握如何使用tensorflow/pytorch编程实现模型，并会使用JupyterNotebook或Pycharm完成项目</li>
</ul>
<h3 id="二、实验内容"><a href="#二、实验内容" class="headerlink" title="二、实验内容"></a>二、实验内容</h3><ul>
<li>完成猫狗分类的模型的编码实现和模型训练</li>
</ul>
<h3 id="三、实验步骤"><a href="#三、实验步骤" class="headerlink" title="三、实验步骤"></a>三、实验步骤</h3><ul>
<li><p>导入需要的函数包</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-keyword">from</span> tensorflow.keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator, load_img<br><span class="hljs-keyword">from</span> tensorflow.keras.utils <span class="hljs-keyword">import</span> to_categorical<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br><span class="hljs-keyword">import</span> matplotlib.pylab <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> os<br></code></pre></td></tr></table></figure>
</li>
<li><p>定义常量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">FAST_RUN = <span class="hljs-literal">False</span><br>IMAGE_WIDTH = <span class="hljs-number">128</span><br>IMAGE_HEIGHT = <span class="hljs-number">128</span><br>IMAGE_SIZE = (IMAGE_WIDTH, IMAGE_HEIGHT)<br>IMAGE_CHANNELS = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>处理数据集文件夹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 处理数据集</span><br>filenames = os.listdir(<span class="hljs-string">&#x27;train&#x27;</span>)<br>categories = []<br><span class="hljs-keyword">for</span> filename <span class="hljs-keyword">in</span> filenames:<br>    category = filename.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 将所有图片按照顺序打上标签，如果是dog标记为1，如果是cat标记为0</span><br>    <span class="hljs-keyword">if</span> category == <span class="hljs-string">&#x27;dog&#x27;</span>:<br>        categories.append(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        categories.append(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 将文件名与标签一一对应</span><br>df = pd.DataFrame(&#123;<br>    <span class="hljs-string">&#x27;filename&#x27;</span>:filenames,<br>    <span class="hljs-string">&#x27;category&#x27;</span>:categories<br>&#125;)<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看前十行数据内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看前十行内容</span><br>df.head(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109194724331.png" class="" title="image-20230109194724331">
</li>
<li><p>随机打开一张图片样本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机打开一张图片样本</span><br>sample = random.choice(filenames)<br>image = load_img(<span class="hljs-string">&#x27;train/&#x27;</span>+sample)<br>plt.imshow(image)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109194800246.png" class="" title="image-20230109194800246">
</li>
<li><p>处理数据标签</p>
<ul>
<li>生成训练数据</li>
<li>划分训练集和验证集</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df[<span class="hljs-string">&#x27;category&#x27;</span>] = df[<span class="hljs-string">&#x27;category&#x27;</span>].replace(&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;cat&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;dog&#x27;</span>&#125;)<br><span class="hljs-comment"># 划分训练集和验证集</span><br>df_train, df_valid = train_test_split(df, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br>df_train = df_train.reset_index(drop=<span class="hljs-literal">True</span>)<br>df_valid = df_valid.reset_index(drop=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 设置Batch Size与训练和验证样本数</span><br>total_train = df_train.shape[<span class="hljs-number">0</span>]<br>total_valid = df_valid.shape[<span class="hljs-number">0</span>]<br>batch_size = <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>数据生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练集数据生成</span><br>train_datagen = ImageDataGenerator(<br>    rotation_range=<span class="hljs-number">5</span>,<br>    rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>,<br>    shear_range=<span class="hljs-number">0.1</span>,<br>    zoom_range=<span class="hljs-number">0.2</span>,<br>    horizontal_flip=<span class="hljs-literal">True</span>,<br>    width_shift_range=<span class="hljs-number">0.1</span>,<br>    height_shift_range=<span class="hljs-number">0.1</span><br>)<br><br>train_generator = train_datagen.flow_from_dataframe(<br>    df_train,<br>    <span class="hljs-string">&#x27;train/&#x27;</span>,<br>    x_col=<span class="hljs-string">&#x27;filename&#x27;</span>,<br>    y_col=<span class="hljs-string">&#x27;category&#x27;</span>,<br>    target_size=IMAGE_SIZE,<br>    class_mode=<span class="hljs-string">&#x27;categorical&#x27;</span>,<br>    batch_size=batch_size<br>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 验证机数据生成</span><br>valid_datagen = ImageDataGenerator(rescale=<span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<br>valid_generator = valid_datagen.flow_from_dataframe(<br>    df_valid,<br>    <span class="hljs-string">&#x27;train/&#x27;</span>,<br>    x_col=<span class="hljs-string">&#x27;filename&#x27;</span>,<br>    y_col=<span class="hljs-string">&#x27;category&#x27;</span>,<br>    target_size=IMAGE_SIZE,<br>    class_mode=<span class="hljs-string">&#x27;categorical&#x27;</span>,<br>    batch_size=batch_size<br>)<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看数据生成样本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看数据生成样例</span><br>df_example = df_train.sample(n=<span class="hljs-number">1</span>).reset_index(drop=<span class="hljs-literal">True</span>)<br>example_generator = train_datagen.flow_from_dataframe(<br>    df_example,<br>    <span class="hljs-string">&#x27;train/&#x27;</span>,<br>    x_col=<span class="hljs-string">&#x27;filename&#x27;</span>,<br>    y_col=<span class="hljs-string">&#x27;category&#x27;</span>,<br>    target_size=IMAGE_SIZE,<br>    class_mode=<span class="hljs-string">&#x27;categorical&#x27;</span><br>)<br><br>plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">12</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">15</span>):<br>    plt.subplot(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, i+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> X_batch, Y_batch <span class="hljs-keyword">in</span> example_generator:<br>        image = X_batch[<span class="hljs-number">0</span>]<br>        plt.imshow(image)<br>        <span class="hljs-keyword">break</span><br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109195226820.png" class="" title="image-20230109195226820">
</li>
<li><p>建立模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tensorflow.keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Conv2D, MaxPooling2D, Dropout, Flatten, Dense, Activation, BatchNormalization<br><br>model = Sequential()<br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_CHANNELS), padding=<span class="hljs-string">&#x27;same&#x27;</span>))<br>model.add(BatchNormalization())<br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>))<br>model.add(BatchNormalization())<br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(BatchNormalization())<br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><br>model.add(Flatten())<br>model.add(Dense(<span class="hljs-number">512</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dropout(<span class="hljs-number">0.1</span>))<br>model.add(Dense(<span class="hljs-number">2</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br></code></pre></td></tr></table></figure>
</li>
<li><p>定义损失函数</p>
<blockquote>
<p>使用交叉熵损失函数</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">model.<span class="hljs-built_in">compile</span>(loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=<span class="hljs-string">&#x27;sgd&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br></code></pre></td></tr></table></figure>
</li>
<li><p>查看深度学习网络</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">model.summary()<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109195428838.png" class="" title="image-20230109195428838">
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 回调：在模型训练期间的某些点调用的实用程序</span><br><span class="hljs-keyword">from</span> tensorflow.keras.callbacks <span class="hljs-keyword">import</span> EarlyStopping, ReduceLROnPlateau<br><br>earlystop = EarlyStopping(patience=<span class="hljs-number">10</span>)<br>learning_rate_reduction = ReduceLROnPlateau(monitor = <span class="hljs-string">&#x27;val_accuracy&#x27;</span>,<br>                                            patience=<span class="hljs-number">5</span>,<br>                                            verbose=<span class="hljs-number">1</span>,<br>                                            factor=<span class="hljs-number">0.5</span>,<br>                                            min_lr=<span class="hljs-number">0.00001</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">callbacks = [earlystop, learning_rate_reduction]<br></code></pre></td></tr></table></figure>
</li>
<li><p>开始训练模型</p>
<blockquote>
<p>一共完成50个epoch训练，每个epoch含有156个steps</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练</span><br>FAST_RUN = <span class="hljs-literal">False</span><br>epochs = <span class="hljs-number">3</span> <span class="hljs-keyword">if</span> FAST_RUN <span class="hljs-keyword">else</span> <span class="hljs-number">50</span><br><br>history = model.fit(train_generator,<br>                   epochs=epochs,<br>                   validation_data=valid_generator,<br>                   validation_steps=total_valid//batch_size,<br>                   steps_per_epoch=total_train//batch_size,<br>                   callbacks=callbacks,<br>                   workers=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109195525256.png" class="" title="image-20230109195525256">
</li>
<li><p>保存模型</p>
<blockquote>
<p>利用model.save_weights与model.load_weights先训练10个epoch，保存模型后，再次加载继续训练20个epoch</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练10个epoch并保存模型</span><br>FAST_RUN = <span class="hljs-literal">False</span><br>epochs = <span class="hljs-number">3</span> <span class="hljs-keyword">if</span> FAST_RUN <span class="hljs-keyword">else</span> <span class="hljs-number">50</span><br><br>history = model.fit(train_generator,<br>                   epochs=<span class="hljs-number">10</span>,<br>                   validation_data=valid_generator,<br>                   validation_steps=total_valid//batch_size,<br>                   steps_per_epoch=total_train//batch_size,<br>                   callbacks=callbacks,<br>                   workers=<span class="hljs-number">12</span>)<br><br>model.save_weights(<span class="hljs-string">&#x27;weights.ckpt&#x27;</span>)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109204708818.png" class="" title="image-20230109204708818">
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 重新加载模型</span><br>model.load_weights(<span class="hljs-string">&#x27;weights.ckpt&#x27;</span>)<br><span class="hljs-comment"># 继续训练20个epoch</span><br>history1 = model.fit(train_generator,<br>                   epochs=<span class="hljs-number">20</span>,<br>                   validation_data=valid_generator,<br>                   validation_steps=total_valid//batch_size,<br>                   steps_per_epoch=total_train//batch_size,<br>                   callbacks=callbacks,<br>                   workers=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109214257445.png" class="" title="image-20230109214257445">
</li>
<li><p>对训练的结果进行可视化</p>
<blockquote>
<p>对存储的损失值和精度值拟合成曲线</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可视化训练结果</span><br>fig, (ax1, ax2) = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">12</span>))<br>ax1.plot(history.history[<span class="hljs-string">&#x27;loss&#x27;</span>], color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;Training loss&#x27;</span>)<br>ax1.plot(history.history[<span class="hljs-string">&#x27;val_loss&#x27;</span>], color=<span class="hljs-string">&#x27;r&#x27;</span>, label=<span class="hljs-string">&#x27;Validation loss&#x27;</span>)<br>ax1.set_xticks(np.arange(<span class="hljs-number">1</span>, epochs, <span class="hljs-number">1</span>))<br>ax1.set_yticks(np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>))<br>ax1.legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>, shadow=<span class="hljs-literal">True</span>)<br><br>ax2.plot(history.history[<span class="hljs-string">&#x27;accuracy&#x27;</span>], color=<span class="hljs-string">&#x27;b&#x27;</span>, label=<span class="hljs-string">&#x27;Training accuracy&#x27;</span>)<br>ax2.plot(history.history[<span class="hljs-string">&#x27;val_accuracy&#x27;</span>], color=<span class="hljs-string">&#x27;r&#x27;</span>, label=<span class="hljs-string">&#x27;Validation accuracy&#x27;</span>)<br>ax2.set_xticks(np.arange(<span class="hljs-number">1</span>, epochs, <span class="hljs-number">1</span>))<br><br>legend = plt.legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>, shadow=<span class="hljs-literal">True</span>)<br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109205151944.png" class="" title="image-20230109205151944">
</li>
<li><p>准备测试集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 准备测试集以及创建测试机</span><br>test_filenames = os.listdir(<span class="hljs-string">&#x27;test1&#x27;</span>)<br>df_test = pd.DataFrame(&#123;<br>    <span class="hljs-string">&#x27;filename&#x27;</span>:test_filenames<br>&#125;)<br>nb_samples = df_test.shape[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">test_datagen = ImageDataGenerator(<span class="hljs-attribute">rescale</span>=1./255)<br>test_generator = test_datagen.flow_from_dataframe(<br>    df_test,<br>    <span class="hljs-string">&#x27;test1/&#x27;</span>,<br>    <span class="hljs-attribute">x_col</span>=<span class="hljs-string">&#x27;filename&#x27;</span>,<br>    <span class="hljs-attribute">y_col</span>=None,<br>    <span class="hljs-attribute">class_mode</span>=None,<br>    <span class="hljs-attribute">target_size</span>=IMAGE_SIZE,<br>    <span class="hljs-attribute">batch_size</span>=batch_size,<br>    <span class="hljs-attribute">shuffle</span>=<span class="hljs-literal">False</span><br>)<br></code></pre></td></tr></table></figure>
</li>
<li><p>预测</p>
<blockquote>
<p>通过神经网络，对测试集的数据进行预测</p>
<p>选择输出概率最高的做为预测结果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">predict = model.predict(test_generator,<br>                       steps=np.ceil(nb_samples/batch_size),<br>                       workers=<span class="hljs-number">12</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">df_test[<span class="hljs-string">&#x27;category&#x27;</span>] = np.argmax(predict, axis=-<span class="hljs-number">1</span>)<br><br>label_map = <span class="hljs-built_in">dict</span>((v,k) <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> train_generator.class_indices.items())<br>df_test[<span class="hljs-string">&#x27;category&#x27;</span>] = df_test[<span class="hljs-string">&#x27;category&#x27;</span>].replace(label_map)<br><br>df_test[<span class="hljs-string">&#x27;category&#x27;</span>] = df_test[<span class="hljs-string">&#x27;category&#x27;</span>].replace(&#123;<span class="hljs-string">&#x27;dog&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;cat&#x27;</span>:<span class="hljs-number">0</span>&#125;)<br><br>df_test[<span class="hljs-string">&#x27;category&#x27;</span>].value_counts().plot.bar()<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109205407961.png" class="" title="image-20230109205407961">
</li>
<li><p>查看预测结果</p>
<blockquote>
<p>可视化了前三十个预测结果，只有1002一张图片预测错误</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">sample_test = df_test.head(<span class="hljs-number">30</span>)<br>sample_test.head()<br>dict_1 = &#123;<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;dog&#x27;</span>, <span class="hljs-number">0</span>:<span class="hljs-string">&#x27;cat&#x27;</span>&#125;<br>plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">24</span>))<br><span class="hljs-keyword">for</span> index, row <span class="hljs-keyword">in</span> sample_test.iterrows():<br>    filename = row[<span class="hljs-string">&#x27;filename&#x27;</span>]<br>    category = row[<span class="hljs-string">&#x27;category&#x27;</span>]<br>    img = load_img(<span class="hljs-string">&#x27;test1/&#x27;</span> + filename, target_size=IMAGE_SIZE)<br>    plt.subplot(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, index+<span class="hljs-number">1</span>)<br>    plt.imshow(img)<br>    plt.xlabel(filename + <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(category) + <span class="hljs-string">&#x27;)&#x27;</span> + dict_1[category])<br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/AI-lab01/image-20230109205438300.png" class="" title="image-20230109205438300">
<img src="/2023/02/02/AI-lab01/image-20230109205453040.png" class="" title="image-20230109205453040">
</li>
</ul>
<h4 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h4><ul>
<li><p>叙述从逻辑回归到神经元工作原理</p>
<p>逻辑回归工作原理：逻辑回归用于二分类问题，将输入的数据进行处理过后得到一个输出数据，再通过sigmoid函数，通过阈值的设置来判断将输出的数据映射为0，或者是1.</p>
<p>神经元工作原理：神经元的每一个输入都会对应一个相应的权值，通过神经元后，再经过激活函数，产生输出，常见的激活函数有sigmoid函数，relu函数。</p>
</li>
<li><p>两种常用的激活函数</p>
<p>Sigmoid激活函数、Relu激活函数</p>
</li>
<li><p>两种池化方式</p>
<p>最大池化：将输入的图像划分为若干个矩形区域，对每个子区域输出最大值。</p>
<p>平均池化：将输入的图像划分为若干个矩形区域，对每个子区域输出所有元素的平均值</p>
</li>
<li><p>卷积神经网络要素：卷积核、池化、特征图</p>
<p>卷积核：卷积核，是卷积层中用于与输入的矩阵进行卷积运算的单元，通过与卷积核的卷积运算能够提取出原始图像中的一些特征属性。</p>
<p>池化：池化的重要的目的在于进一步降低网络的整体计算代价，同时也能够在一定程度上降低网络出现过拟合的风险，能够将原始图像矩阵通过一定的池化方式进行压缩。</p>
<p>特征图：通过卷积层进行与卷积核运算过后所得到的图就称为提取特征后的特征图。</p>
</li>
<li><p>实验用到的模型图示，给出实验中的关键代码并解释</p>
<img src="/2023/02/02/AI-lab01/image-20230109222224342.png" class="" title="image-20230109222224342">
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">model = Sequential()<br><span class="hljs-comment"># 卷积层1，卷积核的大小为（3，3），使用relu激活函数</span><br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, input_shape=(IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_CHANNELS), padding=<span class="hljs-string">&#x27;same&#x27;</span>))<br><br><span class="hljs-comment"># 对数据进行标准化，加快训练速度</span><br>model.add(BatchNormalization())<br><br><span class="hljs-comment"># 池化层1，使用最大池化的方法，池化尺寸为（2，2）</span><br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><br><span class="hljs-comment"># 卷积层2，卷积核的大小为（3，3），使用relu激活函数</span><br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>, padding=<span class="hljs-string">&#x27;same&#x27;</span>))<br>model.add(BatchNormalization())<br><span class="hljs-comment"># 池化层2，使用最大池化的方法，池化尺寸为（2，2）</span><br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><br><span class="hljs-comment"># 卷积层3，卷积核的大小为（3，3），使用relu激活函数</span><br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(BatchNormalization())<br><span class="hljs-comment"># 池化层3，使用最大池化的方法，池化尺寸为（2，2）</span><br>model.add(MaxPooling2D(pool_size=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><br><span class="hljs-comment"># 扁平层，将多维数据一维化</span><br>model.add(Flatten())<br><span class="hljs-comment"># 全连接层2，将输入的数据转化为512维度</span><br>model.add(Dense(<span class="hljs-number">512</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br><span class="hljs-comment"># 删除10%的神经元，将其置为0，防止过拟合</span><br>model.add(Dropout(<span class="hljs-number">0.1</span>))<br><span class="hljs-comment"># 全连接层2，将数据最终转化为2为数据，通过softmax映射成概率值</span><br>model.add(Dense(<span class="hljs-number">2</span>, activation=<span class="hljs-string">&#x27;softmax&#x27;</span>))<br></code></pre></td></tr></table></figure>
</li>
<li><p>问答</p>
<p>问题：在训练过程中，学习率是怎样进行调整的？</p>
<p>回答：使用ReduceLROnPlateau和EarlyStopping配合动态调整学习率，ReduceLRonPlateau函数中有一些列参数可以搭配使用来动态调整学习率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">monitor：监测的值，可以是accuracy，val_loss,val_accuracy<br>factor：缩放学习率的值，学习率将以lr = lr*factor的形式被减少<br>patience：当patience个epoch过去而模型性能不提升时，学习率减少的动作会被触发<br>mode：‘auto’，‘<span class="hljs-built_in">min</span>’，‘<span class="hljs-built_in">max</span>’之一 默认‘auto’就行<br>epsilon：阈值，用来确定是否进入检测值的“平原区”<br>cooldown：学习率减少后，会经过cooldown个epoch才重新进行正常操作<br>min_lr：学习率最小值，能缩小到的下限<br></code></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch安装使用</title>
    <url>/2023/02/02/pytorch-install/</url>
    <content><![CDATA[<h2 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h2><h3 id="1、Pytorch的安装以及环境管理"><a href="#1、Pytorch的安装以及环境管理" class="headerlink" title="1、Pytorch的安装以及环境管理"></a>1、Pytorch的安装以及环境管理</h3><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 安装环境</span><br><span class="hljs-attribute">conda</span> create -n pytorch python=<span class="hljs-number">3</span>.<span class="hljs-number">9</span><br><br><span class="hljs-comment"># 激活环境，进入pytorch环境下</span><br><span class="hljs-attribute">conda</span> activate pytorch<br></code></pre></td></tr></table></figure>
<ul>
<li>查看对应显卡类型，显卡算力以及需要下载的CUDA版本</li>
</ul>
<blockquote>
<p>显卡型号：GeForce RTX3060</p>
<p>显卡算力：8.6</p>
<p>CUDA SDK 11.1 – 11.4 support for compute capability 3.5 – 8.6 (Kepler (in part), Maxwell, Pascal, Volta, Turing, Ampere (in part)).</p>
<p>CUDA SDK 11.5 – 11.7.1 support for compute capability 3.5 – 8.7 (Kepler (in part), Maxwell, Pascal, Volta, Turing, Ampere)</p>
<p>CUDA版本：11.5-11.7</p>
<p>显卡驱动：11.6</p>
</blockquote>
<ul>
<li>进入pytorch官网，pytorch.org</li>
</ul>
<img src="/2023/02/02/pytorch-install/image-20221022163847897.png" class="" title="image-20221022163847897">
<ul>
<li>选择对应型号</li>
</ul>
<blockquote>
<p>复制选中的内容，粘贴至pytorch环境下的命令中</p>
<p>conda install + 包</p>
</blockquote>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># conda的安装包命令 -c pytorch，表示默认从官网下载，会很慢</span><br><span class="hljs-attribute">conda</span> install pytorch torchvision torchaudio cudatoolkit=<span class="hljs-number">11</span>.<span class="hljs-number">6</span> -c 下载地址<br></code></pre></td></tr></table></figure>
<ul>
<li>安装过后检查安装包的情况</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 使用以上命令安装过后，会自动安装一个cpuonly的包，有这个包就不能使用gpu</span><br><span class="hljs-attribute">conda</span> list<br><br><span class="hljs-comment"># 卸载cpionly的包</span><br>conda uninstall cpuonly<br><br><span class="hljs-comment"># 输入yes后会更改pytorch torchvision torchaudio cudatoolkit=11.6</span><br>conda list<br><span class="hljs-comment"># 再次查看，就会发现</span><br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/pytorch-install/image-20221022164808915.png" class="" title="image-20221022164808915">
<ul>
<li>验证是否可以使用gpu</li>
</ul>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"># 进入pytorch环境下<br># pip list 查看环境下的包<br># 输入python，进入解释器<br><span class="hljs-keyword">import</span> torch <br>torch.cuda.is_available()<br># 返回为<span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/pytorch-install/image-20221022165103111.png" class="" title="image-20221022165103111">
<h3 id="2、Pytorch"><a href="#2、Pytorch" class="headerlink" title="2、Pytorch"></a>2、Pytorch</h3><ul>
<li>两大法宝内置函数</li>
</ul>
<blockquote>
<p>dir()，打开操作，看到有什么函数</p>
<p>help()，说明书，如何使用</p>
</blockquote>
<ul>
<li>加载数据</li>
</ul>
<blockquote>
<p><code>Dataset</code>类：提供一种方式取获取数据及其<code>label</code>值</p>
<p><code>Dataloader</code>类：为网络提供不同的数据形式，打包Dataset类</p>
</blockquote>
<p>​        使用dataset类的实战</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 继承Dataset类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyData</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br><br>    <span class="hljs-comment"># 构造函数，为后面的方法提供变量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root_dir, label_dir</span>):<br>        self.root_dir = root_dir<br>        self.label_dir = label_dir<br>        self.path = os.path.join(root_dir, label_dir)<br>        <span class="hljs-comment"># 图片所有地址</span><br>        self.img_path = os.listdir(self.path)<br><br>    <span class="hljs-comment"># 读取第idx张图片</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        img_name = self.img_path[idx]<br>        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)<br>        img = Image.<span class="hljs-built_in">open</span>(img_item_path)<br>        label = self.label_dir<br>        <span class="hljs-keyword">return</span> img, label<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.img_path)<br><br>root_dir = <span class="hljs-string">&quot;data\\train&quot;</span><br>label_dir = <span class="hljs-string">&quot;ants&quot;</span><br>ants_dataset = MyData(root_dir, label_dir)<br><br><span class="hljs-comment"># 读取第0张图片</span><br>img, label = ants_dataset[<span class="hljs-number">0</span>]<br><br></code></pre></td></tr></table></figure>
<img src="/2023/02/02/pytorch-install/image-20221022174307472.png" class="" title="image-20221022174307472">
<ul>
<li>PIL简单用法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-comment"># 读取图片文件</span><br>img = Image.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;文件路径&quot;</span>)<br><span class="hljs-comment"># 显示图片</span><br>img.show()<br></code></pre></td></tr></table></figure>
<ul>
<li>os用法</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 将文件夹下的文件名作为列表返回</span><br><span class="hljs-attribute">os</span>.listdir(文件夹名)<br><br><span class="hljs-comment"># 将两个文件路径拼接起来</span><br><span class="hljs-attribute">os</span>.path.join(路径<span class="hljs-number">1</span>, 路径<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
<h3 id="3、Tensorboard的使用"><a href="#3、Tensorboard的使用" class="headerlink" title="3、Tensorboard的使用"></a>3、Tensorboard的使用</h3><blockquote>
<p>使用Tensorboard的时候，可以将训练的数据图像在网页端监控</p>
</blockquote>
<ul>
<li>需要：pip install tensorboard</li>
<li><p>在Terminal中输入：tensorboard —logdir=logs  —port=<em>*</em></p>
<ul>
<li>主义输入的文件名不用加引号</li>
</ul>
</li>
<li><p>点击链接，可以指定端口号</p>
</li>
<li>在使用过程中，不同的图片要用不同的tag</li>
</ul>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 写入变化函数</span><br><span class="hljs-built_in">from</span> torch.utils.tensorboard import SummaryWriter<br><br><span class="hljs-built_in">write</span> = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><span class="hljs-comment">#write.add_image()</span><br><span class="hljs-comment"># 可以传入标题等</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):<br>    <span class="hljs-built_in">write</span>.add_scalar(<span class="hljs-string">&quot;y=2x&quot;</span>, <span class="hljs-number">2</span>*i, i)<br><br><span class="hljs-built_in">write</span>.<span class="hljs-built_in">close</span>()<br><br></code></pre></td></tr></table></figure>
<p>​        对图片的显示</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-keyword">write</span> = SummaryWriter(&quot;logs&quot;)<br>image_path = &quot;dataset\\train\\ants_image\\0013035.jpg&quot;<br>img_PIL = Image.<span class="hljs-keyword">open</span>(image_path)<br>img_array = np.<span class="hljs-keyword">array</span>(img_PIL)<br><br>print(img_array.shape)<br><br><span class="hljs-keyword">write</span>.add_image(&quot;test&quot;, img_array, <span class="hljs-number">1</span>, dataformats=<span class="hljs-string">&#x27;HWC&#x27;</span>)<br><br><span class="hljs-keyword">write</span>.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure>
<h3 id="4、Torchvision中的transforms"><a href="#4、Torchvision中的transforms" class="headerlink" title="4、Torchvision中的transforms"></a>4、Torchvision中的transforms</h3><ul>
<li>transforms工具箱：将特定格式的图片通过转化输出图片变化结果<ul>
<li><code>transforms.ToTensor</code>：将图片或<code>numpy.ndarray</code>数据转化为<code>Tensor</code>数据</li>
<li><code>ToPILImage</code>：将Tensor数据类型转化为ndarray数据类型或PIL数据类型</li>
<li><code>transforms.Normalize</code>：图片的归一化，输入均值列表、标准差列表，列表长度为通道数</li>
<li><code>Resize</code>：设计图片的尺寸，若给定两个参数，则进行裁剪，若输入一个参数，则等比缩放，参数以元组的形式</li>
<li><code>Compose</code>：流水线的集合，数据是transforms类型，提供一个操作的列表</li>
</ul>
</li>
<li><p>Tensor数据类型</p>
<ul>
<li>Tensor数据类型中包装了神经网络的一些数据参数，因此需要将图片的文件转化为Tensor数据</li>
</ul>
</li>
<li><p>输入：PIL、Image.open()</p>
</li>
<li>输出：tensor、ToTensor()</li>
<li>作用：ndarray()、cv.imread()</li>
</ul>
<h3 id="5、Torchvision中的数据集的使用"><a href="#5、Torchvision中的数据集的使用" class="headerlink" title="5、Torchvision中的数据集的使用"></a>5、Torchvision中的数据集的使用</h3><ul>
<li>dataset</li>
<li>dataloader：数据加载器，从数据集中取数据</li>
</ul>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>PyTorch</tag>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习实践实验-LSTM与迁移学习</title>
    <url>/2023/01/21/deep-learning-test05/</url>
    <content><![CDATA[<h1 id="实验5：LSTM与迁移学习"><a href="#实验5：LSTM与迁移学习" class="headerlink" title="实验5：LSTM与迁移学习"></a>实验5：LSTM与迁移学习</h1><h3 id="1、序列预测"><a href="#1、序列预测" class="headerlink" title="1、序列预测"></a>1、序列预测</h3><p>已知一个整数序列的通项公式（自行选择），根据公式生成若干长度为5的序列做为训练集，训练一个LSTM网络，对给定的序列预测下一项的值。</p>
<p><strong>完成程度：</strong>使用函数3*x+2生成100个长度为5的序列，选择前4列作为特征，第5列作为标签，按照9训练集：1测试集对生成的数据进行划分，定义LSTM网络，包含1个LSTM和一个全连接层。使用训练集对模型进行训练，在验证集上进行验证测试。</p>
<h3 id="2、正弦函数预测"><a href="#2、正弦函数预测" class="headerlink" title="2、正弦函数预测"></a>2、正弦函数预测</h3><p>通过已知的样本数据对正弦函数进行预测，并绘制成图形。要求分别设计LSTM，GRU和RNN网络进行预测，记录三者的预测准确率并绘制图形</p>
<p><strong>完成程度：</strong>使用正弦函数生成200个长度为10的序列，选择前9列作为特征，第10列作为标签，按照3训练集：1测试集对生成的数据进行划分，分别定义RNN、LSTM、GRU网络，定义一个全连接层。分别使用三个模型在训练集上对模型进行训练，在测试集上进行验证测试。</p>
<h3 id="3、猫狗大战"><a href="#3、猫狗大战" class="headerlink" title="3、猫狗大战"></a>3、猫狗大战</h3><p>通过来自kaggle上的猫狗数据集，训练一个识别猫狗图片的分类器。要求设计一个使用ResNet18作为主干的卷积神经网络，在迁移网络时采用固定值模式，要求模型的准确率不低于90%。猫狗大战数据集训练集有25000张，猫狗各占一办。测试集12500张。</p>
<p><strong>完成程度：</strong>对训练数据进行划分，划分为训练集和测试集，其中训练集包含11250张图片，测试集包含1250张图片，随机取出一张图片查看样本图片。利用ResNet50作为基干网，定义网络模型，修改ResNet50的最后一层全连接层，再使用addmodule添加一个dropout和一个全连接层，使用交叉熵损失函数，并将模型和损失函数放入GPU中对模型开始进行训练，一共训练5个epoch，在测试集上进行测试验证，模型准确率为95.16%。</p>
<h2 id="1、序列预测-1"><a href="#1、序列预测-1" class="headerlink" title="1、序列预测"></a>1、序列预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset, DataLoader, TensorDataset<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成序列</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getSeq</span>(<span class="hljs-params">start, n</span>):<br>    x = [ <span class="hljs-number">3</span>*x+<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, start+n)]<br>    <span class="hljs-keyword">return</span> x<br><br>data = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    rnd = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">25</span>)<br>    data.append(getSeq(rnd, <span class="hljs-number">5</span>))<br>    <br>data = np.array(data)<br>data = torch.from_numpy(data)<br><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">target = data[:, -<span class="hljs-number">1</span>:].<span class="hljs-built_in">type</span>(torch.FloatTensor)<br>data = data[:, :-<span class="hljs-number">1</span>].<span class="hljs-built_in">type</span>(torch.FloatTensor)<br><br>train_x = data[:<span class="hljs-number">90</span>]<br>train_y = target[:<span class="hljs-number">90</span>]<br>test_x = data[<span class="hljs-number">90</span>:]<br>test_y = target[<span class="hljs-number">90</span>:]<br><br>train_dataset = TensorDataset(train_x, train_y)<br>test_dataset = TensorDataset(test_x, test_y)<br>train_loader = DataLoader(dataset=train_dataset, batch_size=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>)<br>test_loader = DataLoader(dataset=test_dataset, batch_size=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构建LSTM网络</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.lstm = nn.LSTM(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, batch_first=<span class="hljs-literal">True</span>)<br>        self.fc = nn.Linear(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, hidden</span>):<br>        <span class="hljs-comment"># print(hidden)</span><br>        output, hidden = self.lstm(x, hidden)<br>        output = output[:, -<span class="hljs-number">1</span>, :]<br>        output = self.fc(output)<br>        <span class="hljs-keyword">return</span> output<br>    <br>net = model()<br>loss_fn = nn.MSELoss()<br>opt = torch.optim.Adam(net.parameters(), lr=<span class="hljs-number">0.001</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练</span><br><span class="hljs-comment"># 初始化h0，c0，如果batchsize不是4，要考虑最后一个batch的样本数</span><br>h0 = torch.zeros(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>c0 = torch.zeros(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1200</span>):<br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        x, y = data<br>        <span class="hljs-comment">#print(x)</span><br>        x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># print(x.shape,h0.shape)</span><br>        <br>        pred = net(x, (h0, c0))<br>        loss = loss_fn(pred, y)<br>        <br>        opt.zero_grad()<br>        loss.backward()<br>        opt.step()<br>        <br>    <span class="hljs-keyword">if</span> epoch%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第&#x27;</span>,epoch,<span class="hljs-string">&#x27;epoch，损失为：&#x27;</span>,loss.data)<br></code></pre></td></tr></table></figure>
<pre><code>第 0 epoch，损失为： tensor(2489.9465)
第 100 epoch，损失为： tensor(1262.1434)
第 200 epoch，损失为： tensor(1057.6017)
第 300 epoch，损失为： tensor(109.3138)
第 400 epoch，损失为： tensor(167.9138)
第 500 epoch，损失为： tensor(47.4988)
第 600 epoch，损失为： tensor(0.7118)
第 700 epoch，损失为： tensor(0.6654)
第 800 epoch，损失为： tensor(0.0557)
第 900 epoch，损失为： tensor(0.0901)
第 1000 epoch，损失为： tensor(0.0679)
第 1100 epoch，损失为： tensor(0.0544)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试验证</span><br>rights=<span class="hljs-number">0</span><br>length=<span class="hljs-number">0</span><br><br><span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_loader):<br>    x, y = data<br>    x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br>    hidden = torch.zeros(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>    pred = net(x, (h0, c0))<br>    <span class="hljs-built_in">print</span>(y.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).data)<br>    <span class="hljs-built_in">print</span>(pred.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).data)<br></code></pre></td></tr></table></figure>
<pre><code>tensor([[17., 38., 83., 17., 53.]])
tensor([[16.9066, 37.6783, 82.5042, 16.9066, 52.4514]])
tensor([[29., 41., 86., 50., 86.]])
tensor([[28.9673, 40.6793, 85.1809, 49.4299, 85.1809]])
</code></pre><h2 id="2、正弦函数预测-1"><a href="#2、正弦函数预测-1" class="headerlink" title="2、正弦函数预测"></a>2、正弦函数预测</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset, DataLoader, TensorDataset<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">data = []<br>start = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>):<br>    x = [np.sin(x/<span class="hljs-number">10</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start, start+<span class="hljs-number">11</span>)]<br>    data.append(x)<br>    start = start+<span class="hljs-number">1</span><br><br>data = np.array(data)<br>data = torch.from_numpy(data)<br><br>target = data[:, -<span class="hljs-number">1</span>:].<span class="hljs-built_in">type</span>(torch.FloatTensor)<br>data = data[:, :-<span class="hljs-number">1</span>].<span class="hljs-built_in">type</span>(torch.FloatTensor)<br><br>train_x = data[:<span class="hljs-number">150</span>]<br>train_y = target[:<span class="hljs-number">150</span>]<br>test_x = data[<span class="hljs-number">150</span>:]<br>test_y = target[<span class="hljs-number">150</span>:]<br><br>train_dataset = TensorDataset(train_x, train_y)<br>test_dataset = TensorDataset(test_x, test_y)<br>train_loader = DataLoader(train_dataset, batch_size=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">True</span>)<br>test_loader = DataLoader(test_dataset, batch_size=<span class="hljs-number">5</span>, shuffle=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构建模型</span><br><span class="hljs-comment"># 构建LSTM网络</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.lstm = nn.LSTM(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, batch_first=<span class="hljs-literal">True</span>)<br>        self.cnn = nn.RNN(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, batch_first=<span class="hljs-literal">True</span>)<br>        self.gru = nn.GRU(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, batch_first=<span class="hljs-literal">True</span>)<br>        self.fc = nn.Linear(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, hidden</span>):<br>        <span class="hljs-comment"># print(hidden)</span><br>        <span class="hljs-comment">#output, hidden = self.lstm(x, hidden)</span><br>        output, hidden = self.cnn(x, hidden)<br>        <span class="hljs-comment">#output, hidden = self.gru(x, hidden)</span><br>        output = output[:, -<span class="hljs-number">1</span>, :]<br>        output = self.fc(output)<br>        <span class="hljs-keyword">return</span> output<br>    <br>net = model()<br>loss_fn = nn.MSELoss()<br>opt = torch.optim.Adam(net.parameters(), lr=<span class="hljs-number">0.001</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练</span><br><span class="hljs-comment"># 初始化h0，c0，如果batchsize不是4，要考虑最后一个batch的样本数</span><br>h0 = torch.zeros(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>c0 = torch.zeros(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500</span>):<br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        x, y = data<br>        <span class="hljs-comment">#print(x)</span><br>        x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># print(x.shape,h0.shape)</span><br>        <br>        pred = net(x, h0)<br>        loss = loss_fn(pred, y)<br>        <br>        opt.zero_grad()<br>        loss.backward()<br>        opt.step()<br>        <br>    <span class="hljs-keyword">if</span> epoch%<span class="hljs-number">50</span>==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第&#x27;</span>,epoch,<span class="hljs-string">&#x27;epoch，损失为：&#x27;</span>,loss.data)<br></code></pre></td></tr></table></figure>
<pre><code>第 0 epoch，损失为： tensor(0.2056)
第 50 epoch，损失为： tensor(0.0008)
第 100 epoch，损失为： tensor(2.5645e-05)
第 150 epoch，损失为： tensor(9.5258e-06)
第 200 epoch，损失为： tensor(1.8686e-05)
第 250 epoch，损失为： tensor(4.9946e-05)
第 300 epoch，损失为： tensor(3.0734e-06)
第 350 epoch，损失为： tensor(1.7624e-06)
第 400 epoch，损失为： tensor(2.9713e-06)
第 450 epoch，损失为： tensor(5.6524e-06)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试验证</span><br>preds = []<br><br><span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_loader):<br>    x, y = data<br>    x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">1</span>)<br>    hidden = torch.zeros(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>    pred = net(x, h0)<br>    preds.append(pred.data.numpy())<br>    <span class="hljs-built_in">print</span>(y.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).data)<br>    <span class="hljs-built_in">print</span>(pred.view(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).data, <span class="hljs-string">&#x27;\n&#x27;</span>)<br>    <br>plt.scatter(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(train_y)), train_y.data.numpy(), marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br><span class="hljs-comment">#plt.scatter(range(150, 200), test_y.data.numpy(), marker=&#x27;o&#x27;)</span><br><br>plt.scatter(<span class="hljs-built_in">range</span>(<span class="hljs-number">150</span>, <span class="hljs-number">200</span>), preds, marker=<span class="hljs-string">&#x27;s&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>
<pre><code>tensor([[-0.2879, -0.3821, -0.4724, -0.5581, -0.6381]])
tensor([[-0.2867, -0.3812, -0.4718, -0.5576, -0.6377]]) 

tensor([[-0.7118, -0.7784, -0.8371, -0.8876, -0.9291]])
tensor([[-0.7111, -0.7773, -0.8356, -0.8855, -0.9265]]) 

tensor([[-0.9614, -0.9841, -0.9969, -0.9998, -0.9927]])
tensor([[-0.9584, -0.9809, -0.9939, -0.9973, -0.9909]]) 

tensor([[-0.9756, -0.9488, -0.9126, -0.8672, -0.8132]])
tensor([[-0.9747, -0.9488, -0.9133, -0.8683, -0.8143]]) 

tensor([[-0.7510, -0.6813, -0.6048, -0.5223, -0.4346]])
tensor([[-0.7518, -0.6815, -0.6044, -0.5214, -0.4336]]) 

tensor([[-0.3425, -0.2470, -0.1490, -0.0495,  0.0504]])
tensor([[-0.3417, -0.2467, -0.1494, -0.0504,  0.0495]]) 

tensor([[0.1499, 0.2478, 0.3433, 0.4354, 0.5231]])
tensor([[0.1492, 0.2477, 0.3438, 0.4363, 0.5242]]) 

tensor([[0.6055, 0.6820, 0.7516, 0.8137, 0.8676]])
tensor([[0.6065, 0.6826, 0.7518, 0.8134, 0.8670]]) 

tensor([[0.9129, 0.9491, 0.9758, 0.9928, 0.9998]])
tensor([[0.9120, 0.9480, 0.9746, 0.9915, 0.9987]]) 

tensor([[0.9968, 0.9839, 0.9612, 0.9288, 0.8872]])
tensor([[0.9960, 0.9834, 0.9610, 0.9289, 0.8875]]) 
</code></pre><p>​    </p>
<p>​<br><img src="/2023/01/21/deep-learning-test05/output_5_1.png" class="" title="png"><br>​    </p>
<h2 id="3、猫狗大战-1"><a href="#3、猫狗大战-1" class="headerlink" title="3、猫狗大战"></a>3、猫狗大战</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> opt<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, models, transforms<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> time<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> shutil<br><br><span class="hljs-comment"># kaggle原始数据集地址</span><br>original_dataset_dir = <span class="hljs-string">&#x27;/Users/jihaipeng/PycharmProjects/深度学习实践/深度学习实验/5实验5/dogs_cats/kaggle/train&#x27;</span><br>total_num = <span class="hljs-number">12500</span>  <span class="hljs-comment">#int(len(os.listdir(original_dataset_dir)) / 2)</span><br>random_idx = np.array(<span class="hljs-built_in">range</span>(total_num))<br>np.random.shuffle(random_idx)<br><span class="hljs-comment"># 待处理的数据集地址</span><br>base_dir = <span class="hljs-string">&#x27;/Users/jihaipeng/PycharmProjects/深度学习实践/深度学习实验/5实验5/dogs_cats/kaggle/data&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(base_dir):<br>    os.mkdir(base_dir)<br><br><span class="hljs-comment"># 训练集、测试集的划分</span><br>sub_dirs = [<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>]<br>animals = [<span class="hljs-string">&#x27;cats&#x27;</span>, <span class="hljs-string">&#x27;dogs&#x27;</span>]<br>train_idx = random_idx[:<span class="hljs-built_in">int</span>(total_num * <span class="hljs-number">0.9</span>)]<br>test_idx = random_idx[<span class="hljs-built_in">int</span>(total_num * <span class="hljs-number">0.9</span>):]<br>numbers = [train_idx, test_idx]<br><span class="hljs-keyword">for</span> idx, sub_dir <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(sub_dirs):<br>    <span class="hljs-built_in">dir</span> = os.path.join(base_dir, sub_dir)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-built_in">dir</span>):<br>        os.mkdir(<span class="hljs-built_in">dir</span>)<br>    <span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals:<br>        animal_dir = os.path.join(<span class="hljs-built_in">dir</span>, animal)  <span class="hljs-comment">#</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(animal_dir):<br>            os.mkdir(animal_dir)<br>        fnames = [animal[:-<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;.&#123;&#125;.jpg&#x27;</span>.<span class="hljs-built_in">format</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> numbers[idx]]<br>        <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> fnames:<br>            src = os.path.join(original_dataset_dir, fname)<br>            dst = os.path.join(animal_dir, fname)<br>            shutil.copyfile(src, dst)<br><br>        <span class="hljs-comment"># 验证训练集、验证集、测试集的划分的照片数目</span><br>        <span class="hljs-built_in">print</span>(animal_dir + <span class="hljs-string">&#x27; total images : %d&#x27;</span> % (<span class="hljs-built_in">len</span>(os.listdir(animal_dir))))<br></code></pre></td></tr></table></figure>
<pre><code>/Users/jihaipeng/PycharmProjects/深度学习实践/深度学习实验/5实验5/dogs_cats/kaggle/data/train/cats total images : 11250
/Users/jihaipeng/PycharmProjects/深度学习实践/深度学习实验/5实验5/dogs_cats/kaggle/data/train/dogs total images : 11250
/Users/jihaipeng/PycharmProjects/深度学习实践/深度学习实验/5实验5/dogs_cats/kaggle/data/test/cats total images : 1250
/Users/jihaipeng/PycharmProjects/深度学习实践/深度学习实验/5实验5/dogs_cats/kaggle/data/test/dogs total images : 1250
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;数据准备&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始&quot;</span>)<br>train_data = datasets.ImageFolder(root=<span class="hljs-string">&quot;data/train/&quot;</span>,<br>                                  transform=transforms.Compose(<br>                                      [<br>                                          transforms.Resize([<span class="hljs-number">224</span>, <span class="hljs-number">224</span>]),<br>                                          transforms.ToTensor(),<br>                                          transforms.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>                                      ]<br>                                  ))<br></code></pre></td></tr></table></figure>
<pre><code>开始
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(train_data.class_to_idx)<br><span class="hljs-built_in">print</span>(train_data.classes)<br>index = <span class="hljs-number">11249</span><br>img = train_data[index][<span class="hljs-number">0</span>]<br>label = train_data[index][<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label&quot;</span>, label)<br>plt.imshow(img[<span class="hljs-number">0</span>, :])<br>plt.show()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;len&quot;</span>, <span class="hljs-built_in">len</span>(train_data))<br></code></pre></td></tr></table></figure>
<pre><code>&#123;&#39;cats&#39;: 0, &#39;dogs&#39;: 1&#125;
[&#39;cats&#39;, &#39;dogs&#39;]
label 0
</code></pre><img src="/2023/01/21/deep-learning-test05/output_3_1.png" class="" title="png">
<pre><code>len 22500
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">test_data = datasets.ImageFolder(root=<span class="hljs-string">&#x27;data/test/&#x27;</span>,<br>                                 transform=transforms.Compose(<br>                                     [<br>                                         transforms.Resize([<span class="hljs-number">224</span>, <span class="hljs-number">224</span>]),<br>                                         transforms.ToTensor(),<br>                                         transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>                                     ]<br>                                 ))<br>train_loader = DataLoader(train_data, batch_size=<span class="hljs-number">8</span>, shuffle=<span class="hljs-literal">True</span>)<br>test_loader = DataLoader(test_data, batch_size=<span class="hljs-number">8</span>, shuffle=<span class="hljs-literal">True</span>)<br>index = <span class="hljs-number">1253</span><br>img = test_data[index][<span class="hljs-number">0</span>].numpy()<br>label = test_data[index][<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;label&quot;</span>, label)<br>plt.imshow(img[<span class="hljs-number">0</span>, :])<br>plt.show()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;len&quot;</span>, <span class="hljs-built_in">len</span>(test_data))<br>count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2500</span>):<br>    label = test_data[i][<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> label == <span class="hljs-number">1</span>:<br>        count += <span class="hljs-number">1</span><br><br><span class="hljs-built_in">print</span>(count)<br></code></pre></td></tr></table></figure>
<pre><code>label 1
</code></pre><img src="/2023/01/21/deep-learning-test05/output_4_1.png" class="" title="png">
<pre><code>len 2500
1250
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;采用固定值方式迁移Resnet18网络&quot;&quot;&quot;</span><br>net = models.resnet18(pretrained=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> net.parameters():<br>    <span class="hljs-comment"># 把参数冻结住，反向传播时不修改</span><br>    param.requires_grad = <span class="hljs-literal">False</span><br>features = net.fc.in_features<br>net.fc = nn.Linear(features, <span class="hljs-number">2</span>)<br>loss_fn = nn.CrossEntropyLoss()<br>opt = torch.optim.SGD(net.fc.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;训练&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始训练&quot;</span>, time.ctime())<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        x, y = data<br>        pred = net(x)<br>        loss = loss_fn(pred, y)<br><br>        opt.zero_grad()<br>        loss.backward()<br>        opt.step()<br>        <span class="hljs-keyword">if</span> i % <span class="hljs-number">25</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;:.2f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i / <span class="hljs-number">28</span>), <span class="hljs-string">&#x27;%&#x27;</span>)<br>    <span class="hljs-comment"># if epoch % 2 == 0:</span><br>    <span class="hljs-built_in">print</span>(loss.data)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;训练结束&quot;</span>, time.ctime())<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;测试&quot;&quot;&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试&quot;</span>, time.ctime())<br>rights = <span class="hljs-number">0</span><br>length = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_loader):<br>    x, y = data<br><br>    pred = net(x)<br>    <span class="hljs-comment"># print(&quot;pred: &quot;, pred)</span><br>    <span class="hljs-comment"># print(&quot;y: &quot;, y)</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y)):<br>        <span class="hljs-keyword">if</span> pred[j][<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y[j] == <span class="hljs-number">0</span>:<br>            rights += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> pred[j][<span class="hljs-number">1</span>] &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> y[j] == <span class="hljs-number">1</span>:<br>            rights += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<pre><code>测试 Tue Jan  4 16:42:56 2022
正确数: 2245 准确率 89.8 %
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;正确数:&quot;</span>, rights, <span class="hljs-string">&quot;准确率&#123;:1.0f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(rights / <span class="hljs-built_in">len</span>(test_data) * <span class="hljs-number">100</span>), <span class="hljs-string">&quot;%&quot;</span>)<br></code></pre></td></tr></table></figure>
<pre><code>正确数: 2245 准确率90 %
</code></pre>]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习实践实验-卷积神经网络</title>
    <url>/2023/01/15/deep-learning-test04/</url>
    <content><![CDATA[<h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h3 id="1、手写数字识别"><a href="#1、手写数字识别" class="headerlink" title="1、手写数字识别"></a>1、手写数字识别</h3><p>  通过MNIST数据集训练得到一个手写数字分类器。要求设计一个至少包含2个卷积层和池化层的卷积神经网络。卷积核的尺寸不小于5*5，要求训后的得到的网络在测试集准确率不低于96%（要求在网络中使用dropout）</p>
<p> <strong>完成程度：</strong>获取MNIST数据集并保存，获取图片的训练集和测试集，构建卷积神经网络模型，包含2个卷积层，2个池化层，2个全连接层，在最后一个全连接前加入一个dropout层。定义模型和损失函数，并将模型和损失函数送入到GPU当中去，使用训练集训练模型，用测试集进行测试验证，最终准确率有99.35%。</p>
<h3 id="2、CIFAR-10分类网络"><a href="#2、CIFAR-10分类网络" class="headerlink" title="2、CIFAR-10分类网络"></a>2、CIFAR-10分类网络</h3><p>  通过CIFAR-10数据集训练得到一个手写数字分类器。要求设计一个至少包含2个卷积层和池化层的卷积神经网络。卷积核的尺寸统一采用3*3，要求训后的得到的网络在测试集上的准确率不低于70%（要求在网络中使用BatchNorm）</p>
<p><strong>完成程度：</strong>下载CIFAR-10实验数据集，并将其划分成训练集和测试集，查看图片的尺寸，图片尺寸为32*32，一共有3个通道，定义卷积神经网络，一共包含5个卷积层，5个BN层，3个池化层，2个全连接层，最后一个全连接层前加一个dropout层。在GPU上利用训练集训练网络模型，一共进行20测迭代，最终在测试集上进行测试验证，模型训练的准确性为78.84%。</p>
<h2 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取训练数据</span><br>train_data = datasets.MNIST(root=<span class="hljs-string">&#x27;./&#x27;</span>,<br>                      train=<span class="hljs-literal">True</span>,<br>                      transform=transforms.Compose([<br>                         transforms.ToTensor(),<br>                         transforms.Normalize([<span class="hljs-number">0.1307</span>, ], [<span class="hljs-number">0.3081</span>, ])<br>                      ]),<br>                      download=<span class="hljs-literal">True</span><br>                     )<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> TensorDataset, DataLoader, Dataset<br>train_loader = DataLoader(dataset=train_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br><br>test_data = datasets.MNIST(root=<span class="hljs-string">&#x27;./&#x27;</span>,<br>                      train=<span class="hljs-literal">True</span>,<br>                      transform=transforms.Compose([<br>                         transforms.ToTensor(),<br>                         transforms.Normalize([<span class="hljs-number">0.1307</span>, ], [<span class="hljs-number">0.3081</span>, ])<br>                      ])<br>                     )<br><br><br>test_loader = DataLoader(dataset=test_data, batch_size=<span class="hljs-number">64</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看图片示例</span><br><span class="hljs-built_in">print</span>(train_data[<span class="hljs-number">50</span>][<span class="hljs-number">0</span>].numpy().shape)<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>img = train_data[<span class="hljs-number">50</span>][<span class="hljs-number">0</span>].numpy()<br>label = train_data[<span class="hljs-number">50</span>][<span class="hljs-number">1</span>]<br><br>plt.imshow(img[<span class="hljs-number">0</span>, :])<br>plt.show()<br></code></pre></td></tr></table></figure>
<pre><code>(1, 28, 28)
</code></pre><img src="/2023/01/15/deep-learning-test04/output_5_1.png" class="" title="png">
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 网络构建</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)<br>        self.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>)<br>        self.fc1 = nn.Linear((<span class="hljs-number">28</span>*<span class="hljs-number">28</span>)//(<span class="hljs-number">4</span>*<span class="hljs-number">4</span>)*<span class="hljs-number">8</span>, <span class="hljs-number">512</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-comment"># 1*28*28, 4*28*28</span><br>        x = self.conv1(x)<br>        x = F.relu(x)<br>        <span class="hljs-comment"># 4*14*14</span><br>        x = self.pool(x)<br>        <br>        <span class="hljs-comment"># 8*14*14</span><br>        x = self.conv2(x)<br>        x = F.relu(x)<br>        <span class="hljs-comment"># 8*7*7</span><br>        x = self.pool(x)<br>        <br>        x = x.view(-<span class="hljs-number">1</span>, (<span class="hljs-number">28</span>*<span class="hljs-number">28</span>)//(<span class="hljs-number">4</span>*<span class="hljs-number">4</span>)*<span class="hljs-number">8</span>)<br>        x = self.fc1(x)<br>        x = F.relu(x)<br>        <br>        x = F.dropout(x, training=self.training)<br>        x = self.fc2(x)<br>        <span class="hljs-keyword">return</span> x<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">feature_maps</span>(<span class="hljs-params">self, x</span>):<br>        map1 = self.conv1(x)<br>        map1 = F.relu(map1)<br>        map2 = self.pool(map1)<br>        map2 = self.conv2(map2)<br>        map2 = F.relu(map2)<br>        <span class="hljs-keyword">return</span> (map1, map2)<br>    <br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">net = model()<br>net = net.cuda()<br>loss_fn = nn.CrossEntropyLoss()<br>loss_fn = loss_fn.cuda()<br>opt = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>    <span class="hljs-keyword">for</span> i,data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        x, y = data<br>        net.train()<br>        pred = net(x.cuda())<br>        loss = loss_fn(pred, y.cuda())<br>        <br>        opt.zero_grad()<br>        loss.backward()<br>        opt.step()<br>    <span class="hljs-built_in">print</span>(epoch, <span class="hljs-string">&quot;损失值:&quot;</span>,loss)<br></code></pre></td></tr></table></figure>
<pre><code>0 损失值: tensor(0.1942, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
1 损失值: tensor(0.3168, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
2 损失值: tensor(0.0090, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
3 损失值: tensor(0.2042, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
4 损失值: tensor(0.0557, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
5 损失值: tensor(0.1490, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
6 损失值: tensor(0.0090, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
7 损失值: tensor(0.0358, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
8 损失值: tensor(0.1654, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
9 损失值: tensor(0.0103, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
10 损失值: tensor(0.0287, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
11 损失值: tensor(0.0289, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
12 损失值: tensor(0.1634, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
13 损失值: tensor(0.0111, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
14 损失值: tensor(0.0598, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
15 损失值: tensor(0.0598, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
16 损失值: tensor(0.0384, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
17 损失值: tensor(0.0041, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
18 损失值: tensor(0.0288, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
19 损失值: tensor(0.0030, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试验证</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rightness</span>(<span class="hljs-params">predictions, labels</span>):<br>    pred = torch.<span class="hljs-built_in">max</span>(predictions.data, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>    rights = pred.eq(labels.data.view_as(pred)).<span class="hljs-built_in">sum</span>()<br>    <span class="hljs-keyword">return</span> rights, <span class="hljs-built_in">len</span>(labels)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 验证测试</span><br>rights = <span class="hljs-number">0</span><br>length = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_loader):<br>    x, y = data<br>    net.<span class="hljs-built_in">eval</span>()<br>    pred = net(x.cuda())<br>    rights = rights + rightness(pred, y.cuda())[<span class="hljs-number">0</span>]<br>    length = length + rightness(pred, y.cuda())[<span class="hljs-number">1</span>]<br><br><span class="hljs-built_in">print</span>(rights, length, rights/length)<br></code></pre></td></tr></table></figure>
<pre><code>tensor(59609, device=&#39;cuda:0&#39;) 60000 tensor(0.9935, device=&#39;cuda:0&#39;)
</code></pre><h2 id="CIFAR-10分类网络"><a href="#CIFAR-10分类网络" class="headerlink" title="CIFAR-10分类网络"></a>CIFAR-10分类网络</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader, Dataset, TensorDataset<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取训练数据</span><br>train_data = datasets.CIFAR10(root=<span class="hljs-string">&#x27;./&#x27;</span>,<br>                      train=<span class="hljs-literal">True</span>,<br>                      transform=transforms.Compose([<br>                         transforms.ToTensor(),<br>                         transforms.Normalize([<span class="hljs-number">0.1307</span>, ], [<span class="hljs-number">0.3081</span>, ])<br>                      ]),<br>                      download=<span class="hljs-literal">True</span><br>                     )<br></code></pre></td></tr></table></figure>
<pre><code>Files already downloaded and verified
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取训练数据</span><br>test_data = datasets.CIFAR10(root=<span class="hljs-string">&#x27;./&#x27;</span>,<br>                      train=<span class="hljs-literal">False</span>,<br>                      transform=transforms.Compose([<br>                         transforms.ToTensor(),<br>                         transforms.Normalize([<span class="hljs-number">0.1307</span>, ], [<span class="hljs-number">0.3081</span>, ])<br>                      ])<br>                     )<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据加载器</span><br>train_dataset = DataLoader(train_data, batch_size=<span class="hljs-number">4</span>, shuffle=<span class="hljs-literal">True</span>)<br>test_dataset = DataLoader(test_data, batch_size=<span class="hljs-number">4</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 随机查看一张图片</span><br><span class="hljs-built_in">print</span>(np.random.randint(<span class="hljs-number">3000</span>))<br><span class="hljs-built_in">print</span>(train_data[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].shape)<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>img = train_data[<span class="hljs-number">50</span>][<span class="hljs-number">0</span>].numpy()<br><br>plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">12</span>))<br><span class="hljs-comment"># 在plt.imshow()输入彩色图像时，需要对通道进行转化</span><br><span class="hljs-comment"># pytorch中时(3, height, width)，imshow中是（height, width, 3）</span><br>plt.imshow(img.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>))<br></code></pre></td></tr></table></figure>
<pre><code>638
torch.Size([3, 32, 32])


Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers).





&lt;matplotlib.image.AxesImage at 0x27e882a9c70&gt;
</code></pre><p>​<br><img src="/2023/01/15/deep-learning-test04/output_4_3.png" class="" title="png"><br>​    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义网络</span><br><span class="hljs-comment"># 要求至少包含5个卷积层和池化层</span><br><span class="hljs-comment"># 卷积核的尺寸统一为3*3</span><br><span class="hljs-comment"># 要求网络中使用BatchNorm</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 图片尺寸为[3, 32, 32]</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        self.conv3 = nn.Conv2d(<span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        self.conv4 = nn.Conv2d(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        self.conv5 = nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>)<br>        self.pool1 = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>        self.pool2 = nn.AvgPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>        self.dropout = nn.Dropout2d(<span class="hljs-number">0.5</span>)<br>        self.batch_norm1 = nn.BatchNorm2d(<span class="hljs-number">4</span>)<br>        self.batch_norm2 = nn.BatchNorm2d(<span class="hljs-number">8</span>)<br>        self.batch_norm3 = nn.BatchNorm2d(<span class="hljs-number">16</span>)<br>        self.batch_norm4 = nn.BatchNorm2d(<span class="hljs-number">32</span>)<br>        self.batch_norm5 = nn.BatchNorm2d(<span class="hljs-number">64</span>)<br>        self.fc1 = nn.Linear(<span class="hljs-number">64</span>*<span class="hljs-number">4</span>*<span class="hljs-number">4</span>, <span class="hljs-number">512</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">512</span>, <span class="hljs-number">10</span>)<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-comment"># 第一个卷积层，输入3*32*32，输出4*32*32</span><br>        x = self.conv1(x)<br>        x = self.batch_norm1(x)<br>        x = F.relu(x)<br>        <br>        <span class="hljs-comment"># 第二个卷积层，输入4*32*32，输出8*32*32</span><br>        x = self.conv2(x)<br>        x = self.batch_norm2(x)<br>        x = F.relu(x)<br>        <br>        <span class="hljs-comment"># 第三个卷积层，输入8*32*32，输出16*32*32</span><br>        x = self.conv3(x)<br>        x = F.relu(x)<br>        x = self.batch_norm3(x)<br>        <span class="hljs-comment"># 输入16*32*32，输出16*16*16</span><br>        x = self.pool1(x)<br>        <br>        <span class="hljs-comment"># 第四个卷积层，输入16*16*16，输出32*16*16</span><br>        x = self.conv4(x)<br>        x = self.batch_norm4(x)<br>        x = F.relu(x)<br>        <span class="hljs-comment"># 输入32*16*16，输出32*8*8</span><br>        x = self.pool2(x)<br>        <br>        <span class="hljs-comment"># 第五个卷积层，输入32*8*8，输出64*8*8</span><br>        x = self.conv5(x)<br>        x = self.batch_norm5(x)<br>        x = F.relu(x)<br>        <span class="hljs-comment"># 输入64*8*8，输出64*4*4</span><br>        x = self.pool1(x)<br>        <br>        <span class="hljs-comment"># 全连接层</span><br>        x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">64</span>*<span class="hljs-number">4</span>*<span class="hljs-number">4</span>)<br>        x = self.fc1(x)<br>        x = F.relu(x)<br>        <br>        <span class="hljs-comment"># 随机失活20%参数</span><br>        x = self.dropout(x)<br>        x = self.fc2(x)<br>        <br>        <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment"># 使用GPU</span><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>        <br>net = model()<br><span class="hljs-built_in">print</span>(net)<br>net.to(device)<br><span class="hljs-comment"># 使用交叉熵损失函数</span><br>loss_fn = nn.CrossEntropyLoss()<br>loss_fn.to(device)<br><span class="hljs-comment"># 最优化方法</span><br>opt = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br></code></pre></td></tr></table></figure>
<pre><code>model(
  (conv1): Conv2d(3, 4, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv2): Conv2d(4, 8, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv3): Conv2d(8, 16, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv4): Conv2d(16, 32, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (conv5): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))
  (pool1): MaxPool2d(kernel_size=2, stride=2, padding=0, dilation=1, ceil_mode=False)
  (pool2): AvgPool2d(kernel_size=2, stride=2, padding=0)
  (dropout): Dropout2d(p=0.5, inplace=False)
  (batch_norm1): BatchNorm2d(4, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  (batch_norm2): BatchNorm2d(8, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  (batch_norm3): BatchNorm2d(16, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  (batch_norm4): BatchNorm2d(32, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  (batch_norm5): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
  (fc1): Linear(in_features=1024, out_features=512, bias=True)
  (fc2): Linear(in_features=512, out_features=10, bias=True)
)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchinfo <span class="hljs-keyword">import</span> summary<br>summary(net, input_size=(<span class="hljs-number">64</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>))<br></code></pre></td></tr></table></figure>
<pre><code>D:\02_soft\anaconda3\envs\pytorch\lib\site-packages\torch\nn\functional.py:1331: UserWarning: dropout2d: Received a 2-D input to dropout2d, which is deprecated and will result in an error in a future release. To retain the behavior and silence this warning, please use dropout instead. Note that dropout2d exists to provide channel-wise dropout on inputs with 2 spatial dimensions, a channel dimension, and an optional batch dimension (i.e. 3D or 4D inputs).
  warnings.warn(warn_msg)





==========================================================================================
Layer (type:depth-idx)                   Output Shape              Param #
==========================================================================================
model                                    [64, 10]                  --
├─Conv2d: 1-1                            [64, 4, 32, 32]           112
├─BatchNorm2d: 1-2                       [64, 4, 32, 32]           8
├─Conv2d: 1-3                            [64, 8, 32, 32]           296
├─BatchNorm2d: 1-4                       [64, 8, 32, 32]           16
├─Conv2d: 1-5                            [64, 16, 32, 32]          1,168
├─BatchNorm2d: 1-6                       [64, 16, 32, 32]          32
├─MaxPool2d: 1-7                         [64, 16, 16, 16]          --
├─Conv2d: 1-8                            [64, 32, 16, 16]          4,640
├─BatchNorm2d: 1-9                       [64, 32, 16, 16]          64
├─AvgPool2d: 1-10                        [64, 32, 8, 8]            --
├─Conv2d: 1-11                           [64, 64, 8, 8]            18,496
├─BatchNorm2d: 1-12                      [64, 64, 8, 8]            128
├─MaxPool2d: 1-13                        [64, 64, 4, 4]            --
├─Linear: 1-14                           [64, 512]                 524,800
├─Dropout2d: 1-15                        [64, 512]                 --
├─Linear: 1-16                           [64, 10]                  5,130
==========================================================================================
Total params: 554,890
Trainable params: 554,890
Non-trainable params: 0
Total mult-adds (M): 289.00
==========================================================================================
Input size (MB): 0.79
Forward/backward pass size (MB): 42.21
Params size (MB): 2.22
Estimated Total Size (MB): 45.22
==========================================================================================
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开始训练</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_dataset):<br>        x, y = data<br>        x = x.to(device)<br>        y = y.to(device)<br>        net.train()<br>        pred = net(x)<br>        loss = loss_fn(pred, y)<br><br>        opt.zero_grad()<br>        loss.backward()<br>        opt.step()<br>    <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第&#x27;</span>, epoch, <span class="hljs-string">&#x27;个epoch，loss为：&#x27;</span>, loss)<br></code></pre></td></tr></table></figure>
<pre><code>D:\02_soft\anaconda3\envs\pytorch\lib\site-packages\torch\nn\functional.py:1331: UserWarning: dropout2d: Received a 2-D input to dropout2d, which is deprecated and will result in an error in a future release. To retain the behavior and silence this warning, please use dropout instead. Note that dropout2d exists to provide channel-wise dropout on inputs with 2 spatial dimensions, a channel dimension, and an optional batch dimension (i.e. 3D or 4D inputs).
  warnings.warn(warn_msg)


第 0 个epoch，loss为： tensor(1.4621, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 1 个epoch，loss为： tensor(1.1412, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 2 个epoch，loss为： tensor(0.7093, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 3 个epoch，loss为： tensor(1.1387, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 4 个epoch，loss为： tensor(1.1270, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 5 个epoch，loss为： tensor(0.1355, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 6 个epoch，loss为： tensor(2.1455, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 7 个epoch，loss为： tensor(0.2261, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 8 个epoch，loss为： tensor(0.3833, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 9 个epoch，loss为： tensor(1.3244, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 10 个epoch，loss为： tensor(0.1666, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 11 个epoch，loss为： tensor(0.8256, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 12 个epoch，loss为： tensor(0.8673, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 13 个epoch，loss为： tensor(0.0255, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 14 个epoch，loss为： tensor(0.8387, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 15 个epoch，loss为： tensor(0.1123, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 16 个epoch，loss为： tensor(0.0009, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 17 个epoch，loss为： tensor(0.0298, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 18 个epoch，loss为： tensor(0.5178, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
第 19 个epoch，loss为： tensor(0.3033, device=&#39;cuda:0&#39;, grad_fn=&lt;NllLossBackward0&gt;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试验证</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rightness</span>(<span class="hljs-params">predictions, labels</span>):<br>    pred = torch.<span class="hljs-built_in">max</span>(predictions.data, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>    rights = pred.eq(labels.data.view_as(pred)).<span class="hljs-built_in">sum</span>()<br>    <span class="hljs-keyword">return</span> rights, <span class="hljs-built_in">len</span>(labels)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 验证测试</span><br>rights = <span class="hljs-number">0</span><br>length = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_dataset):<br>    x, y = data<br>    x = x.to(device)<br>    y = y.to(device)<br>    net.<span class="hljs-built_in">eval</span>()<br>    pred = net(x)<br>    rights = rights + rightness(pred, y)[<span class="hljs-number">0</span>]<br>    length = length + rightness(pred, y)[<span class="hljs-number">1</span>]<br><br><span class="hljs-built_in">print</span>(rights, length, rights/length)<br></code></pre></td></tr></table></figure>
<pre><code>tensor(7884, device=&#39;cuda:0&#39;) 10000 tensor(0.7884, device=&#39;cuda:0&#39;)
</code></pre>]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习实践实验-SoftMax回归</title>
    <url>/2023/01/08/deep-learning-test03/</url>
    <content><![CDATA[<h1 id="SoftMax回归"><a href="#SoftMax回归" class="headerlink" title="SoftMax回归"></a>SoftMax回归</h1><h3 id="1、聚类和分类"><a href="#1、聚类和分类" class="headerlink" title="1、聚类和分类"></a>1、聚类和分类</h3><p>通过sklearn库提供的聚类算法生成K类数据，以这些数据做为数据集训练神经网络，利用softmax层和交叉熵损失函数对数据进行分类。聚类参数要求K&gt;3，数据样本不少于1000，其他参数参考课件。对聚类后的数据按9：1的原则划分训练集和测试集，利用在训练集上训练得到的模型对测试集上的数据进行验证，要求模型的准确率不低于99%。</p>
<p><strong>完成程度</strong>：使用sklearn.datasets中的make_blobs函数生成1200个样本数据，样本种类为4，样本中心分别为[-5, 5], [0, -2], [4, 8], [7, 3]，方差分别为[1.5,1.5,1.2,1]，每样样本数为300个，对样本数据进行划分，按照9训练集：1测试集的比例进行划分，构建网络，使用交叉熵损失函数，使用训练集对模型进行训练，在测试集上完成测试验证。</p>
<h3 id="2、鸢尾花分类"><a href="#2、鸢尾花分类" class="headerlink" title="2、鸢尾花分类"></a>2、鸢尾花分类</h3><p>  Iris数据集包含150个样本，对应数据集的每行数据。每行数据包含每个样本的四个特征和样本的类别信息，iris数据集是用来给鸢尾花做分类的数据集，每个样本包含了花萼长度、花萼宽度、花瓣长度、花瓣宽度四个特征，请用神经网络训练一个分类器，分类器可以通过样本的四个特征来判断样本属于山鸢尾花、变色鸢尾还是维吉尼亚鸢尾。数据集文件iris.csv。要求模型的准确率不低于99%。</p>
<p><strong>完成程度</strong>：加载鸢尾花数据集iris.csv，查看样本数据，对数据进行标准化处理，将使用到的数据划分为训练集和测试集，搭建网络模型，使用交叉熵损失函数，使用训练集对模型进行训练，在测试集上完成测试验证。</p>
<h2 id="聚类和分类"><a href="#聚类和分类" class="headerlink" title="聚类和分类"></a>聚类和分类</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader, TensorDataset, Dataset<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_blobs<br><br>data, target = make_blobs(n_samples=<span class="hljs-number">1200</span>, n_features=<span class="hljs-number">2</span>, centers=[[-<span class="hljs-number">5</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">0</span>, -<span class="hljs-number">2</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">8</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">3</span>]], cluster_std=[<span class="hljs-number">1.5</span>,<span class="hljs-number">1.5</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">1</span>])<br>plt.scatter(data[:, <span class="hljs-number">0</span>], data[:, <span class="hljs-number">1</span>], c=target, marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>
<p>​<br><img src="/2023/01/08/deep-learning-test03/output_1_0.png" class="" title="png"><br>​    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据准备</span><br><span class="hljs-comment"># 将训练集和测试集按照9：1的比例进行划分</span><br><span class="hljs-comment"># 一共1200个数据，1080个训练集，120个测试集</span><br>data = torch.from_numpy(data)<br>data = data.<span class="hljs-built_in">type</span>(torch.FloatTensor)<br>target = torch.from_numpy(target)<br>target = target.<span class="hljs-built_in">type</span>(torch.LongTensor)<br><br>train_x = data[:<span class="hljs-number">1080</span>]<br>train_y = target[:<span class="hljs-number">1080</span>]<br><br>test_x = data[<span class="hljs-number">1080</span>:]<br>test_y = target[<span class="hljs-number">1080</span>:]<br><br><span class="hljs-comment"># 训练数据集</span><br>train_dataset = TensorDataset(train_x, train_y)<br><span class="hljs-comment"># 测试数据集</span><br>test_dataset = TensorDataset(test_x, test_y)<br><br><span class="hljs-comment"># 加载器</span><br>train_loader = DataLoader(dataset=train_dataset,batch_size=<span class="hljs-number">32</span>,shuffle=<span class="hljs-literal">True</span>)<br>test_loader = DataLoader(dataset=test_dataset,batch_size=<span class="hljs-number">16</span>,shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构建网络</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.hidden1 = nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>)<br>        self.out = nn.Linear(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.hidden1(x)<br>        x = F.relu(x)<br>        x = self.out(x)<br>        <span class="hljs-keyword">return</span> x<br><br>net = model()<br><span class="hljs-comment"># 交叉熵损失函数</span><br>loss_fn = nn.CrossEntropyLoss()<br><span class="hljs-comment"># 优化器</span><br>opt = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.01</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader, TensorDataset, Dataset<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.hidden1 = nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>)<br>        self.out = nn.liner(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.hidden1(x)<br>        x = F.relu(x)<br>        x = self.out(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">net = model()<br><br>loss_fn = nn.MSELoss()<br>opt = opt<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        x, y = data<br>        pred = net(x)<br>        loss = loss_fn(pred, y)<br>        <br>        opt.zero_grad()<br>        loss.backward()<br>        opt.step()<br>        <br>    <span class="hljs-keyword">if</span>(epoch%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>):<br>        <span class="hljs-built_in">print</span>(loss)<br></code></pre></td></tr></table></figure>
<pre><code>tensor(1.2986, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0348, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0084, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0275, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0479, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0559, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0055, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0015, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0134, grad_fn=&lt;NllLossBackward0&gt;)
tensor(0.0884, grad_fn=&lt;NllLossBackward0&gt;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rightness</span>(<span class="hljs-params">predictions, labels</span>):<br>    pred = torch.<span class="hljs-built_in">max</span>(predictions.data, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>    rights = pred.eq(labels.data.view_as(pred)).<span class="hljs-built_in">sum</span>()<br>    <span class="hljs-keyword">return</span> rights, <span class="hljs-built_in">len</span>(labels)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对测试集进行预测</span><br><span class="hljs-comment"># 将测试集绘制出来</span><br><span class="hljs-built_in">print</span>(test_x.shape, test_y.shape, test_x[<span class="hljs-number">2</span>], target)<br>plt.scatter(test_x[:, <span class="hljs-number">0</span>], test_y, c=target[<span class="hljs-number">1080</span>:], marker=<span class="hljs-string">&#x27;o&#x27;</span>)<br><br>rights = <span class="hljs-number">0</span><br>length = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_loader):<br>    x, y = data<br>    pred = net(x)<br>    rights = rights + rightness(pred, y)[<span class="hljs-number">0</span>]<br>    length = length + rightness(pred, y)[<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(y)<br>    <span class="hljs-built_in">print</span>(torch.<span class="hljs-built_in">max</span>(pred.data, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(rights, length, rights/length)<br></code></pre></td></tr></table></figure>
<pre><code>torch.Size([120, 2]) torch.Size([120]) tensor([4.7586, 6.5412]) tensor([1, 0, 1,  ..., 0, 0, 1])
tensor([0, 0, 2, 1, 1, 0, 1, 0, 3, 0, 1, 3, 3, 1, 1, 1])
tensor([0, 0, 2, 1, 1, 0, 1, 0, 3, 0, 1, 3, 3, 1, 1, 1]) 

tensor([0, 1, 2, 1, 2, 0, 0, 1, 2, 2, 3, 2, 1, 3, 2, 2])
tensor([0, 1, 2, 1, 2, 0, 0, 1, 2, 2, 3, 2, 0, 3, 2, 2]) 

tensor([0, 0, 3, 0, 3, 0, 2, 0, 2, 1, 3, 0, 3, 2, 0, 0])
tensor([0, 0, 3, 0, 3, 0, 2, 0, 2, 1, 3, 0, 3, 2, 0, 0]) 

tensor([3, 3, 0, 0, 2, 0, 0, 3, 0, 3, 3, 1, 2, 2, 3, 3])
tensor([3, 3, 0, 0, 2, 0, 0, 3, 0, 3, 3, 1, 2, 2, 3, 3]) 

tensor([0, 0, 1, 0, 1, 0, 3, 2, 1, 1, 1, 2, 2, 2, 0, 0])
tensor([0, 0, 1, 0, 1, 0, 3, 2, 1, 1, 1, 2, 2, 2, 0, 0]) 

tensor([2, 1, 1, 0, 3, 2, 2, 1, 1, 1, 1, 0, 2, 2, 0, 2])
tensor([2, 1, 1, 0, 3, 2, 2, 1, 1, 1, 1, 0, 2, 2, 0, 2]) 

tensor([0, 1, 3, 2, 2, 2, 3, 1, 1, 0, 3, 2, 0, 3, 1, 0])
tensor([0, 1, 3, 2, 2, 2, 3, 1, 1, 0, 3, 2, 0, 3, 1, 0]) 

tensor([2, 1, 2, 1, 1, 1, 0, 3])
tensor([2, 1, 2, 1, 1, 1, 0, 3]) 

tensor(119) 120 tensor(0.9917)
</code></pre><img src="/2023/01/08/deep-learning-test03/output_9_1.png" class="" title="png">
<h2 id="鸢尾花分类"><a href="#鸢尾花分类" class="headerlink" title="鸢尾花分类"></a>鸢尾花分类</h2><ul>
<li>通过花萼长度，花萼宽度，花瓣长度，花瓣宽度4个特征</li>
<li>使用神经网络训练一个分类器对数据集iris.csv进行分类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入相关函数</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset, DataLoader, TensorDataset<br><span class="hljs-keyword">from</span> sklearn.utils <span class="hljs-keyword">import</span> shuffle<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据预处理</span><br>data = pd.read_csv(<span class="hljs-string">&#x27;iris.csv&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)):<br>    <span class="hljs-keyword">if</span> data.loc[i, <span class="hljs-string">&#x27;Species&#x27;</span>] == <span class="hljs-string">&#x27;setosa&#x27;</span>:<br>        data.loc[i, <span class="hljs-string">&#x27;Species&#x27;</span>] = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> data.loc[i, <span class="hljs-string">&#x27;Species&#x27;</span>] == <span class="hljs-string">&#x27;versicolor&#x27;</span>:<br>        data.loc[i, <span class="hljs-string">&#x27;Species&#x27;</span>] = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> data.loc[i, <span class="hljs-string">&#x27;Species&#x27;</span>] == <span class="hljs-string">&#x27;virginica&#x27;</span>:<br>        data.loc[i, <span class="hljs-string">&#x27;Species&#x27;</span>] = <span class="hljs-number">2</span><br><br>data.head()<br></code></pre></td></tr></table></figure>
<p>&lt;/style&gt;</p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Unnamed: 0</th>
      <th>Sepal.Length</th>
      <th>Sepal.Width</th>
      <th>Petal.Length</th>
      <th>Petal.Width</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2</td>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>3</td>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4</td>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5</td>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>&lt;/div&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">data = data.drop(<span class="hljs-string">&#x27;Unnamed: 0&#x27;</span>, axis=<span class="hljs-number">1</span>)<br>data.head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }


    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Sepal.Length</th>
      <th>Sepal.Width</th>
      <th>Petal.Length</th>
      <th>Petal.Width</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.1</td>
      <td>3.5</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.9</td>
      <td>3.0</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.7</td>
      <td>3.2</td>
      <td>1.3</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.6</td>
      <td>3.1</td>
      <td>1.5</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.0</td>
      <td>3.6</td>
      <td>1.4</td>
      <td>0.2</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

</div>




<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">data = shuffle(data)<br><span class="hljs-built_in">print</span>(data.head())<br>data.index = <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data))<br>data.head()<br></code></pre></td></tr></table></figure>
<pre><code>     Sepal.Length  Sepal.Width  Petal.Length  Petal.Width Species
62            6.0          2.2           4.0          1.0       1
122           7.7          2.8           6.7          2.0       2
130           7.4          2.8           6.1          1.9       2
125           7.2          3.2           6.0          1.8       2
112           6.8          3.0           5.5          2.1       2
</code></pre><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Sepal.Length</th>
      <th>Sepal.Width</th>
      <th>Petal.Length</th>
      <th>Petal.Width</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>6.0</td>
      <td>2.2</td>
      <td>4.0</td>
      <td>1.0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>7.7</td>
      <td>2.8</td>
      <td>6.7</td>
      <td>2.0</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>7.4</td>
      <td>2.8</td>
      <td>6.1</td>
      <td>1.9</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>7.2</td>
      <td>3.2</td>
      <td>6.0</td>
      <td>1.8</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td>6.8</td>
      <td>3.0</td>
      <td>5.5</td>
      <td>2.1</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p>&lt;/div&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将数据进行标准化处理</span><br>col_titles = [<span class="hljs-string">&#x27;Sepal.Length&#x27;</span>, <span class="hljs-string">&#x27;Sepal.Width&#x27;</span>, <span class="hljs-string">&#x27;Petal.Length&#x27;</span>, <span class="hljs-string">&#x27;Petal.Width&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> col_titles:<br>    mean, std = data[i].mean(), data[i].std()<br>    data[i] = (data[i]-mean)/std<br><br>data.head()<br></code></pre></td></tr></table></figure>
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }


    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }

</style>

<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Sepal.Length</th>
      <th>Sepal.Width</th>
      <th>Petal.Length</th>
      <th>Petal.Width</th>
      <th>Species</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.189196</td>
      <td>-1.966964</td>
      <td>0.137087</td>
      <td>-0.261511</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2.242172</td>
      <td>-0.590395</td>
      <td>1.666574</td>
      <td>1.050416</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1.879882</td>
      <td>-0.590395</td>
      <td>1.326688</td>
      <td>0.919223</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.638355</td>
      <td>0.327318</td>
      <td>1.270040</td>
      <td>0.788031</td>
      <td>2</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1.155302</td>
      <td>-0.131539</td>
      <td>0.986802</td>
      <td>1.181609</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

</div>




<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据集处理</span><br><span class="hljs-comment"># 划分训练集和测试集</span><br>train_data = data[:-<span class="hljs-number">32</span>]<br>train_x = train_data.drop([<span class="hljs-string">&#x27;Species&#x27;</span>], axis=<span class="hljs-number">1</span>).values<br>train_y = train_data[<span class="hljs-string">&#x27;Species&#x27;</span>].values.astype(<span class="hljs-built_in">int</span>)<br>train_x = torch.from_numpy(train_x).<span class="hljs-built_in">type</span>(torch.FloatTensor)<br>train_y = torch.from_numpy(train_y).<span class="hljs-built_in">type</span>(torch.LongTensor)<br><br>test_data = data[-<span class="hljs-number">32</span>:]<br>test_x = test_data.drop([<span class="hljs-string">&#x27;Species&#x27;</span>], axis=<span class="hljs-number">1</span>).values<br>test_y = test_data[<span class="hljs-string">&#x27;Species&#x27;</span>].values.astype(<span class="hljs-built_in">int</span>)<br>test_x = torch.from_numpy(test_x).<span class="hljs-built_in">type</span>(torch.FloatTensor)<br>test_y = torch.from_numpy(test_y).<span class="hljs-built_in">type</span>(torch.LongTensor)<br><br>train_dataset = TensorDataset(train_x, train_y)<br>test_dataset = TensorDataset(test_x, test_y)<br>train_loader = DataLoader(dataset=train_dataset, batch_size=<span class="hljs-number">16</span>, shuffle=<span class="hljs-literal">True</span>)<br>test_loader = DataLoader(dataset=test_dataset, batch_size=<span class="hljs-number">16</span>, shuffle=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构建神经网络</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.hidden1 = nn.Linear(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>        self.out = nn.Linear(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.hidden1(x)<br>        x = F.relu(x)<br>        x = self.out(x)<br>        <span class="hljs-keyword">return</span> x<br>    <br>net = model()<br>loss_fn = nn.CrossEntropyLoss()<br>opt = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.05</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        x, y = data<br>        pred = net(x)<br>        loss = loss_fn(pred, y)<br>        <br>        opt.zero_grad()<br>        loss.backward()<br>        opt.step()<br>        <br>    <span class="hljs-keyword">if</span> epoch%<span class="hljs-number">1000</span>==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;第&#x27;</span>, epoch, <span class="hljs-string">&#x27;个epoch，损失值为：&#x27;</span>, loss)<br></code></pre></td></tr></table></figure>
<pre><code>第 0 个epoch，损失值为： tensor(1.0210, grad_fn=&lt;NllLossBackward0&gt;)
第 1000 个epoch，损失值为： tensor(0.0007, grad_fn=&lt;NllLossBackward0&gt;)
第 2000 个epoch，损失值为： tensor(0.0010, grad_fn=&lt;NllLossBackward0&gt;)
第 3000 个epoch，损失值为： tensor(0.0004, grad_fn=&lt;NllLossBackward0&gt;)
第 4000 个epoch，损失值为： tensor(0.0008, grad_fn=&lt;NllLossBackward0&gt;)
第 5000 个epoch，损失值为： tensor(0.0007, grad_fn=&lt;NllLossBackward0&gt;)
第 6000 个epoch，损失值为： tensor(0.0010, grad_fn=&lt;NllLossBackward0&gt;)
第 7000 个epoch，损失值为： tensor(0.0001, grad_fn=&lt;NllLossBackward0&gt;)
第 8000 个epoch，损失值为： tensor(0.0006, grad_fn=&lt;NllLossBackward0&gt;)
第 9000 个epoch，损失值为： tensor(0.0001, grad_fn=&lt;NllLossBackward0&gt;)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">rightness</span>(<span class="hljs-params">predictions, labels</span>):<br>    pred = torch.<span class="hljs-built_in">max</span>(predictions.data, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>]<br>    rights = pred.eq(labels.data.view_as(pred)).<span class="hljs-built_in">sum</span>()<br>    <span class="hljs-keyword">return</span> rights, <span class="hljs-built_in">len</span>(labels)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 验证测试</span><br>net = net.cpu()<br>rights = <span class="hljs-number">0</span><br>length = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_loader):<br>    x, y = data<br>    pred = net(x)<br>    rights = rights + rightness(pred, y)[<span class="hljs-number">0</span>]<br>    length = length + rightness(pred, y)[<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(y)<br>    <span class="hljs-built_in">print</span>(torch.<span class="hljs-built_in">max</span>(pred.data, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;\n&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(rights, length, rights/length)<br></code></pre></td></tr></table></figure>
<pre><code>tensor([2, 0, 1, 2, 1, 2, 1, 2, 2, 0, 1, 1, 0, 2, 0, 0])
tensor([2, 0, 1, 2, 2, 2, 1, 2, 2, 0, 1, 1, 0, 2, 0, 0]) 

tensor([1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 2, 1, 1, 1, 2])
tensor([2, 0, 1, 1, 0, 1, 0, 1, 0, 2, 1, 2, 1, 1, 1, 2]) 

tensor(29) 32 tensor(0.9062)
</code></pre>]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习实践实验-共享单车预测</title>
    <url>/2023/01/04/deep-learning-test02/</url>
    <content><![CDATA[<h1 id="实验二、共享单车预测"><a href="#实验二、共享单车预测" class="headerlink" title="实验二、共享单车预测"></a>实验二、共享单车预测</h1><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a><strong>内容</strong></h3><p>1、通过历史数据预测某一地区接下来一段时间内的共享单车的数量。数据保存在文件bikes.csv中，请按11：1的比例划分训练集和测试集，首先对数据进行预处理，然后在训练集上训练，并在测试集上验证模型。</p>
<p>2、设计神经网络对数据进行拟合，利用训练后的模型对数据拟合并进行预测，记录误差，并绘制拟合效果。</p>
<h3 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a><strong>完成情况</strong></h3><p>1、数据预处理</p>
<p>完成程度：使用pandas读取原始数据bikes.csv，对离散数据使用one-hot编码处理，对连续数据进行标准化处理，将数据划分成11训练集：1测试集。删除某些处理过后的列，将标签列于数据分离。</p>
<p>2、设计神经网络拟合</p>
<p>完成程度：搭建神经网络，隐藏层包含10个Linear，通过Sigmoid函数进行非线性化处理，再通过输出层对数据进行输出。使用MSELoss损失误差，采用随机梯度下降的方法，设置学习率为0.01，batch_size=128。对训练集进行训练，用得到的模型对测试集进行测试，通过绘制图像进行对比分析。</p>
<h2 id="读取原始数据，进行数据预处理"><a href="#读取原始数据，进行数据预处理" class="headerlink" title="读取原始数据，进行数据预处理"></a>读取原始数据，进行数据预处理</h2><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入相关包和函数</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读入数据并进行数据处理</span><br>data = pd.read_csv(<span class="hljs-string">&#x27;bikes.csv&#x27;</span>)<br>col_titles = [<span class="hljs-string">&#x27;season&#x27;</span>, <span class="hljs-string">&#x27;weathersit&#x27;</span>, <span class="hljs-string">&#x27;mnth&#x27;</span>, <span class="hljs-string">&#x27;hr&#x27;</span>, <span class="hljs-string">&#x27;weekday&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> col_titles:<br>    dummies = pd.get_dummies(data[i], prefix=i)<br>    data = pd.concat([data, dummies], axis=<span class="hljs-number">1</span>)<br><br>col_titles_to_drop = [<span class="hljs-string">&#x27;instant&#x27;</span>, <span class="hljs-string">&#x27;dteday&#x27;</span>] + col_titles<br><span class="hljs-built_in">print</span>(col_titles_to_drop)<br>data = data.drop(col_titles_to_drop, axis=<span class="hljs-number">1</span>)<br>data.head()<br></code></pre></td></tr></table></figure>
<pre><code>[&#39;instant&#39;, &#39;dteday&#39;, &#39;season&#39;, &#39;weathersit&#39;, &#39;mnth&#39;, &#39;hr&#39;, &#39;weekday&#39;]
</code></pre><p><table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>holiday</th>
      <th>workingday</th>
      <th>temp</th>
      <th>hum</th>
      <th>windspeed</th>
      <th>cnt</th>
      <th>season_1</th>
      <th>season_2</th>
      <th>season_3</th>
      <th>season_4</th>
      <th>...</th>
      <th>hr_21</th>
      <th>hr_22</th>
      <th>hr_23</th>
      <th>weekday_0</th>
      <th>weekday_1</th>
      <th>weekday_2</th>
      <th>weekday_3</th>
      <th>weekday_4</th>
      <th>weekday_5</th>
      <th>weekday_6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
      <td>0.24</td>
      <td>0.81</td>
      <td>0.0</td>
      <td>16</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>0</td>
      <td>0.22</td>
      <td>0.80</td>
      <td>0.0</td>
      <td>40</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0</td>
      <td>0.22</td>
      <td>0.80</td>
      <td>0.0</td>
      <td>32</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>0</td>
      <td>0.24</td>
      <td>0.75</td>
      <td>0.0</td>
      <td>13</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>0</td>
      <td>0.24</td>
      <td>0.75</td>
      <td>0.0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table></p>
<p>5 rows × 57 columns</p>

<p>&lt;/div&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对连续数据进行标准化处理</span><br>col_titles = [<span class="hljs-string">&#x27;cnt&#x27;</span>, <span class="hljs-string">&#x27;temp&#x27;</span>, <span class="hljs-string">&#x27;hum&#x27;</span>, <span class="hljs-string">&#x27;windspeed&#x27;</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> col_titles:<br>    mean, std = data[i].mean(), data[i].std()<br>    <span class="hljs-keyword">if</span> i == <span class="hljs-string">&#x27;cnt&#x27;</span>:<br>        mean_cnt, std_cnt = mean, std<br>    <br>    data[i] = (data[i] - mean)/std<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据集处理</span><br>test_data = data[-<span class="hljs-number">30</span>*<span class="hljs-number">24</span>:]<br>train_data = data[:-<span class="hljs-number">30</span>*<span class="hljs-number">24</span>]<br><br><span class="hljs-comment"># 删除标签类</span><br>X = train_data.drop([<span class="hljs-string">&#x27;cnt&#x27;</span>], axis=<span class="hljs-number">1</span>)<br>X = X.values<br>Y = train_data[<span class="hljs-string">&#x27;cnt&#x27;</span>]<br>Y = Y.values.astype(<span class="hljs-built_in">float</span>)<br>Y = np.reshape(Y, [<span class="hljs-built_in">len</span>(Y), <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 搭建神经网络</span><br>input_size = X.shape[<span class="hljs-number">1</span>]<br>hidden_size = <span class="hljs-number">10</span><br>output_size = <span class="hljs-number">1</span><br>batch_size = <span class="hljs-number">128</span><br><br>neu = torch.nn.Sequential(<br>    torch.nn.Linear(input_size, hidden_size),<br>    torch.nn.Sigmoid(),<br>    torch.nn.Linear(hidden_size, output_size)<br>)<br>loss_fn = torch.nn.MSELoss()<br>opt = torch.optim.SGD(neu.parameters(), lr=<span class="hljs-number">0.01</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练模型</span><br>losses = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>    batch_loss = []<br>    <span class="hljs-keyword">for</span> start <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(X), batch_size):<br>        <span class="hljs-keyword">if</span> start+batch_size&lt;<span class="hljs-built_in">len</span>(X):<br>            end = start+batch_size<br>        <span class="hljs-keyword">else</span>:<br>            end = <span class="hljs-built_in">len</span>(X)<br><br>        <span class="hljs-comment"># 生成一个batch的训练数据</span><br>        x = torch.FloatTensor(X[start:end])<br>        y = torch.FloatTensor(Y[start:end])<br><br>        pred = neu(x)<br>        loss = loss_fn(pred, y)<br>        opt.zero_grad()<br>        loss.backward()<br>        opt.step()<br>        batch_loss.append(loss.data.numpy())<br>    <span class="hljs-keyword">if</span> i%<span class="hljs-number">100</span>==<span class="hljs-number">0</span>:<br>        losses.append(np.mean(batch_loss))<br>        <span class="hljs-built_in">print</span>(i, np.mean(batch_loss))<br>        <br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.plot(np.arange(<span class="hljs-built_in">len</span>(losses))*<span class="hljs-number">100</span>, losses)<br>plt.xlabel(<span class="hljs-string">&#x27;batch&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;MSE&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>
<pre><code>0 0.8939656
100 0.30960146
200 0.26964802
300 0.18884033
400 0.14483929
500 0.1316976
600 0.12759094
700 0.12547289
800 0.12405107
900 0.12297937
</code></pre><img src="/2023/01/04/deep-learning-test02/output_7_1.png" class="" title="png">
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 测试，验证</span><br>X = test_data.drop([<span class="hljs-string">&#x27;cnt&#x27;</span>], axis=<span class="hljs-number">1</span>)<br>Y = test_data[<span class="hljs-string">&#x27;cnt&#x27;</span>]<br>Y = Y.values.reshape([<span class="hljs-built_in">len</span>(Y), <span class="hljs-number">1</span>])<br>X = torch.FloatTensor(X.values)<br>Y = torch.FloatTensor(Y)<br>pred = neu(X)<br><br>Y = Y.data.numpy()*std_cnt+mean_cnt<br>pred = pred.data.numpy()*std_cnt+mean_cnt<br><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>xplot, = plt.plot(np.arange(X.size(<span class="hljs-number">0</span>)), Y)<br>yplot, = plt.plot(np.arange(X.size(<span class="hljs-number">0</span>)), pred, <span class="hljs-string">&#x27;:&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>
<p>​<br><img src="/2023/01/04/deep-learning-test02/output_8_0.png" class="" title="png"><br>​    </p>
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习实践实验-线性回归</title>
    <url>/2023/01/03/deep-learning-test01/</url>
    <content><![CDATA[<h1 id="实验一、线性回归"><a href="#实验一、线性回归" class="headerlink" title="实验一、线性回归"></a>实验一、线性回归</h1><ul>
<li>已知模型y = a*x + b</li>
<li>生成带噪声的数据拟合线性函数</li>
<li>绘制图像拟合效果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入相关包</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>%matplotlib inline<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成y = a*x + b的噪声数据200个</span><br><span class="hljs-comment"># 定义a = 3， b = 2</span><br>a, b = <span class="hljs-number">3</span>, <span class="hljs-number">2</span><br><br>x_datas = torch.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">20</span>,<span class="hljs-number">200</span>)<br>rand_noise = torch.randn(<span class="hljs-number">200</span>)*<span class="hljs-number">3</span><br>y_lables = a*x_datas + b + rand_noise<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 绘制散点图</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.scatter(x_datas, y_lables)<br>plt.show()<br></code></pre></td></tr></table></figure>
<p>​<br><img src="/2023/01/03/deep-learning-test01/output_3_0.png" class="" title="png"><br>​    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将数据划分为训练集和测试集，按照180，20进行划分</span><br><span class="hljs-comment"># 每十个数据中，分层抽取出一个数据作为测试集</span><br><br>test_index = [<span class="hljs-number">10</span>*i + np.random.randint(<span class="hljs-number">10</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>)]<br>train_index = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_index]<br><br>X_train1, X_test1, y_train1, y_test1 = x_datas[train_index], x_datas[test_index], y_lables[train_index], y_lables[test_index]<br>y_train1<br></code></pre></td></tr></table></figure>
<pre><code>tensor([ 3.6945,  4.7438,  7.9504,  5.5705,  5.6000,  9.5666,  8.5461,  4.9789,
         0.6976,  5.6866,  4.2295, 10.9321, 11.2976,  7.9842, 12.1275,  8.0943,
        10.5445, 13.4849, 18.5069, 11.6880, 16.8814, 12.7575, 10.7111, 12.1603,
        14.7055, 14.3254, 11.4367, 17.6528, 18.5793, 17.8409, 13.8733, 16.6622,
        18.6143, 14.5482, 16.6509, 17.4552, 20.0250, 20.3924, 20.6348, 18.2929,
        16.6831, 20.4449, 17.3773, 18.3895, 18.2360, 24.1661, 18.2511, 16.6143,
        20.3642, 16.5544, 19.0061, 25.6141, 20.1254, 21.4796, 23.3279, 20.1736,
        25.3058, 26.7936, 24.8702, 23.0888, 24.2360, 26.3334, 26.8100, 22.9726,
        25.0721, 28.1969, 27.3128, 28.3941, 27.2811, 25.5293, 29.3596, 30.8378,
        29.3787, 30.2246, 28.6970, 19.3994, 31.6431, 35.1937, 26.6844, 31.5928,
        32.8604, 31.2751, 26.1607, 26.1867, 27.4753, 28.5589, 32.5150, 35.3546,
        29.3716, 30.2867, 34.1565, 36.8429, 32.5876, 41.2268, 32.7979, 35.0479,
        38.0979, 34.0405, 35.0074, 40.8656, 39.9885, 37.4418, 37.3445, 33.4271,
        40.4349, 41.4754, 36.4292, 41.2385, 41.1300, 39.4304, 39.1217, 40.2641,
        41.4882, 36.4677, 45.3880, 41.7064, 46.0084, 42.7886, 48.2276, 48.9552,
        45.7761, 46.6802, 49.1144, 47.0020, 41.9040, 47.4266, 48.3905, 51.4273,
        46.7154, 49.9467, 45.0021, 50.9472, 55.9469, 49.3655, 44.3413, 47.9426,
        45.9358, 54.3920, 49.9636, 53.2459, 50.3228, 46.5756, 50.2442, 54.3946,
        50.2086, 49.6290, 50.5312, 54.7947, 47.7757, 50.7428, 52.6791, 55.2901,
        55.9978, 57.0760, 50.6741, 53.8824, 58.6424, 53.3195, 57.1432, 54.2989,
        49.9915, 55.4631, 56.1260, 55.4143, 54.0111, 56.7517, 59.6828, 57.2633,
        56.1236, 63.1750, 59.2744, 54.7133, 54.5091, 57.9472, 64.0721, 63.9801,
        61.2980, 61.6411, 62.6100, 59.2035])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将训练集转化为张量，使用梯度下降法进行训练</span><br><span class="hljs-comment"># 迭代次数 10000，学习率：0.001</span><br><br>a = torch.rand(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.rand(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>loss = []<br>theta = <span class="hljs-number">0.00001</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>+<span class="hljs-number">1</span>):<br>    y_p = a.expand_as(X_train1)*X_train1 + b.expand_as(X_train1)<br>    loss_tmp = torch.mean((y_p - y_train1)**<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> i%<span class="hljs-number">500</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;迭代&quot;</span> , i , <span class="hljs-string">&quot;次，损失值为：&quot;</span>,loss_tmp.data.numpy())<br>    <br>    loss.append(loss_tmp.data.numpy())<br>    loss_tmp.backward()<br>    a.data = a.data - theta*a.grad.data<br>    b.data = b.data - theta*b.grad.data<br>    a.grad.data.zero_()<br>    b.grad.data.zero_()<br>    <br><span class="hljs-built_in">print</span>(a, b)<br></code></pre></td></tr></table></figure>
<pre><code>迭代 0 次，损失值为： 1019.3526
迭代 500 次，损失值为： 68.77335
迭代 1000 次，损失值为： 12.962891
迭代 1500 次，损失值为： 9.682995
迭代 2000 次，损失值为： 9.4870615
迭代 2500 次，损失值为： 9.47218
迭代 3000 次，损失值为： 9.467946
迭代 3500 次，损失值为： 9.46435
迭代 4000 次，损失值为： 9.460806
迭代 4500 次，损失值为： 9.457279
迭代 5000 次，损失值为： 9.453774
迭代 5500 次，损失值为： 9.450276
迭代 6000 次，损失值为： 9.446788
迭代 6500 次，损失值为： 9.44333
迭代 7000 次，损失值为： 9.439879
迭代 7500 次，损失值为： 9.436436
迭代 8000 次，损失值为： 9.433018
迭代 8500 次，损失值为： 9.429613
迭代 9000 次，损失值为： 9.426218
迭代 9500 次，损失值为： 9.422838
迭代 10000 次，损失值为： 9.419481
tensor([3.1121], requires_grad=True) tensor([0.9682], requires_grad=True)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.scatter(X_test1, y_test1)<br><br>plt.plot(X_test1.data.numpy(), a.data.numpy()*X_test1.data.numpy() + b.data.numpy())<br><br>plt.show()<br></code></pre></td></tr></table></figure>
<img src="/2023/01/03/deep-learning-test01/output_6_0.png" class="" title="png">
<ul>
<li>已知模型y = a<em>x^3 + b</em>x^2 + c*x + d</li>
<li>生成带噪声的数据拟合三次函数</li>
<li>绘制图像拟合效果</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成200个噪声数据</span><br><span class="hljs-comment"># 参数设置，a=0.005, b=0.01, c=0.1, d=1</span><br><br>a, b, c, d = <span class="hljs-number">0.005</span>, <span class="hljs-number">0.01</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">1</span><br><br>rand = torch.randn(<span class="hljs-number">200</span>)*<span class="hljs-number">1.5</span><br>X_trains = torch.linspace(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">200</span>)<br>Y_labels = a*(X_trains**<span class="hljs-number">3</span>) + b*(X_trains**<span class="hljs-number">2</span>) + c*X_trains + d + rand<br><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.scatter(X_trains, Y_labels)<br>plt.show()<br></code></pre></td></tr></table></figure>
<p>​<br><img src="/2023/01/03/deep-learning-test01/output_8_0.png" class="" title="png"><br>​    </p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构造数据集和训练集标签</span><br><br>test_index = [<span class="hljs-number">10</span>*i + np.random.randint(<span class="hljs-number">10</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>)]<br>train_index = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">if</span> i <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_index]<br><br>X_train2, X_test2, y_train2, y_test2 = X_trains[train_index], X_trains[test_index], Y_labels[train_index], Y_labels[test_index]<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 开始训练</span><br>a = torch.rand(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.rand(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>c = torch.rand(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>d = torch.rand(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>theta = <span class="hljs-number">0.0000001</span><br>times = <span class="hljs-number">50000</span><br>loss = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(times+<span class="hljs-number">1</span>):<br>    loss_tmp = torch.mean(((a.expand_as(X_train2) * (X_train2**<span class="hljs-number">3</span>) + <br>                           b.expand_as(X_train2) * (X_train2**<span class="hljs-number">2</span>) + c.expand_as(X_train2) * X_train2 + <br>                           d.expand_as(X_train2) - y_train2))**<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> i%<span class="hljs-number">2500</span> == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;迭代&quot;</span>, i,<span class="hljs-string">&quot;次，损失值为：&quot;</span>, loss_tmp.data.numpy())<br>    <br>    loss_tmp.backward()<br>    a.data = a.data - a.grad.data * theta<br>    b.data = b.data - b.grad.data * theta<br>    c.data = c.data - c.grad.data * theta<br>    d.data = d.data - d.grad.data * theta<br>    <br>    a.grad.data.zero_()<br>    b.grad.data.zero_()<br>    c.grad.data.zero_()<br>    d.grad.data.zero_()<br>    <br></code></pre></td></tr></table></figure>
<pre><code>迭代 0 次，损失值为： 3153.991
迭代 2500 次，损失值为： 11.566195
迭代 5000 次，损失值为： 5.8502893
迭代 7500 次，损失值为： 3.6634474
迭代 10000 次，损失值为： 2.8267233
迭代 12500 次，损失值为： 2.506517
迭代 15000 次，损失值为： 2.3839154
迭代 17500 次，损失值为： 2.3369095
迭代 20000 次，损失值为： 2.318825
迭代 22500 次，损失值为： 2.3118067
迭代 25000 次，损失值为： 2.3090246
迭代 27500 次，损失值为： 2.307857
迭代 30000 次，损失值为： 2.307303
迭代 32500 次，损失值为： 2.3069975
迭代 35000 次，损失值为： 2.3067696
迭代 37500 次，损失值为： 2.306577
迭代 40000 次，损失值为： 2.3063998
迭代 42500 次，损失值为： 2.3062305
迭代 45000 次，损失值为： 2.3060641
迭代 47500 次，损失值为： 2.3058996
迭代 50000 次，损失值为： 2.3057368
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对测试集进行预测拟合</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.scatter(X_test2, y_test2)<br><br>plt.plot(X_test2.data.numpy(), a.data.numpy()*(X_test2.data.numpy()**<span class="hljs-number">3</span>) + b.data.numpy()*(X_test2.data.numpy()**<span class="hljs-number">2</span>) + c.data.numpy()*X_test2.data.numpy() + d.data.numpy())<br><br>plt.show()<br></code></pre></td></tr></table></figure>
<p>​<br><img src="/2023/01/03/deep-learning-test01/output_11_0.png" class="" title="png"><br>​    </p>
<h2 id="设计神经网络对前面的数据进行拟合"><a href="#设计神经网络对前面的数据进行拟合" class="headerlink" title="设计神经网络对前面的数据进行拟合"></a>设计神经网络对前面的数据进行拟合</h2><ul>
<li>记录误差，绘制拟合效果</li>
<li>直线拟合数据为：X_train1, y_train1, X_test1, y_test1</li>
<li>曲线拟合数据为：X_train2, y_train2, X_test2, y_test2</li>
</ul>
<h3 id="一、拟合直线"><a href="#一、拟合直线" class="headerlink" title="一、拟合直线"></a>一、拟合直线</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用网络拟合直线</span><br><span class="hljs-comment"># 直线拟合只需要一个神经元就能完成拟合</span><br><br><span class="hljs-comment"># 定义网络</span><br>net = torch.nn.Sequential(<br>    torch.nn.Linear(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br>)<br><span class="hljs-comment"># 定义损失函数</span><br>loss_fn = torch.nn.MSELoss()<br><span class="hljs-comment"># 梯度下降方法，随机梯度下降</span><br>opt = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.0001</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练数据</span><br>losses = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>    pred = net(X_train1.view(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>    loss = loss_fn(pred, y_train1.view(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">if</span> i%<span class="hljs-number">200</span>==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;loss:&#x27;</span>, loss.data)<br>        losses.append(loss.data)<br>    <br>    opt.zero_grad()<br>    loss.backward()<br>    opt.step()<br>    <br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.plot(X_train1.data.numpy(), y_train1.data.numpy(), <span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.plot(X_train1.data.numpy(), net(X_train1.view(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)).data.numpy())<br>plt.show()<br></code></pre></td></tr></table></figure>
<pre><code>loss: tensor(999.4984)
loss: tensor(10.4790)
loss: tensor(10.4377)
loss: tensor(10.4070)
loss: tensor(10.3768)
</code></pre><img src="/2023/01/03/deep-learning-test01/output_15_1.png" class="" title="png">
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对测试集进行预测验证</span><br>pred = net(X_test1.view(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.plot(X_test1.data.numpy(), y_test1.data.numpy(), <span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.plot(X_test1.data.numpy(), pred.data.numpy())<br>plt.show()<br></code></pre></td></tr></table></figure>
<p>​<br><img src="/2023/01/03/deep-learning-test01/output_16_0.png" class="" title="png"><br>​    </p>
<h3 id="二、拟合多项式函数"><a href="#二、拟合多项式函数" class="headerlink" title="二、拟合多项式函数"></a>二、拟合多项式函数</h3><ul>
<li>单层神经网络只能够拟合直线</li>
<li>对多项式函数的拟合需要多层神经网络，且需要激活函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义model类</span><br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-comment"># 继承nn.Module</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 第一个隐藏层</span><br>        self.hidden1=nn.Linear(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>)<br>        <span class="hljs-comment"># 第二个隐藏层</span><br>        self.hidden2=nn.Linear(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br>        <span class="hljs-comment"># 第三个隐藏层</span><br>        self.hidden3=nn.Linear(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br>        <span class="hljs-comment"># 输出层</span><br>        self.out=nn.Linear(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 定义网络前向运算</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = self.hidden1(x)<br>        x = F.sigmoid(x)<br>        x = self.hidden2(x)<br>        x = F.sigmoid(x)<br>        x = self.hidden3(x)<br>        x = F.sigmoid(x)<br>        x = self.out(x)<br>        <span class="hljs-keyword">return</span> x<br>    <br>net = model()<br><span class="hljs-built_in">print</span>(net)<br></code></pre></td></tr></table></figure>
<pre><code>model(
  (hidden1): Linear(in_features=1, out_features=4, bias=True)
  (hidden2): Linear(in_features=4, out_features=4, bias=True)
  (hidden3): Linear(in_features=4, out_features=4, bias=True)
  (out): Linear(in_features=4, out_features=1, bias=True)
)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义损失函数</span><br>loss_fn = torch.nn.MSELoss()<br>opt = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>)<br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练数据</span><br>losses2 = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000</span>):<br>    pred = net(X_train2.view(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>    loss = loss_fn(pred, y_train2.view(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>    <span class="hljs-keyword">if</span> i%<span class="hljs-number">2500</span>==<span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;loss:&#x27;</span>, loss.data)<br>        losses2.append(loss)<br>    <br>    opt.zero_grad()<br>    loss.backward()<br>    opt.step()<br><br><span class="hljs-comment"># 绘制图像</span><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.plot(X_train2.data.numpy(), y_train2.data.numpy(), <span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.plot(X_train2.data.numpy(), net(X_train2.view(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)).data.numpy())<br>plt.show()<br></code></pre></td></tr></table></figure>
<pre><code>loss: tensor(357.9143)


D:\02_soft\anaconda3\envs\pytorch\lib\site-packages\torch\nn\functional.py:1960: UserWarning: nn.functional.sigmoid is deprecated. Use torch.sigmoid instead.
  warnings.warn(&quot;nn.functional.sigmoid is deprecated. Use torch.sigmoid instead.&quot;)


loss: tensor(146.0952)
loss: tensor(23.4380)
loss: tensor(16.6693)
loss: tensor(12.3312)
loss: tensor(10.4051)
loss: tensor(8.9617)
loss: tensor(7.7465)
loss: tensor(6.7640)
loss: tensor(5.9918)
loss: tensor(5.4033)
loss: tensor(4.9512)
loss: tensor(4.5902)
loss: tensor(4.2906)
loss: tensor(4.0353)
loss: tensor(3.8134)
loss: tensor(3.6182)
loss: tensor(3.4456)
loss: tensor(3.2944)
loss: tensor(3.1646)
</code></pre><img src="/2023/01/03/deep-learning-test01/output_20_3.png" class="" title="png">
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用训练的模型对测试集进行预测</span><br>pred2 = net(X_test2.view(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">8</span>))<br>plt.plot(X_test2.data.numpy(), y_test2.data.numpy(), <span class="hljs-string">&#x27;o&#x27;</span>)<br>plt.plot(X_test2.data.numpy(), pred2.data.numpy())<br>plt.show()<br></code></pre></td></tr></table></figure>
<img src="/2023/01/03/deep-learning-test01/output_21_0.png" class="" title="png">
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理实验-图像去噪</title>
    <url>/2022/10/19/digital-image-test04/</url>
    <content><![CDATA[<h3 id="1、均值滤波"><a href="#1、均值滤波" class="headerlink" title="1、均值滤波"></a>1、均值滤波</h3><p>具体内容: 利用 OpenCV 对灰度图像像素进行操作，分别利用算术均值滤波器、几何均值滤波器、谐波和逆谐波均值滤波器进行图像去噪。模板大小为5*5。（注：请分别为图像添加高斯噪声、胡椒噪声、盐噪声和椒盐噪声，并观察滤波效果）</p>
<p>完成程度：读入灰度图像，分别为图像加入椒噪声、盐噪声、椒盐噪声以及高斯噪声，并使用5*5的模板分别对不同的噪声图像进行处理，处理的过程是用模板中的像素取平均值后赋值给中心像素，最终得到处理结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 1、均值滤波</span><br><span class="hljs-function">Mat <span class="hljs-title">average_filter</span><span class="hljs-params">(Mat image1, string s)</span> </span>&#123;<br>	<span class="hljs-comment">// 构建均值滤波模板</span><br><br>	Mat image = image1.<span class="hljs-built_in">clone</span>();<br>	<span class="hljs-type">int</span> size = <span class="hljs-number">5</span>;<br>	image.<span class="hljs-built_in">convertTo</span>(image, CV_8U);<br>	Mat meta = Mat::<span class="hljs-built_in">ones</span>(size, size, CV_8U);<br><br>	<span class="hljs-type">int</span> count_size = size * size;<br><br>	<span class="hljs-comment">// 对原始图像进行填充操作</span><br>	image = <span class="hljs-built_in">fill_zero</span>(image, size);<br>	<span class="hljs-type">int</span> row = image.rows;<br>	<span class="hljs-type">int</span> col = image.cols;<br>	<span class="hljs-comment">// 输出图像保存在res中</span><br>	<span class="hljs-function">Mat <span class="hljs-title">res</span><span class="hljs-params">(row - size + <span class="hljs-number">1</span>, col - size + <span class="hljs-number">1</span>, CV_8U)</span></span>;<br>	<span class="hljs-comment">// 使用meta模板对图像进行处理</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row - size + <span class="hljs-number">1</span>; ++i) &#123;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col - size + <span class="hljs-number">1</span>; ++j) &#123;<br><br>			<span class="hljs-type">int</span> sum_ = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; size; ++s) &#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; size; ++t) &#123;<br>					sum_ += image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i + s, j + t) * meta.<span class="hljs-built_in">at</span>&lt;uchar&gt;(s, t);<br>				&#125;<br>			&#125;<br>			res.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j) = sum_ / count_size;<br>		&#125;<br>	&#125;<br><br><br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;均值滤波处理&quot;</span> + s, res);<br><br>	<span class="hljs-keyword">return</span> res;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">junzhi_quzao</span><span class="hljs-params">(Mat image)</span> </span>&#123;<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;原图&quot;</span>, image);<br><br>	<span class="hljs-built_in">average_filter</span>(<span class="hljs-built_in">guassion</span>(image), <span class="hljs-string">&quot;高斯噪声&quot;</span>);<br>	<span class="hljs-built_in">average_filter</span>(<span class="hljs-built_in">jiao_salty</span>(image), <span class="hljs-string">&quot;椒盐噪声&quot;</span>);<br>	<span class="hljs-built_in">average_filter</span>(<span class="hljs-built_in">salty</span>(image), <span class="hljs-string">&quot;盐噪声&quot;</span>);<br>	<span class="hljs-built_in">average_filter</span>(<span class="hljs-built_in">jiao</span>(image), <span class="hljs-string">&quot;椒噪声&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>添加噪声</p>
<img src="/2022/10/19/digital-image-test04/image-20240302185557410.png" class="" title="image-20240302185557410">
<img src="/2022/10/19/digital-image-test04/image-20240302185602980.png" class="" title="image-20240302185602980">
<img src="/2022/10/19/digital-image-test04/image-20240302185608155.png" class="" title="image-20240302185608155">
<p>均值滤波</p>
<img src="/2022/10/19/digital-image-test04/image-20240302185735104.png" class="" title="image-20240302185735104">
<img src="/2022/10/19/digital-image-test04/image-20240302185739084.png" class="" title="image-20240302185739084">
<h3 id="2、中值滤波"><a href="#2、中值滤波" class="headerlink" title="2、中值滤波"></a>2、中值滤波</h3><p>具体内容: 利用 OpenCV 对灰度图像像素进行操作，分别利用 5<em>5 和 9</em>9尺寸的模板对图像进行中值滤波。（注：请分别为图像添加胡椒噪声、盐噪声和椒盐噪声，并观察滤波效果） </p>
<p>完成程度：分别为图像加入椒噪声、盐噪声、椒盐噪声以及高斯噪声，并使用5*5的模板分别对不同的噪声图像进行处理，处理的过程是，将模板内的像素灰度进行排序，取排序后的中间灰度值作为模板中心像素的灰度值，最终得到处理结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 2、中值滤波</span><br><span class="hljs-comment">// 将窗口中的点按照从小到大的排序，取中间的值作为窗口中心的值</span><br><span class="hljs-function">Mat <span class="hljs-title">median_filter</span><span class="hljs-params">(Mat image1, <span class="hljs-type">int</span> size, string s1)</span> </span>&#123;<br>	<span class="hljs-comment">// 构建均值滤波模板</span><br>	Mat image = image1.<span class="hljs-built_in">clone</span>();<br>	image.<span class="hljs-built_in">convertTo</span>(image, CV_8U);<br><br>	<span class="hljs-comment">// 对原始图像进行填充操作</span><br>	image = <span class="hljs-built_in">fill_zero</span>(image, size);<br>	<span class="hljs-type">int</span> row = image.rows;<br>	<span class="hljs-type">int</span> col = image.cols;<br>	<span class="hljs-comment">// 输出图像保存在res中</span><br>	<span class="hljs-function">Mat <span class="hljs-title">res</span><span class="hljs-params">(row - size + <span class="hljs-number">1</span>, col - size + <span class="hljs-number">1</span>, CV_8U)</span></span>;<br>	<span class="hljs-comment">// 使用meta模板对图像进行处理</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row - size + <span class="hljs-number">1</span>; ++i) &#123;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col - size + <span class="hljs-number">1</span>; ++j) &#123;<br>			vector&lt;<span class="hljs-type">int</span>&gt; num;<br>			<span class="hljs-type">int</span> sum_ = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; size; ++s) &#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; size; ++t) &#123;<br>					<span class="hljs-type">int</span> k = image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i + s, j + t);<br>					num.<span class="hljs-built_in">push_back</span>(k);<br>				&#125;<br>			&#125;<br>			<span class="hljs-built_in">sort</span>(num.<span class="hljs-built_in">begin</span>(), num.<span class="hljs-built_in">end</span>());<br>			res.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j) = num[<span class="hljs-built_in">int</span>(num.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>)];<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;中值滤波处理&quot;</span> + s1, res);<br><br>	<span class="hljs-keyword">return</span> res;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">zhongzhi_quzao</span><span class="hljs-params">(Mat image)</span> </span>&#123;<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;原图&quot;</span>, image);<br><br>	<span class="hljs-built_in">median_filter</span>(<span class="hljs-built_in">guassion</span>(image), <span class="hljs-number">5</span>, <span class="hljs-string">&quot;高斯噪声&quot;</span>);<br>	<span class="hljs-built_in">median_filter</span>(<span class="hljs-built_in">jiao_salty</span>(image), <span class="hljs-number">5</span>, <span class="hljs-string">&quot;椒盐噪声&quot;</span>);<br>	<span class="hljs-built_in">median_filter</span>(<span class="hljs-built_in">salty</span>(image), <span class="hljs-number">5</span>, <span class="hljs-string">&quot;盐噪声&quot;</span>);<br>	<span class="hljs-built_in">median_filter</span>(<span class="hljs-built_in">jiao</span>(image), <span class="hljs-number">5</span>, <span class="hljs-string">&quot;椒噪声&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/19/digital-image-test04/image-20240302185751435.png" class="" title="image-20240302185751435">
<img src="/2022/10/19/digital-image-test04/image-20240302185800747.png" class="" title="image-20240302185800747">
<h3 id="3、自适应均值滤波"><a href="#3、自适应均值滤波" class="headerlink" title="3、自适应均值滤波"></a>3、自适应均值滤波</h3><p>具体内容:利用 OpenCV 对灰度图像像素进行操作，设计自适应局部降低噪声滤波器去噪算法。模板大小 7*7（对比该算法的效果和均值滤波器的效果） </p>
<p>完成程度：自适应的均值滤波，可以通过局部的均值方差，以及噪声的均值方差之间的关系，来自动的调整对噪声处理强的大小，将原始图片的方差作为分子，将局部图片的方差作为分母，用7*7的模板对加入高斯噪声的图像进行了处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 3、自适应均值滤波</span><br><span class="hljs-comment">// 计算图像全局的方差</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">quare_sub</span><span class="hljs-params">(Mat image)</span> </span>&#123;<br>	<span class="hljs-comment">// 统计不同灰度的概率密度</span><br>	<span class="hljs-type">double</span> midu[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>	<span class="hljs-type">int</span> col = image.cols;<br>	<span class="hljs-type">int</span> row = image.rows;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; ++j) &#123;<br>			midu[image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j)] += <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-type">int</span> size = col * row;<br><br>	<span class="hljs-comment">// 计算均值</span><br>	<span class="hljs-type">double</span> med = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i) &#123;<br>		med += i * (midu[i] / size);<br>	&#125;<br><br>	<span class="hljs-comment">// 计算方差</span><br>	<span class="hljs-type">double</span> quare = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i) &#123;<br>		quare += <span class="hljs-built_in">pow</span>((i - med), <span class="hljs-number">2</span>) * (midu[i] / size);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> quare;<br>&#125;<br><br><span class="hljs-comment">// 自适应均值滤波</span><br><span class="hljs-function">Mat <span class="hljs-title">self_adapt_mean_filter</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> self_adapt_mean_filter_size)</span> </span>&#123;<br>	<span class="hljs-comment">// 滤波窗口尺寸必须为奇数</span><br>	Mat pScr, dst;<br>	<span class="hljs-comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span><br>	pScr = image.<span class="hljs-built_in">clone</span>();<br>	<span class="hljs-type">int</span> row = pScr.rows;<br>	<span class="hljs-type">int</span> col = pScr.cols;<br>	<span class="hljs-built_in">blur</span>(pScr, dst, <span class="hljs-built_in">Size</span>(<span class="hljs-number">7</span>, <span class="hljs-number">7</span>));<br>	<span class="hljs-type">int</span> pos = (self_adapt_mean_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>	<span class="hljs-type">double</span> Sn = <span class="hljs-number">100.0</span>;<br>	<span class="hljs-comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = pos; m &lt; row - pos; m++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = pos; n &lt; col - pos; n++) &#123;<br>			<span class="hljs-type">int</span> Zxy = <span class="hljs-built_in">int</span>(pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(m, n));<br>			<span class="hljs-type">int</span> Zmed = <span class="hljs-built_in">int</span>(dst.<span class="hljs-built_in">at</span>&lt;uchar&gt;(m, n));<br>			<span class="hljs-type">double</span> Sl = <span class="hljs-number">0.0</span>;<br>			<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - (self_adapt_mean_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &lt;= m + (self_adapt_mean_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i++) &#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - (self_adapt_mean_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j &lt;= n + (self_adapt_mean_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j++) &#123;<br>					<span class="hljs-type">int</span> Sxy = pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j);<br>					Sl += <span class="hljs-built_in">pow</span>(Sxy - Zmed, <span class="hljs-number">2</span>);<br>					count++;<br>				&#125;<br>			&#125;<br>			Sl = Sl / count;<br>			pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(m, n) = (<span class="hljs-type">int</span>)(Zxy - Sn / Sl * (Zxy - Zmed));<br><br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> pScr;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">self_adapt</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>	Mat res = image.<span class="hljs-built_in">clone</span>();<br>	<br>	res = <span class="hljs-built_in">guassion</span>(res);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;加入高斯噪声后图片&quot;</span>, res);<br>	res = <span class="hljs-built_in">self_adapt_mean_filter</span>(res, size);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;使用自适应均值滤波&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/19/digital-image-test04/image-20240302185819182.png" class="" title="image-20240302185819182">
<h3 id="4、自适应中值滤波"><a href="#4、自适应中值滤波" class="headerlink" title="4、自适应中值滤波"></a>4、自适应中值滤波</h3><p>具体内容: 利用 OpenCV 对灰度图像像素进行操作，设计自适应中值滤波算法对椒盐图像进行去噪。模板大小 7*7（对比中值滤波器的效果） </p>
<p>完成程度：自适应的中值滤波和自适应的均值滤波具有相似的原理，与均值滤波不同的便是，中值滤波适应的是模板的大小，而均值滤波适应的是去噪比例大小。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//4、自适应中值滤波</span><br><span class="hljs-comment">// 自适应中值滤波</span><br><span class="hljs-function">Mat <span class="hljs-title">self_adapt_median_filter</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> self_adapt_median_filter_size)</span> </span>&#123;<br>	<span class="hljs-comment">// 滤波窗口尺寸必须为奇数</span><br>	Mat pScr = image.<span class="hljs-built_in">clone</span>();<br>	<span class="hljs-comment">// 1为加载图像的颜色类型,1为原图返回,0为灰度返回</span><br>	<span class="hljs-type">int</span> row = pScr.rows;<br>	<span class="hljs-type">int</span> col = pScr.cols;<br>	<span class="hljs-type">int</span> channel = pScr.<span class="hljs-built_in">channels</span>();<br>	<span class="hljs-comment">// 滤波器窗口的起始尺寸</span><br>	<span class="hljs-type">int</span> pos = (self_adapt_median_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>	<span class="hljs-comment">// 每个滤波窗口中心位置都计算滤波窗口内通道值的平均值</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> m = pos; m &lt; row - pos; m++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = pos; n &lt; col - pos; n++) &#123;<br>			<span class="hljs-type">int</span> minValue = <span class="hljs-number">255</span>;<br>			<span class="hljs-type">int</span> maxValue = <span class="hljs-number">0</span>;<br>			<span class="hljs-type">int</span> medValue = <span class="hljs-number">0</span>;<br>			vector&lt;<span class="hljs-type">int</span>&gt; filter_value;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - (self_adapt_median_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i &lt;= m + (self_adapt_median_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; i++) &#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - (self_adapt_median_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j &lt;= n + (self_adapt_median_filter_size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j++) &#123;<br>					filter_value.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">int</span>(pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j)));<br>					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>(pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j)) &gt; maxValue)<br>						maxValue = <span class="hljs-built_in">int</span>(pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j));<br>					<span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>(pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j)) &lt; minValue)<br>						minValue = <span class="hljs-built_in">int</span>(pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j));<br>				&#125;<br>			&#125;<br>			<span class="hljs-built_in">sort</span>(filter_value.<span class="hljs-built_in">begin</span>(), filter_value.<span class="hljs-built_in">end</span>());<br>			medValue = filter_value[<span class="hljs-built_in">int</span>(self_adapt_median_filter_size * self_adapt_median_filter_size / <span class="hljs-number">2</span>)];<br>			<span class="hljs-type">int</span> fxy = <span class="hljs-built_in">int</span>(pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(m, n));<br>			<span class="hljs-keyword">if</span> (medValue &gt; minValue &amp;&amp; medValue &lt; maxValue)<br>				<span class="hljs-keyword">if</span> (fxy &lt;= minValue || fxy &gt;= maxValue)<br>					pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(m, n) = medValue;<br>				<span class="hljs-keyword">else</span><br>					pScr.<span class="hljs-built_in">at</span>&lt;uchar&gt;(m, n) = medValue;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-keyword">return</span> pScr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">self_median</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> size)</span> </span>&#123;<br><br>	Mat res = image.<span class="hljs-built_in">clone</span>();<br>	res = <span class="hljs-built_in">guassion</span>(res);<br>	res = <span class="hljs-built_in">self_adapt_median_filter</span>(image, <span class="hljs-number">7</span>);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;使用自适应中值滤波&quot;</span>, res);<br>	<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/19/digital-image-test04/image-20240302185829105.png" class="" title="image-20240302185829105">
<h3 id="5、彩色图像均值滤波"><a href="#5、彩色图像均值滤波" class="headerlink" title="5、彩色图像均值滤波"></a>5、彩色图像均值滤波</h3><p>具体内容: 利用 OpenCV 对彩色图像 RGB 三个通道的像素进行操作，利用算术均值滤波器和几何均值滤波器进行彩色图像去噪。模板大小为 5*5。</p>
<p>完成程度：分别对彩色图像的三个通道加入高斯噪声，然后再合并三个通道，得到的便是加入有高斯噪声的彩色图像。通过对带有噪声的彩色图像进行通道分离，再分别使用自适应的均值滤波对三个通道进行处理，最终合并以后便是，处理的结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//5、彩色图像均值滤波</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">color_quzao</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>	vector&lt;Mat&gt;channels;<br>	vector&lt;Mat&gt;channels1;<br>	<span class="hljs-built_in">split</span>(image, channels);<br>	channels1 = channels;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>		channels[i] = <span class="hljs-built_in">guassion</span>(channels[i]);<br>	&#125;<br>	Mat res;<br>	Mat res1;<br>	<span class="hljs-built_in">merge</span>(channels, res);<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;彩色图像加入高斯噪声&quot;</span>, res);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>		channels[i] = <span class="hljs-built_in">self_adapt_mean_filter</span>(channels[i].<span class="hljs-built_in">clone</span>(), <span class="hljs-number">7</span>);<br><br>		channels1[i] = <span class="hljs-built_in">self_adapt_median_filter</span>(channels[i].<span class="hljs-built_in">clone</span>(), <span class="hljs-number">7</span>);<br>	&#125;<br><br>	<span class="hljs-built_in">merge</span>(channels, res);<br>	<span class="hljs-built_in">merge</span>(channels1, res1);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;自适应均值滤波处理彩色图像&quot;</span>, res);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;自适应中值滤波处理彩色图像&quot;</span>, res1);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/19/digital-image-test04/image-20240302185837682.png" class="" title="image-20240302185837682">
<img src="/2022/10/19/digital-image-test04/image-20240302185841933.png" class="" title="image-20240302185841933">]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>数字图像</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理实验-空域滤波</title>
    <url>/2022/10/02/digital-image-test03/</url>
    <content><![CDATA[<h3 id="1、利用均值模板平滑灰度图像"><a href="#1、利用均值模板平滑灰度图像" class="headerlink" title="1、利用均值模板平滑灰度图像"></a>1、利用均值模板平滑灰度图像</h3><p>具体内容: 利用 OpenCV 对图像像素进行操作，分别利用 3<em>3、5</em>5 和 9*9 尺寸的均值模板平滑灰度图像。</p>
<p>完成程度：对原图像进行边缘填充，用周围的像素点灰度值代替图像边缘的值，构造了3<em>3、5</em>5、7*7的均值模板，对灰度图像进行均值计算操作，将得到的均值赋值给对应的新矩阵。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 辅助函数1、对原始灰度图像进行边缘填充操作</span><br><span class="hljs-function">Mat <span class="hljs-title">fill_zero</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>	<span class="hljs-comment">// 将边缘的填充为与它最近的像素灰度</span><br>	<span class="hljs-type">int</span> fill_size = <span class="hljs-built_in">int</span>(size / <span class="hljs-number">2</span>);<br>	<span class="hljs-type">int</span> row = image.rows;<br>	<span class="hljs-type">int</span> col = image.cols;<br><br>	Mat first_row = image.<span class="hljs-built_in">rowRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>	Mat last_row = image.<span class="hljs-built_in">rowRange</span>(row - <span class="hljs-number">1</span>, row);<br>	<br>	<span class="hljs-comment">// 垂直填充</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fill_size; ++i) &#123;<br>		cv::<span class="hljs-built_in">vconcat</span>(first_row, image, image);<br>		cv::<span class="hljs-built_in">vconcat</span>(image, last_row, image);<br>	&#125;<br><br>	<span class="hljs-comment">// 水平填充</span><br>	Mat left_col = image.<span class="hljs-built_in">colRange</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>	Mat right_col = image.<span class="hljs-built_in">colRange</span>(col - <span class="hljs-number">1</span>, col);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fill_size; ++i) &#123;<br>		cv::<span class="hljs-built_in">hconcat</span>(left_col, image, image);<br>		cv::<span class="hljs-built_in">hconcat</span>(image, right_col, image);<br>	&#125;<br><br>	<span class="hljs-comment">// imshow(&quot;填充后&quot;, image);</span><br>	<span class="hljs-keyword">return</span> image;<br><br>&#125;<br><br><span class="hljs-comment">// 1、利用均值模板平滑灰度图像</span><br><span class="hljs-function">Mat <span class="hljs-title">average_filter</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> size)</span> </span>&#123;<br>	<span class="hljs-comment">// 构建均值滤波模板</span><br>	image.<span class="hljs-built_in">convertTo</span>(image, CV_8U);<br>	Mat meta = Mat::<span class="hljs-built_in">ones</span>(size, size, CV_8U);<br><br>	<span class="hljs-type">int</span> count_size = size * size;<br><br>	<span class="hljs-comment">// 对原始图像进行填充操作</span><br>	image = <span class="hljs-built_in">fill_zero</span>(image, size);<br>	<span class="hljs-type">int</span> row = image.rows;<br>	<span class="hljs-type">int</span> col = image.cols;<br>	<span class="hljs-comment">// 输出图像保存在res中</span><br>	<span class="hljs-function">Mat <span class="hljs-title">res</span><span class="hljs-params">(row-size+<span class="hljs-number">1</span>, col-size+<span class="hljs-number">1</span>, CV_8U)</span></span>;<br>	<span class="hljs-comment">// 使用meta模板对图像进行处理</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row - size + <span class="hljs-number">1</span>; ++i) &#123;<br><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col - size + <span class="hljs-number">1</span>; ++j) &#123;<br><br>			<span class="hljs-type">int</span> sum_ = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; size; ++s) &#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; size; ++t) &#123;<br>					sum_ += image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i+s, j+t) * meta.<span class="hljs-built_in">at</span>&lt;uchar&gt;(s, t);<br>				&#125;<br>			&#125;<br>			res.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j) = sum_/count_size;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;均值滤波：&quot;</span>+ <span class="hljs-built_in">to_string</span>(size) + <span class="hljs-string">&#x27;*&#x27;</span> + <span class="hljs-built_in">to_string</span>(size), res);<br>	<br>	<span class="hljs-keyword">return</span> res;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/02/digital-image-test03/image-20240302184920811.png" class="" title="image-20240302184920811">
<h3 id="2、利用高斯模板平滑灰度图像"><a href="#2、利用高斯模板平滑灰度图像" class="headerlink" title="2、利用高斯模板平滑灰度图像"></a>2、利用高斯模板平滑灰度图像</h3><p>具体内容: 利用 OpenCV 对图像像素进行操作，分别利用 3<em>3、5</em>5 和 9*9 尺寸的高斯模板平滑灰度图像。 </p>
<p>完成程度：通过高斯函数自定义构造3<em>3、5</em>5、7*7的高斯模板，编写卷积运算的函数，并将原灰度图与所构造的高斯模板进行卷积操作，得到平滑后的图像并输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 辅助函数2、完成卷积操作</span><br><span class="hljs-function">Mat <span class="hljs-title">juanji</span><span class="hljs-params">(Mat image, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; meta, <span class="hljs-type">int</span> size_)</span> </span>&#123;<br><br>	<span class="hljs-type">double</span> sum = <span class="hljs-number">0.0</span>;<br>	<span class="hljs-comment">// 求meta元素的和</span><br>	<span class="hljs-comment">//for (int i = 0; i &lt; size; ++i) &#123;</span><br>	<span class="hljs-comment">//	for (int j = 0; j &lt; size; ++j) &#123;</span><br>	<span class="hljs-comment">//		sum += meta[i][j];</span><br>	<span class="hljs-comment">//	&#125;</span><br>	<span class="hljs-comment">//&#125;</span><br>	<span class="hljs-type">int</span> size = size_ % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? size_ + <span class="hljs-number">1</span> : size_;<br>	<span class="hljs-type">int</span> row = image.rows;<br>	<span class="hljs-type">int</span> col = image.cols;<br>	Mat res = Mat::<span class="hljs-built_in">zeros</span>(row - size + <span class="hljs-number">1</span>, col - size + <span class="hljs-number">1</span>, CV_8U);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row - size + <span class="hljs-number">1</span>; ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col - size + <span class="hljs-number">1</span>; ++j) &#123;<br>			<span class="hljs-type">double</span> sum_1 = <span class="hljs-number">0.0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; size_; ++s) &#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; size_; ++t) &#123;<br>					sum_1 += image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i + s, j + t) * meta[s][t];<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (sum_1 &gt; <span class="hljs-number">0</span>) &#123;<br>				res.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j) = <span class="hljs-built_in">int</span>(sum_1);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				res.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j) = <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 2、利用高斯模板平滑灰度图像</span><br><span class="hljs-function">Mat <span class="hljs-title">gaussion_filter</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> size, <span class="hljs-type">double</span> sigma)</span> </span>&#123;<br>	<span class="hljs-comment">// 高斯方程为，h(x,y) = e**-&#123;([(x-x0))**2+(y-y0)**2]/(2*σ**2)]&#125;</span><br>	<span class="hljs-comment">// 其中x0，y0为中心坐标</span><br>	<span class="hljs-comment">// 构造高斯滤波器模板</span><br>	vector&lt;vector&lt;<span class="hljs-type">double</span>&gt; &gt;<span class="hljs-built_in">gaussion_module</span>(size, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt;(size));<br>	<span class="hljs-type">int</span> x0 = (size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>	<span class="hljs-type">int</span> y0 = (size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>	<span class="hljs-comment">// 求和</span><br>	<span class="hljs-type">double</span> sum_ = <span class="hljs-number">0.0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; size; ++x) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; size; ++y) &#123;<br>			gaussion_module[x][y] = <span class="hljs-built_in">exp</span>(-(<span class="hljs-built_in">pow</span>((x - x0), <span class="hljs-number">2</span>) + <span class="hljs-built_in">pow</span>((y - y0), <span class="hljs-number">2</span>)) / (<span class="hljs-number">2</span> * sigma * sigma));<br>			sum_ += gaussion_module[x][y];<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">// 填充</span><br>	image = <span class="hljs-built_in">fill_zero</span>(image, size);<br><br>	<span class="hljs-comment">// Mat res = juanji(image, gaussion_module, size);</span><br><br>	<span class="hljs-type">int</span> row = image.rows;<br>	<span class="hljs-type">int</span> col = image.cols;<br>	<span class="hljs-function">Mat <span class="hljs-title">res</span><span class="hljs-params">(row - size + <span class="hljs-number">1</span>, col - size + <span class="hljs-number">1</span>, CV_8U)</span></span>;<br><br>	<span class="hljs-comment">// 使用高斯滤波进行卷积操作</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row - size + <span class="hljs-number">1</span>; ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col - size + <span class="hljs-number">1</span>; ++j) &#123;<br>			<span class="hljs-comment">// 卷积和</span><br>			<span class="hljs-type">double</span> sum_mul = <span class="hljs-number">0.0</span>;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; size; ++s) &#123;<br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt; size; ++t) &#123;<br>					sum_mul += image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i + s, j + t) * gaussion_module[s][t];<br>				&#125;<br>			&#125;<br>			res.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j) = <span class="hljs-built_in">int</span>(sum_mul / sum_);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;高斯模板尺寸：&quot;</span> + <span class="hljs-built_in">to_string</span>(size) + <span class="hljs-string">&#x27;*&#x27;</span> + <span class="hljs-built_in">to_string</span>(size), res);<br><br>	<span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/02/digital-image-test03/image-20240302184935209.png" class="" title="image-20240302184935209">
<img src="/2022/10/02/digital-image-test03/image-20240302184940449.png" class="" title="image-20240302184940449">
<h3 id="3、利用-Laplacian、Robert、Sobel-模板锐化灰度图像"><a href="#3、利用-Laplacian、Robert、Sobel-模板锐化灰度图像" class="headerlink" title="3、利用 Laplacian、Robert、Sobel 模板锐化灰度图像"></a>3、利用 Laplacian、Robert、Sobel 模板锐化灰度图像</h3><p>具体内容: 利用 OpenCV 对图像像素进行操作，分别利用 Laplacian、Robert、Sobel 模板锐化灰度图像。 </p>
<p>完成程度：分别构造Laplacian、Robert、Sobel模板，用这三个模板分别原始图像进行卷积操作，得到结果后输出</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 3、利用Laplacian、Robert、Sobel模板锐化灰度图像</span><br><span class="hljs-function">vector&lt;Mat&gt; <span class="hljs-title">sharpen</span><span class="hljs-params">(Mat image1)</span> </span>&#123;<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;原图&quot;</span>, image1);<br>	<span class="hljs-comment">// 对原图进行填充</span><br>	Mat image = image1;<br><br>	<span class="hljs-comment">//image = average_filter(image, 3);</span><br>	image = <span class="hljs-built_in">fill_zero</span>(image, <span class="hljs-number">3</span>);<br>	<span class="hljs-comment">// 拉普拉斯模板&#123;0，1，0，1，-4，1，0，1，0&#125;</span><br>	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;laplacian_model = &#123; &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125; &#125;;<br>	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;laplacian_model2 = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-8</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125; &#125;;<br>	<br>	Mat res_laplacian = <span class="hljs-built_in">juanji</span>(image, laplacian_model, <span class="hljs-number">3</span>);<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Laplacian&quot;</span>, res_laplacian);<br>	<span class="hljs-built_in">subtract</span>(image1, res_laplacian, res_laplacian);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Laplacian处理过后的图像&quot;</span>, res_laplacian);<br><br>	<span class="hljs-comment">// Robert算子</span><br>	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;robert_model = &#123; &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125; &#125;;<br>	Mat image_robert = image1;<br>	image_robert = <span class="hljs-built_in">fill_zero</span>(image_robert, <span class="hljs-number">2</span>);<br>	Mat res_robert = <span class="hljs-built_in">juanji</span>(image_robert, robert_model, <span class="hljs-number">2</span>);<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;robert&quot;</span>, res_robert);<br>	<span class="hljs-built_in">add</span>(image1, res_robert, res_robert);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Rebort处理过后的图像&quot;</span>, res_robert);<br>	<span class="hljs-comment">// cout &lt;&lt; res_rebort.cols &lt;&lt; &quot;sadas&quot; &lt;&lt; endl;</span><br><br>	<span class="hljs-comment">// Sobel算子</span><br>	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;sobel_model = &#123; &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125; &#125;;<br>	Mat image_sobel = image1;<br>	image_sobel = <span class="hljs-built_in">fill_zero</span>(image_sobel, <span class="hljs-number">3</span>);<br>	Mat res_sobel = <span class="hljs-built_in">juanji</span>(image_sobel, sobel_model, <span class="hljs-number">3</span>);<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;sobel&quot;</span>, res_sobel);<br>	<span class="hljs-built_in">subtract</span>(image1, res_sobel, res_sobel);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Sobel处理过后的图像&quot;</span>, res_sobel);<br><br>	vector&lt;Mat&gt; res = &#123; res_laplacian, res_robert, res_sobel &#125;;<br>	Mat s;<br>	<span class="hljs-built_in">merge</span>(res, s);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;get&quot;</span>, s);<br><br>	<span class="hljs-keyword">return</span> res;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Laplacian</p>
<img src="/2022/10/02/digital-image-test03/image-20240302184950081.png" class="" title="image-20240302184950081">
<p>Robert</p>
<img src="/2022/10/02/digital-image-test03/image-20240302184959151.png" class="" title="image-20240302184959151">
<p>Sobel</p>
<img src="/2022/10/02/digital-image-test03/image-20240302185003442.png" class="" title="image-20240302185003442">
<h3 id="4、利用高提升滤波算法增强灰度图像"><a href="#4、利用高提升滤波算法增强灰度图像" class="headerlink" title="4、利用高提升滤波算法增强灰度图像"></a>4、利用高提升滤波算法增强灰度图像</h3><p>具体内容: 利用 OpenCV 对图像像素进行操作，设计高提升滤波算法增强图像。 </p>
<p>完成程度：使用高斯滤波平滑原始图像，将原始图像减去平滑后的图像，得到高斯滤波过滤掉的细节图像，给细节图像乘上一定的倍数（本实验所用的倍数是2），再加到原始图像中，输出图像。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 4、利用高提升滤波算法增强灰度图像</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enhance_image</span><span class="hljs-params">(Mat image)</span> </span>&#123;<br>	<span class="hljs-comment">// 先对原始图像进行平滑处理</span><br>	Mat filt_image = <span class="hljs-built_in">gaussion_filter</span>(image, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>	Mat sub_image;<br>	<span class="hljs-built_in">subtract</span>(image, filt_image, sub_image);<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;dada&quot;</span>, sub_image*<span class="hljs-number">2</span>);<br>	Mat res;<br>	<span class="hljs-built_in">add</span>(image, sub_image, res);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;高提升后的图像&quot;</span>, res);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/02/digital-image-test03/image-20240302185107213.png" class="" title="image-20240302185107213">
<h3 id="5、利用均值模板平滑彩色图像"><a href="#5、利用均值模板平滑彩色图像" class="headerlink" title="5、利用均值模板平滑彩色图像"></a>5、利用均值模板平滑彩色图像</h3><p>具体内容：利用 OpenCV 分别对图像像素的 RGB 三个通道进行操作，利用 3<em>3、5</em>5 和 9*9 尺寸的均值模板平滑彩色图像。</p>
<p>完成程度：在完成了均值滤波平滑灰度图像的基础上，分离彩色图像的三个通道，分别对其三个通道进行平滑处理，完成以后再合并输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 5、利用均值模板平滑彩色图像</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">average_filter_color</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> size)</span> </span>&#123;<br><br>	<span class="hljs-comment">// 分别对三个通道进行处理</span><br>	vector&lt;Mat&gt; channels;<br>	cv::<span class="hljs-built_in">split</span>(image, channels);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>		channels[i] = <span class="hljs-built_in">average_filter</span>(channels[i], size);<br>	&#125;<br>	<br>	cv::<span class="hljs-built_in">merge</span>(channels, image);<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;彩图&quot;</span>, image);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/02/digital-image-test03/image-20240302185113358.png" class="" title="image-20240302185113358">
<img src="/2022/10/02/digital-image-test03/image-20240302185116864.png" class="" title="image-20240302185116864">
<h3 id="6、利用高斯模板平滑彩色图像"><a href="#6、利用高斯模板平滑彩色图像" class="headerlink" title="6、利用高斯模板平滑彩色图像"></a>6、利用高斯模板平滑彩色图像</h3><p>具体内容：利用 OpenCV 分别对图像像素的 RGB 三个通道进行操作，分别利用 3<em>3、5</em>5 和 9*9 尺寸的高斯模板平滑彩色图像。</p>
<p>完成程度：在完成了高斯滤波平滑灰度图像的基础上，分离彩色图像的三个通道，分别对其三个通道进行平滑处理，完成以后再合并输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 6、利用高斯模板平滑彩色图像</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gaussion_filter_color</span><span class="hljs-params">(Mat image, <span class="hljs-type">int</span> size)</span> </span>&#123;<br><br>	<span class="hljs-comment">// 分别对三个通道进行处理</span><br>	vector&lt;Mat&gt; channels;<br>	cv::<span class="hljs-built_in">split</span>(image, channels);<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>		channels[i] = <span class="hljs-built_in">gaussion_filter</span>(channels[i], size, <span class="hljs-number">1</span>);<br>	&#125;<br><br>	cv::<span class="hljs-built_in">merge</span>(channels, image);<br><br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;彩图&quot;</span>, image);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/10/02/digital-image-test03/image-20240302185124222.png" class="" title="image-20240302185124222">
<img src="/2022/10/02/digital-image-test03/image-20240302185128004.png" class="" title="image-20240302185128004">
<h3 id="7、利用-Laplacian、Robert、Sobel-模板锐化彩色图像"><a href="#7、利用-Laplacian、Robert、Sobel-模板锐化彩色图像" class="headerlink" title="7、利用 Laplacian、Robert、Sobel 模板锐化彩色图像"></a>7、利用 Laplacian、Robert、Sobel 模板锐化彩色图像</h3><p>具体内容：利用 OpenCV 分别对图像像素的 RGB 三个通道进行操作，分别利用 Laplacian、Robert、Sobel 模板锐化彩色图像。</p>
<p>完成程度：构造Laplacian、Robert、Sobel算子，分别对彩色图像的三个通道进行卷积操作，完成以后进行通道合并，并输出合并后的彩色图像。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 7、利用Laplacian、Robert、Sobel模板锐化彩色图像</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sharpen_color</span><span class="hljs-params">(Mat image)</span> </span>&#123;<br><br>	vector&lt;Mat&gt; channels;<br>	<span class="hljs-built_in">split</span>(image, channels);<br><br>	<span class="hljs-comment">// Laplacian</span><br>	vector&lt;Mat&gt; laplacian_channels = channels;<br>	vector&lt;Mat&gt; laplacian_channels_color = channels;<br><br>	vector&lt;Mat&gt; robert_channels = channels;<br>	vector&lt;Mat&gt; robert_channels_color = channels;<br><br>	vector&lt;Mat&gt; sobel_channels = channels;<br>	vector&lt;Mat&gt; sobel_channels_color = channels;<br><br>	Mat res_laplacian;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>		vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;laplacian_model = &#123; &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-4</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125; &#125;;<br>		vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;laplacian_model2 = &#123; &#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-8</span>,<span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125; &#125;;<br><br>		laplacian_channels[i] = <span class="hljs-built_in">fill_zero</span>(laplacian_channels[i], <span class="hljs-number">3</span>);<br>		laplacian_channels[i] = <span class="hljs-built_in">juanji</span>(laplacian_channels[i], laplacian_model, <span class="hljs-number">3</span>);<br><br>		<span class="hljs-built_in">subtract</span>(channels[i], laplacian_channels[i], laplacian_channels_color[i]);<br>	&#125;<br>	<span class="hljs-built_in">merge</span>(laplacian_channels, res_laplacian);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Laplacian锐化&quot;</span>, res_laplacian);<br>	<span class="hljs-built_in">merge</span>(laplacian_channels_color, res_laplacian);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Laplacian锐化处理后图片&quot;</span>, res_laplacian);<br>	<br>	<span class="hljs-comment">// Robert</span><br><br>	<span class="hljs-built_in">split</span>(image, channels);<br>	Mat res_robert;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>		vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;robert_model = &#123; &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125; &#125;;<br><br>		robert_channels[i] = <span class="hljs-built_in">fill_zero</span>(robert_channels[i], <span class="hljs-number">2</span>);<br>		robert_channels[i] = <span class="hljs-built_in">juanji</span>(robert_channels[i], robert_model, <span class="hljs-number">2</span>);<br><br>		<span class="hljs-built_in">add</span>(channels[i], robert_channels[i], robert_channels_color[i]);<br>	&#125;<br>	<span class="hljs-built_in">merge</span>(robert_channels, res_robert);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Robert锐化&quot;</span>, res_robert);<br>	<span class="hljs-built_in">merge</span>(robert_channels_color, res_robert);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Robert锐化处理后图片&quot;</span>, res_robert);<br><br>	<span class="hljs-comment">// Sobel</span><br><br>	<span class="hljs-built_in">split</span>(image, channels);<br>	Mat res_sobel;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>		vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;sobel_model = &#123; &#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-1</span>&#125;,&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125; &#125;;<br><br>		sobel_channels[i] = <span class="hljs-built_in">fill_zero</span>(sobel_channels[i], <span class="hljs-number">3</span>);<br>		sobel_channels[i] = <span class="hljs-built_in">juanji</span>(sobel_channels[i], sobel_model, <span class="hljs-number">3</span>);<br><br>		<span class="hljs-built_in">subtract</span>(channels[i], sobel_channels[i], sobel_channels_color[i]);<br>	&#125;<br>	<span class="hljs-built_in">merge</span>(sobel_channels, res_sobel);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Sobel锐化&quot;</span>, res_sobel);<br>	<span class="hljs-built_in">merge</span>(sobel_channels_color, res_sobel);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;Sobel锐化处理后图片&quot;</span>, res_sobel);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Laplacian</p>
<img src="/2022/10/02/digital-image-test03/image-20240302185142206.png" class="" title="image-20240302185142206">
<p>Robert</p>
<img src="/2022/10/02/digital-image-test03/image-20240302185150777.png" class="" title="image-20240302185150777">
<p>Sobel</p>
<img src="/2022/10/02/digital-image-test03/image-20240302185159151.png" class="" title="image-20240302185159151">]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>数字图像</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理实验-直方图均衡</title>
    <url>/2022/09/23/digital-image-test02/</url>
    <content><![CDATA[<h3 id="1、计算灰度图像的归一化直方图"><a href="#1、计算灰度图像的归一化直方图" class="headerlink" title="1、计算灰度图像的归一化直方图"></a>1、计算灰度图像的归一化直方图</h3><p>具体内容：利用OpenCV对图像像素进行操作，计算归一化直方图，并在窗口中以图形的方式显示出来。</p>
<p>完成程度：读入图片，统计不同灰度级的像素个数，并存入大小为256的数组中。设置背景画布的大小，并根据数组中的最大值最小值，将不同灰度级像素点的个数映射到画布当中，通过使用柱线的方式，绘制直方图。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 1、计算灰度图像的归一化直方图，并绘制图像</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nomalization</span><span class="hljs-params">(Mat src_image, String name)</span> </span>&#123;<br>	Mat image = src_image;<br>	<span class="hljs-type">double</span> gray_scale[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>	<span class="hljs-type">int</span> row = image.rows;<br>	<span class="hljs-type">int</span> col = image.cols;<br><br>	<span class="hljs-comment">// 统计不同灰度级的像素个数</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>			gray_scale[<span class="hljs-built_in">int</span>(image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j))] = gray_scale[<span class="hljs-built_in">int</span>(image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j))] + <span class="hljs-number">1</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 绘制直方图</span><br>	<span class="hljs-comment">// 定义背景图像灰度为255</span><br>	<span class="hljs-type">int</span> length = <span class="hljs-number">500</span>;<br>	<span class="hljs-type">int</span> heigth = <span class="hljs-number">600</span>;<br>	<span class="hljs-type">int</span> reflection = <span class="hljs-number">500</span>;<br>	<span class="hljs-comment">// 最大值映射到500</span><br>	Mat hist_image = <span class="hljs-built_in">Mat</span>(heigth, length, CV_8U, <span class="hljs-built_in">Scalar</span>(<span class="hljs-number">255</span>));<br><br>	<span class="hljs-comment">// 对灰度级进行归一化处理，先求出最大值，最小值默认为0</span><br>	<span class="hljs-type">double</span> max = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i) &#123;<br>		<span class="hljs-keyword">if</span> ((gray_scale[i]) &gt; max) &#123;<br>			max = gray_scale[i];<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 将像素点的数量映射到画布上</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i) &#123;<br>		gray_scale[i] = <span class="hljs-built_in">int</span>(gray_scale[i] * reflection / max);<br>	&#125;<br><br>	<span class="hljs-comment">// 直线绘制</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i) &#123;<br>		<span class="hljs-built_in">line</span>(hist_image, <span class="hljs-built_in">Point</span>(i * <span class="hljs-number">2</span>, heigth), <span class="hljs-built_in">Point</span>(i * <span class="hljs-number">2</span>, heigth - gray_scale[i]), Scalar::<span class="hljs-built_in">all</span>(<span class="hljs-number">0</span>));<br>		<span class="hljs-built_in">line</span>(hist_image, <span class="hljs-built_in">Point</span>(i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, heigth), <span class="hljs-built_in">Point</span>(i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, heigth - gray_scale[i]), Scalar::<span class="hljs-built_in">all</span>(<span class="hljs-number">0</span>));<br>	&#125;<br><br>	<span class="hljs-built_in">imshow</span>(name, hist_image);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/09/23/digital-image-test02/image-20240302184201998.png" class="" title="image-20240302184201998">
<h3 id="2、灰度图像直方图均衡处理"><a href="#2、灰度图像直方图均衡处理" class="headerlink" title="2、灰度图像直方图均衡处理"></a>2、灰度图像直方图均衡处理</h3><p>具体内容:通过计算归一化直方图，设计算法实现直方图均衡化处理。</p>
<p>完成程度：存储灰度图像不同灰度级的像素个数，计算不同灰度级的概率密度。利用公式Sk = （L-1）*[p(r0)到p(rk)的和]对不同灰度进行离散化，完成不同灰度的映射，将映射表存入到数组当中。遍历原始灰度图像的像素点，对照灰度映射表，完成灰度级的转化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 2、灰度图像直方图均衡化处理</span><br><span class="hljs-comment">// 直方图均衡化的表达式为：Sk = （L-1）*[p(r0)到p(rk)的和]</span><br><span class="hljs-function">Mat <span class="hljs-title">average_image</span><span class="hljs-params">(Mat src_image)</span> </span>&#123;<br>	Mat image = src_image;<br>	Mat result = src_image;<br>	<span class="hljs-type">int</span> row = image.rows;<br>	<span class="hljs-type">int</span> col = image.cols;<br>	<span class="hljs-type">int</span> all_n = row * col;<br>	<span class="hljs-type">int</span> gray_table[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>	<span class="hljs-comment">// 存储不同灰度的数量</span><br>	<span class="hljs-type">double</span> gray_scale[<span class="hljs-number">256</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>	<span class="hljs-comment">// 计算不同灰度的概率密度</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>			gray_scale[image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j)] = gray_scale[image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j)] + <span class="hljs-number">1</span>;<br>		&#125;<br>		<br>	&#125;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i) &#123;<br>		gray_scale[i] = gray_scale[i] / all_n;<br>	&#125;<br><br>	<span class="hljs-comment">// 将不同的灰度离散化</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; ++i) &#123;<br>		<span class="hljs-comment">// 求概率密度的和</span><br>		<span class="hljs-type">float</span> sum_midu = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>			sum_midu = sum_midu + gray_scale[j];<br>		&#125;<br>		gray_table[i] = <span class="hljs-built_in">int</span>(<span class="hljs-number">255</span> * sum_midu + <span class="hljs-number">0.5</span>);<br>		<span class="hljs-keyword">if</span> (gray_table[i] &gt; <span class="hljs-number">255</span>) &#123;<br>			gray_table[i] = <span class="hljs-number">255</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// 完成灰度转换</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br><br>			result.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j) = gray_table[image.<span class="hljs-built_in">at</span>&lt;uchar&gt;(i, j)];<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>过亮图像</p>
<img src="/2022/09/23/digital-image-test02/image-20240302184304968.png" class="" title="image-20240302184304968">
<p>处理过后</p>
<img src="/2022/09/23/digital-image-test02/image-20240302184311057.png" class="">
<p>过暗图像</p>
<img src="/2022/09/23/digital-image-test02/image-20240302184323543.png" class="">
<p>处理过后  </p>
<img src="/2022/09/23/digital-image-test02/image-20240302184327658.png" class="">
<h3 id="3、彩色图像直方图均衡化处理"><a href="#3、彩色图像直方图均衡化处理" class="headerlink" title="3、彩色图像直方图均衡化处理"></a>3、彩色图像直方图均衡化处理</h3><p>具体内容:在灰度图像直方图均衡处理的基础上实现彩色直方图均衡处理。</p>
<p>完成程度：将彩色图像的三个颜色通道进行分离并存储在Mat矩阵当中，调用内容2中的直方图均衡化函数，分别对三个通道的直方图进行均衡化处理，处理完毕以后对三个通道进行合并，最终显示该图像。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 3、彩色图像直方图均衡化处理</span><br><span class="hljs-comment">// 将彩色图像中的三个通道提取出来</span><br><span class="hljs-comment">// 分别做直方图均衡化处理，然后再进行合并</span><br><span class="hljs-function">Mat <span class="hljs-title">color_average</span><span class="hljs-params">(Mat src)</span> </span>&#123;<br><br>	Mat image = src;<br>	vector&lt;Mat&gt;channels;<br>	cv::<span class="hljs-built_in">split</span>(image, channels);<br><br>	channels[<span class="hljs-number">0</span>] = <span class="hljs-built_in">average_image</span>(channels[<span class="hljs-number">0</span>]);<br>	channels[<span class="hljs-number">1</span>] = <span class="hljs-built_in">average_image</span>(channels[<span class="hljs-number">1</span>]);<br>	channels[<span class="hljs-number">2</span>] = <span class="hljs-built_in">average_image</span>(channels[<span class="hljs-number">2</span>]);<br><br>	cv::<span class="hljs-built_in">merge</span>(channels, image);<br><br>	<span class="hljs-comment">//imshow(&quot;color_image&quot;, image);</span><br>	<span class="hljs-keyword">return</span> image;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>曝光不足图像处理</p>
<img src="/2022/09/23/digital-image-test02/image-20240302184347311.png" class="" title="image-20240302184347311">
<p>曝光过度图像处理</p>
<img src="/2022/09/23/digital-image-test02/image-20240302184359230.png" class="" title="image-20240302184359230">]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>数字图像</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像处理实验-图像灰度变化</title>
    <url>/2022/09/20/digital-image-test01/</url>
    <content><![CDATA[<h1 id="图像灰度变换"><a href="#图像灰度变换" class="headerlink" title="图像灰度变换"></a>图像灰度变换</h1><h3 id="1、利用Opencv读取图像"><a href="#1、利用Opencv读取图像" class="headerlink" title="1、利用Opencv读取图像"></a>1、利用Opencv读取图像</h3><p>完成程度：使用opencv中的imread（）函数完成了对图片文件“lena.bmp”的读取，并将读取的内容存储至cv中的Mat矩阵中，最后使用imshow（）函数将该图片在窗口中显示出来。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//  1、利用OpenCV读取图像</span><br><span class="hljs-function">Mat <span class="hljs-title">read_image</span><span class="hljs-params">(String path)</span> </span>&#123;<br>	Mat image = <span class="hljs-built_in">imread</span>(path, IMREAD_GRAYSCALE);<br>	Mat tmp = image.<span class="hljs-built_in">clone</span>();<br>	<span class="hljs-keyword">if</span> (image.<span class="hljs-built_in">empty</span>()) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t find the path.Please input the true path.&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-keyword">return</span> image;<br>	&#125;<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;lena.bmp&quot;</span>, tmp);<br>	<span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h3 id="2、灰度图像二值化处理"><a href="#2、灰度图像二值化处理" class="headerlink" title="2、灰度图像二值化处理"></a>2、灰度图像二值化处理</h3><p>完成程度：遍历内容1中读取的矩阵，设置阈值为128，将矩阵中大于128的像素设置为255，将矩阵中小于等于128的像素点设置为0，使用imshow（）函数输出该图片。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 2、灰度图像二值化处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">binary_image</span><span class="hljs-params">(Mat tmp)</span> </span>&#123;<br>	<span class="hljs-comment">// 设置阈值为128</span><br><br>	Mat image = <span class="hljs-built_in">Mat</span>(tmp);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; image.rows; i++) &#123;<br>		uchar* p = image.<span class="hljs-built_in">ptr</span>(i);<br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; image.cols; j++) &#123;<br>			<span class="hljs-keyword">if</span> (p[j] &gt; <span class="hljs-number">128</span>) &#123;<br>				p[j] = <span class="hljs-number">255</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				p[j] = <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;binary_image&quot;</span>, image);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<img src="/2022/09/20/digital-image-test01/image-20240302183456769.png" class="" title="image-20240302183456769">
<h3 id="3、灰度图像的对数变换"><a href="#3、灰度图像的对数变换" class="headerlink" title="3、灰度图像的对数变换"></a>3、灰度图像的对数变换</h3><p>完成程度：利用对数变化公式s=c*log(1+r)，对内容1的矩阵进行对数变化。调整不同的c的值[0.5,1,2,4,8]，对比不同的c值对图像变化的影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 3、灰度图像的对数变换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">log_reserve</span><span class="hljs-params">(Mat image)</span> </span>&#123;<br>	<span class="hljs-comment">// 对数变化的函数s = c*log(1+r)</span><br><br>	<span class="hljs-function">Mat <span class="hljs-title">scrimage</span><span class="hljs-params">(image)</span></span>;<br>	<span class="hljs-function">Mat <span class="hljs-title">new_image</span><span class="hljs-params">(scrimage.size(), scrimage.type())</span></span>;<br>	<span class="hljs-comment">// 对原图像进行加1操作</span><br>	<span class="hljs-built_in">add</span>(scrimage, <span class="hljs-built_in">Scalar</span>(<span class="hljs-number">1.0</span>), scrimage);<br>	<span class="hljs-comment">// 数据类型转化</span><br>	scrimage.<span class="hljs-built_in">convertTo</span>(scrimage, CV_64F);<br>	<span class="hljs-type">float</span> c[] = &#123; <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span> &#125;;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; <span class="hljs-number">5</span>; s++) &#123;<br>		<span class="hljs-built_in">log</span>(scrimage, new_image);<br>		new_image = c[s] * new_image;<br><br>		<span class="hljs-comment">//对图像进行归一化处理调整阈值至0-255</span><br>		<span class="hljs-built_in">normalize</span>(new_image, new_image, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, NORM_MINMAX);<br>		<span class="hljs-built_in">convertScaleAbs</span>(new_image, new_image);<br>		String str = <span class="hljs-string">&quot;c=&quot;</span> + <span class="hljs-built_in">to_string</span>(c[s]);<br>		<span class="hljs-built_in">imshow</span>(str, new_image);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/09/20/digital-image-test01/image-20240302183504049.png" class="" title="image-20240302183504049">
<img src="/2022/09/20/digital-image-test01/image-20240302183514481.png" class="" title="image-20240302183514481">
<h3 id="4、灰度图像的伽马变换"><a href="#4、灰度图像的伽马变换" class="headerlink" title="4、灰度图像的伽马变换"></a>4、灰度图像的伽马变换</h3><p>完成程度：利用伽马变化公式s=c<em>（r*</em>γ）完成了对图像的转化，其中令c默认为1，调整γ值分别为[0.1,0.4,1,2.5,10]，对比不同伽马值对图像变换的影响。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 4、灰度图像的伽马变换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gama_reserve</span><span class="hljs-params">(Mat image)</span> </span>&#123;<br>	<span class="hljs-comment">// gama变化的函数s = c*(r**gama)，取c=1</span><br>	image.<span class="hljs-built_in">convertTo</span>(image, CV_64F, <span class="hljs-number">1.0</span> / <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);<br>	<span class="hljs-function">Mat <span class="hljs-title">new_image</span><span class="hljs-params">(image.size(),image.type())</span></span>;<br><br>	<span class="hljs-type">float</span> gama[] = &#123; <span class="hljs-number">0.10</span>, <span class="hljs-number">0.40</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">10</span> &#125;;<br><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>		<span class="hljs-built_in">pow</span>(image, gama[i], new_image);<br>		new_image.<span class="hljs-built_in">convertTo</span>(new_image, CV_8U, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>);<br>		String str = <span class="hljs-string">&quot;gama=&quot;</span> + <span class="hljs-built_in">to_string</span>(gama[i]);<br>		<span class="hljs-built_in">imshow</span>(str, new_image);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/09/20/digital-image-test01/image-20240302183527447.png" class="" title="image-20240302183527447">
<img src="/2022/09/20/digital-image-test01/image-20240302183542527.png" class="" title="image-20240302183542527">
<h3 id="5、彩色图像的补色变换"><a href="#5、彩色图像的补色变换" class="headerlink" title="5、彩色图像的补色变换"></a>5、彩色图像的补色变换</h3><p>完成程度：通过imread（）函数读取“lenaRGB.bmp”彩色图像，并输出到窗口。使用容器存储彩色图像的三个通道的值，对不同的通道进行求补操作，具体操作为，用255减去原始值。将求补后的三个通道进行合并处理，并显示合并后的图像。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 5、彩色图像的补色变换</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">color_reverse</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-comment">// 读入彩色图像</span><br>	String path = <span class="hljs-string">&quot;photo/lenaRGB.bmp&quot;</span>;<br>	Mat image = <span class="hljs-built_in">imread</span>(path);<br>	<span class="hljs-keyword">if</span> (image.<span class="hljs-built_in">empty</span>()) &#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;Can&#x27;t find the path.Please input the true path.&quot;</span> &lt;&lt; endl;<br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;scr_image&quot;</span>, image);<br>	<span class="hljs-comment">// 分离三通道，并保存</span><br>	vector&lt;Mat&gt; channels;<br>	<span class="hljs-built_in">split</span>(image, channels);<br>	<span class="hljs-comment">// 求补操作</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>		channels[i] = <span class="hljs-number">255</span> - channels[i];<br>	&#125;<br>	<span class="hljs-comment">// 合并通道</span><br>	<span class="hljs-function">Mat <span class="hljs-title">new_image</span><span class="hljs-params">(image.size(), image.type())</span></span>;<br>	<span class="hljs-built_in">merge</span>(channels, new_image);<br>	<span class="hljs-built_in">imshow</span>(<span class="hljs-string">&quot;dir_image&quot;</span>, new_image);<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2022/09/20/digital-image-test01/image-20240302183548286.png" class="" title="image-20240302183548286">
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>数字图像</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
</search>
