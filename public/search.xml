<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++使用zlib库来压缩文件</title>
    <url>/2024/01/26/C-%E4%BD%BF%E7%94%A8zlib%E5%BA%93%E6%9D%A5%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="C-使用zlib库来压缩文件"><a href="#C-使用zlib库来压缩文件" class="headerlink" title="C++使用zlib库来压缩文件"></a>C++使用zlib库来压缩文件</h2><p>zlib压缩库提供内存压缩和解压缩功能，包括对未压缩的完整性检查数据，提供支持的压缩方法为：deflation，默认使用压缩数据格式为zlib格式。</p>
<p>zlib库支持读取和写入gzip(.gz)格式的文件，zlib格式旨在紧凑且快速，可用于内存和通信渠道。gzip格式设计用于文件系统上的单文件压缩，比zlib具有更大的头部以维护目录信息，并且使用与zlib不同且更慢的检查方法。</p>
<p>该库不安装任何信号处理程序。解码器检查压缩数据的一致性，因此即使在输入损坏的情况下，库也不应崩溃。</p>
<h3 id="数据流结构"><a href="#数据流结构" class="headerlink" title="数据流结构"></a>数据流结构</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span>pf (*alloc_func)(<span class="hljs-built_in">void</span>pf opaque, uInt items, uInt size);<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">void</span>   (*free_func)(<span class="hljs-built_in">void</span>pf opaque, <span class="hljs-built_in">void</span>pf address);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);</code>这个函数指针通常用于内存分配，允许用户自定义的内存分配函数</li>
<li><code>typedef void   (*free_func)(voidpf opaque, voidpf address);</code>这个函数指针通常用于内存释放，允许用户自定义的内存释放函数</li>
</ul>
<h3 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">ZEXTERN <span class="hljs-type">int</span> ZEXPORT <span class="hljs-title">deflateInit</span><span class="hljs-params">(z_streamp strm, <span class="hljs-type">int</span> level)</span></span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>level</code>表示压缩级别，要么为<code>Z_DEFAULT_COMPRESSION</code>，要么介于0-9之间，1表示最佳速度，9表示最佳压缩，0表示没有压缩，<code>Z_DEFAULT_COMPRESSION</code>默认在6级别。</li>
<li><code>deflateInit</code> 返回 <code>Z_OK</code> 如果成功，则返回 <code>Z_MEM_ERROR</code> 如果没有 足够的内存，<code>Z_STREAM_ERROR</code> <code>level</code> 不是有效的压缩级别，<code>Z_VERSION_ERROR</code> <em>zlib</em> 库版本 （<code>zlib_version</code>） 不兼容 替换为调用方 （<code>ZLIB_VERSION</code>） 假定的版本。如果没有错误消息，<code>则 msg</code> 设置为 null。<code>deflateInit</code> 不 执行任何压缩：这将由 <code>deflate（）</code> 完成。</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">ZEXTERN <span class="hljs-type">int</span> ZEXPORT <span class="hljs-title">deflate</span><span class="hljs-params">(z_streamp strm, <span class="hljs-type">int</span> flush)</span></span>;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>zlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言基本语法</title>
    <url>/2023/12/14/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="GO语言特性"><a href="#GO语言特性" class="headerlink" title="GO语言特性"></a>GO语言特性</h3><ul>
<li><p>并发编程</p>
<p>Go语言中引入了<code>goroutine</code>，通过调用<code>go</code>关键字，可以让函数以goroutine的方式进行运行，以协程为单位进行运行。</p>
<p>协程相比线程更加轻量级，也更节省系统资源。</p>
<p>goroutine内部采用管道<code>channel</code>进行消息传递，从而实现共享内存。</p>
</li>
<li><p>错误处理</p>
<p>函数通过返回错误类型<code>error</code>或者<code>bool</code>类型表明函数执行结果，通过判断返回值是否为<code>nil</code>。</p>
<p>引入了defer关键字用于标准的错误处理流程，提供内置函数<code>panic</code>，<code>recover</code>完成异常抛出和捕捉</p>
</li>
<li><p>垃圾回收</p>
<p>自带自动回收功能，不需要<code>delete</code>和<code>free</code>来释放内存</p>
</li>
<li><p>多返回值</p>
<p>支持多返回值，可以用下划线作为占用符丢掉不要的返回值</p>
</li>
<li><p>匿名函数</p>
<p>支持常规的匿名函数和闭包</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// hello.go</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">//导入fmt包，调用其中的Println()函数</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello，world！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>常量</p>
<p>使用<code>const</code>声明，可以限定常量类型，也可以不指定类型（称为字面常量）</p>
</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">const</span> limit = <span class="hljs-number">512</span><br><span class="hljs-keyword">const</span> top <span class="hljs-built_in">uint16</span> = <span class="hljs-number">1421</span><br><span class="hljs-keyword">const</span> Pi <span class="hljs-built_in">float</span>64 = <span class="hljs-number">3.1415926</span><br><span class="hljs-comment">// 多重赋值</span><br><span class="hljs-keyword">const</span> x,y <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br><br><span class="hljs-comment">// 多个常量赋值</span><br><span class="hljs-keyword">const</span> (<br>	one = <span class="hljs-number">1</span><br>	two = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure>
<ul>
<li><p>iota</p>
<p><code>iota</code>是一个可以被编译器修改的常量，在<code>const</code>关键字出现时被重置为<code>0</code>，在下一个<code>const</code>出现之前，每出现一次<code>iota</code>，所代表的数字自动加1</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    a = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//a == 0</span><br>    b = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//b ==1</span><br>    c = <span class="hljs-literal">iota</span>  <span class="hljs-comment">//c == 2</span><br>)<br><br><span class="hljs-keyword">const</span> d = <span class="hljs-literal">iota</span> <span class="hljs-comment">//d==0,因为const的出现，iota被重置为0</span><br></code></pre></td></tr></table></figure>
<ul>
<li><p>变量</p>
<p>变量使用<code>var</code>进行声明，可以使用<code>:=</code>对变量之间进行初始化，Go编译器会自动推导出该变量的类型</p>
</li>
<li><p>整型</p>
<p>可以通过<code>unsafe.Sizeof</code>函数来查看字节长度</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>byte</code></td>
<td style="text-align:left">等同于 uint8，uint8的别名</td>
</tr>
<tr>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left">依赖于不同平台下的实现，可以是 int32 或者 int64</td>
</tr>
<tr>
<td style="text-align:left"><code>int8</code></td>
<td style="text-align:left">[-128, 127]</td>
</tr>
<tr>
<td style="text-align:left"><code>int16</code></td>
<td style="text-align:left">[-32768, 32767]</td>
</tr>
<tr>
<td style="text-align:left"><code>int32</code></td>
<td style="text-align:left">[-2147483648, 2147483647]</td>
</tr>
<tr>
<td style="text-align:left"><code>int64</code></td>
<td style="text-align:left">[-9223372036854775808, 9223372036854775807]</td>
</tr>
<tr>
<td style="text-align:left"><code>rune</code></td>
<td style="text-align:left">等同于 int32，代表Unicode字符类型</td>
</tr>
<tr>
<td style="text-align:left"><code>uint</code></td>
<td style="text-align:left">依赖于不同平台下的实现，可以是 uint32 或者 uint64</td>
</tr>
<tr>
<td style="text-align:left"><code>uint8</code></td>
<td style="text-align:left">[0, 255]</td>
</tr>
<tr>
<td style="text-align:left"><code>uint16</code></td>
<td style="text-align:left">[0, 65535]</td>
</tr>
<tr>
<td style="text-align:left"><code>uint32</code></td>
<td style="text-align:left">[0, 4294967295]</td>
</tr>
<tr>
<td style="text-align:left"><code>uint64</code></td>
<td style="text-align:left">[0, 18446744073709551615]</td>
</tr>
<tr>
<td style="text-align:left"><code>uintptr</code></td>
<td style="text-align:left">一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64）</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>浮点类型</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>float32</td>
<td>±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数</td>
</tr>
<tr>
<td>float64</td>
<td>±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数</td>
</tr>
<tr>
<td>complex32</td>
<td>复数，实部和虚部都是 float32</td>
</tr>
<tr>
<td>complex64</td>
<td>复数，实部和虚部都是 float64</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>布尔类型</p>
<p><code>true</code>和<code>false</code>：布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。</p>
</li>
<li><p>字符串</p>
<ul>
<li><p>字符串可以使用双引号<code>(&quot;&quot;)</code>或者反引号来创建。双引号用来创建可解析的字符串字面量，可解析的是指字符串中的一些符号可以被格式化为其他内容，如 <code>\n</code> 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。</p>
</li>
<li><p>支持切片操作：对字符串中字符依次访问，可以使用 <code>range</code> 操作符。获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。</p>
</li>
</ul>
<p>支持的操作</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s += t</code></td>
<td>将字符串 t 追加到 s 末尾</td>
</tr>
<tr>
<td><code>s + t</code></td>
<td>将字符串 s 和 t 级联</td>
</tr>
<tr>
<td><code>s[n]</code></td>
<td>从字符串 s 中索引位置为 n 处的原始字节</td>
</tr>
<tr>
<td><code>s[n:m]</code></td>
<td>从位置 n 到位置 <code>m-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>s[n:]</code></td>
<td>从位置 n 到位置 <code>len(s)-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>s[:m]</code></td>
<td>从位置 0 到位置 <code>m-1</code> 处取得的字符（字节）串</td>
</tr>
<tr>
<td><code>len(s)</code></td>
<td>字符串 s 中的字节数</td>
</tr>
<tr>
<td><code>len([]rune(s))</code></td>
<td>字符串 s 中字符的个数，可以使用更快的方法 <code>utf8.RuneCountInString()</code></td>
</tr>
<tr>
<td><code>[]rune(s)</code></td>
<td>将字符串 s 转换为一个 unicode 值组成的串</td>
</tr>
<tr>
<td><code>string(chars)</code></td>
<td>chars 类型是 <code>[]rune</code> 或者 <code>[]int32</code>, 将之转换为字符串</td>
</tr>
<tr>
<td><code>[]byte(s)</code></td>
<td>无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节</td>
</tr>
</tbody>
</table>
</div>
<h3 id="顺序编程"><a href="#顺序编程" class="headerlink" title="顺序编程"></a>顺序编程</h3><ul>
<li><p>if</p>
<p><code>if</code>后面可以紧接一个表达式<code>optionalStatement1</code>，表达式会在进入<code>block</code>前执行，决定进入<code>block</code>分支的是布尔表达式<code>booleanExpression1</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> optionalStatement1; booleanExpression1 &#123;<br>    block1<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> optionalStatement2; booleanExpression2 &#123;<br>    block2<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    block3<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>for</p>
<p><code>for</code>循环可以遍历数组，切片，映射等类型，也可以用于无限循环</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// 无限循环</span><br>    block<br>&#125;<br><br><span class="hljs-keyword">for</span> booleanExpression &#123; <span class="hljs-comment">// while循环，在Go语言中没有while关键字</span><br><br>&#125;<br><br><span class="hljs-keyword">for</span> index, char := <span class="hljs-keyword">range</span> aString &#123; <span class="hljs-comment">// 迭代字符串</span><br><br>&#125;<br><br><span class="hljs-keyword">for</span> item := <span class="hljs-keyword">range</span> aChannel &#123; <span class="hljs-comment">// 迭代通道</span><br><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>goto</p>
<p><code>goto</code>可以实现跳转，在程序代码前定义一个标签以后可以使用goto跳转到标签</p>
</li>
<li><p>switch</p>
</li>
</ul>
<p><strong>类型处理</strong></p>
<ul>
<li><p>类型转换</p>
</li>
<li><p>类型断言</p>
<p>将空接口类型转化为我们所需要的类型，这个操作称为类型断言。（有点难懂）</p>
</li>
</ul>
<p><strong>defer</strong></p>
<ul>
<li>当函数执行到最后时，<code>defer</code>语句会按照逆序执行，最后该函数返回，<code>defer</code>会在<code>return</code>之后执行。</li>
</ul>
<h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><ul>
<li><p>自定义类型及结构体</p>
<p>Go的代码是以包结构来组织的，如果标识符（变量名，函数名，自定义类型），以大写字母开头的标识符是可以导出的，可以在任何导入了定义该标识符的包中使用，Go语言不支持继承，只支持组合。</p>
<ul>
<li></li>
</ul>
</li>
<li><p>方法</p>
</li>
<li><p>组合</p>
</li>
<li><p>接口</p>
<blockquote>
<p>接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。接口指定类型应具有的方法，类型决定如何实现这些方法。</p>
</blockquote>
<p>接口定义了一组方法的集合，任何类型只要实现了接口中定义的所有方法，就被认为实现了该接口。</p>
<p>接口在Go中的实现方式是隐式的，无需显性地声明，这种设计允许对象在不同的上下文中被看作是不同的类型，从而实现了多态性。</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// Animal 接口定义了 Speak 方法</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">interface</span> &#123;<br>    Speak() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// Dog 类型实现了 Animal 接口</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span></span> Speak() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Woof!&quot;</span><br>&#125;<br><br><span class="hljs-comment">// Cat 类型实现了 Animal 接口</span><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span></span> Speak() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Meow!&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 定义一个接口类型的变量</span><br>    <span class="hljs-keyword">var</span> animal Animal<br><br>    <span class="hljs-comment">// 可以将不同类型的对象赋值给接口变量</span><br>    animal = Dog&#123;&#125;<br>    fmt.Println(animal.Speak()) <span class="hljs-comment">// 输出: Woof!</span><br><br>    animal = Cat&#123;&#125;<br>    fmt.Println(animal.Speak()) <span class="hljs-comment">// 输出: Meow!</span><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>go语言 并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见用法</title>
    <url>/2024/01/04/git/</url>
    <content><![CDATA[<h4 id="怎样撤销一个已经push到远端的版本"><a href="#怎样撤销一个已经push到远端的版本" class="headerlink" title="怎样撤销一个已经push到远端的版本"></a>怎样撤销一个已经push到远端的版本</h4><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">每次<span class="hljs-built_in">push</span>之前线pull一下<br><br><span class="hljs-number">1</span>、查看当前提交的信息，找到需要撤回到的版本号复制，一串十六进制的数<br>git <span class="hljs-built_in">log</span><br><br><span class="hljs-number">2</span>、使用git reset<br>git reset --soft 复制的版本号<br><br><span class="hljs-number">3</span>、强制回退当前版本号<br><span class="hljs-comment">// 确认一下当前版本</span><br>git <span class="hljs-built_in">log</span><br><span class="hljs-comment">// 谨慎使用，强制使用本地仓库代码修改远程仓库</span><br>git <span class="hljs-built_in">push</span> orgin master --force<br></code></pre></td></tr></table></figure>
<h4 id="新建分支并同步到远端的分支"><a href="#新建分支并同步到远端的分支" class="headerlink" title="新建分支并同步到远端的分支"></a>新建分支并同步到远端的分支</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 在本地新建一个名字为branch_name的分支，并与远端的origin/branch_name同步</span><br>git checkout -<span class="hljs-keyword">b </span><span class="hljs-keyword">branch_name </span><span class="hljs-keyword">origin/branch_name</span><br></code></pre></td></tr></table></figure>
<h4 id="解决git-clone超时的问题"><a href="#解决git-clone超时的问题" class="headerlink" title="解决git clone超时的问题"></a>解决git clone超时的问题</h4><p>从github上clone代码仓库报错<code>Failed to connect to github.com port 443 after 21038 ms: Couldn&#39;t connect to server</code>且尝试去ping一下github官网会丢包</p>
<img src="/2024/01/04/git/image-20231204110955462.png" class="" title="image-20231204110955462">
<p>解决方案</p>
<p>修改系统的hosts，跳过域名解析的过程，直接用ip地址访问</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.30.255.112</span> github.com git<br><span class="hljs-number">185.31.16.184</span> github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure>
<img src="/2024/01/04/git/image-20231204111125551.png" class="" title="image-20231204111125551">
<p>修改hosts需要给文件更高的权限</p>
<img src="/2024/01/04/git/image-20231204111350240.png" class="" title="image-20231204111350240">
<h4 id="github中git-push出现超时的问题"><a href="#github中git-push出现超时的问题" class="headerlink" title="github中git push出现超时的问题"></a>github中git push出现超时的问题</h4><img src="/2024/01/04/git/image-20231204112945547.png" class="" title="image-20231204112945547">
<p>解决方案</p>
<p>1、打开本机的代理服务器</p>
<img src="/2024/01/04/git/image-20231204113100512.png" class="" title="image-20231204113100512">
<p>2、取消git config里面的http和https代理</p>
<img src="/2024/01/04/git/image-20231204113208566.png" class="" title="image-20231204113208566">
<p>3、设置http代理服务器</p>
<img src="/2024/01/04/git/image-20231204113304822.png" class="" title="image-20231204113304822">
<h4 id="linux中输出一个文件夹下面的所有文件名"><a href="#linux中输出一个文件夹下面的所有文件名" class="headerlink" title="linux中输出一个文件夹下面的所有文件名"></a>linux中输出一个文件夹下面的所有文件名</h4><ul>
<li><strong><code>/path/to/directory</code></strong>: 替换为目标目录的路径。</li>
<li><strong><code>-maxdepth 1</code></strong>: 限制<code>find</code>的搜索深度为1，即仅在指定的目录中搜索，而不会搜索其子目录。</li>
<li><strong><code>-type f</code></strong>: 限制搜索结果为普通文件（不包括目录和其他类型的文件）。</li>
<li><strong><code>-exec basename &#123;&#125; \;</code></strong>: 对每一个找到的文件执行<code>basename</code>命令，即输出文件的基本名称。<code>&#123;&#125;</code>是<code>find</code>命令的占位符，表示每个找到的文件的路径。<code>\;</code>表示命令结束。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">find /path/to/directory -maxdepth 1 -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">basename</span> &#123;&#125; \;<br></code></pre></td></tr></table></figure>
<h4 id="git查看远端仓库地址"><a href="#git查看远端仓库地址" class="headerlink" title="git查看远端仓库地址"></a>git查看远端仓库地址</h4><figure class="highlight dsconfig"><table><tr><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">git</span> <span class="hljs-string">remote</span> -<span class="hljs-string">v</span><br><br><span class="hljs-comment"># 更改远程仓库</span><br><span class="hljs-string">git</span> <span class="hljs-string">remote</span> <span class="hljs-built_in">set-url</span> <span class="hljs-string">origin</span> 仓库地址<br></code></pre></td></tr></table></figure>
<h4 id="查看代码贡献量"><a href="#查看代码贡献量" class="headerlink" title="查看代码贡献量"></a>查看代码贡献量</h4><blockquote>
<p>按照各个作者的修改代码总数排序</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --pretty=<span class="hljs-string">&quot;%aN&quot;</span> | <span class="hljs-built_in">sort</span> | <span class="hljs-built_in">uniq</span> -c | <span class="hljs-keyword">while</span> <span class="hljs-built_in">read</span> count author; <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;<span class="hljs-variable">$author</span> &quot;</span>; git <span class="hljs-built_in">log</span> --author=<span class="hljs-string">&quot;<span class="hljs-variable">$author</span>&quot;</span> --pretty=tformat: --numstat | awk <span class="hljs-string">&#x27;&#123; add += $1; subs += $2 &#125; END &#123; total = add + subs; printf &quot;%d\n&quot;, total &#125;&#x27;</span>; <span class="hljs-keyword">done</span> | <span class="hljs-built_in">sort</span> -rnk2<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>算法题-数组和字符串</title>
    <url>/2024/02/09/leetcode-0209/</url>
    <content><![CDATA[<h3 id="80-删除有序数组中的重复项-Ⅱ"><a href="#80-删除有序数组中的重复项-Ⅱ" class="headerlink" title="80.删除有序数组中的重复项 Ⅱ"></a><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&amp;envId=top-interview-150">80.删除有序数组中的重复项 Ⅱ</a></h3><p>给你一个有序数组 <code>nums</code> ，请你<strong>原地</strong>删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,1,1,2,2,3]</span><br>输出：<span class="hljs-number">5</span>, nums = <span class="hljs-string">[1,1,2,2,3]</span><br>解释：函数应返回新长度 length = <span class="hljs-number">5</span>, 并且原数组的前五个元素被修改为 <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>。 不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,1,2,3</span>,<span class="hljs-number">3</span>]<br>输出：<span class="hljs-number">7</span>, nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]<br>解释：函数应返回新长度 length = <span class="hljs-number">7</span>, 并且原数组的前七个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<p>使用快fast慢slow指针来遍历数组，慢指针记录数组的长度，快指针记录当前所在的元素是是否需要保留，如果需要保留则将当前位置nums[slow]存放快指针所在的元素，如果不需要保留则需要将fast++</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 因为前两个元素都是必然回保留的，所以slow和fast都从2开始</span><br>        <span class="hljs-type">int</span> slow = <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> fast = <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 使用fast来遍历</span><br>        <span class="hljs-keyword">while</span>(fast &lt; n)&#123;<br>            <span class="hljs-comment">// 如果快指针所在的元素不等于当前位置-2所在的元素</span><br>            <span class="hljs-comment">// 说明，快指针所在的位置的元素的前面至多只有slow - 1位置的元素和其相等，即至多只有一个，所以当前fast所在的位置的元素是需要保留的</span><br>            <span class="hljs-comment">// 如果相等的话，说明slow-1和slow-2和fast都相等，所以fast是不需要保留的，fast++</span><br>            <span class="hljs-keyword">if</span>(nums[slow - <span class="hljs-number">2</span>] != nums[fast])&#123;<br>                nums[slow] = nums[fast];<br>                <span class="hljs-comment">// 更新slow位置</span><br>                ++slow;<br>            &#125;<br>            ++fast;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="122-买股票的最佳时机-Ⅱ"><a href="#122-买股票的最佳时机-Ⅱ" class="headerlink" title="122.买股票的最佳时机 Ⅱ"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">122.买股票的最佳时机 Ⅱ</a></h3><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 6 </span>-<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 3 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>+<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tap"><table><tr><td class="code"><pre><code class="hljs tap">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class="hljs-number"> 5 </span>-<span class="hljs-number"> 1 </span>=<span class="hljs-number"> 4 </span>。<br>     总利润为<span class="hljs-number"> 4 </span>。<br></code></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">输入：prices = <span class="hljs-string">[7,6,4,3,1]</span><br>输出：<span class="hljs-number">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class="hljs-number">0</span> 。<br></code></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= prices[i] &lt;= 104</code></li>
</ul>
]]></content>
      <categories>
        <category>算法实践</category>
      </categories>
      <tags>
        <tag>leetcode 算法 数组 字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>平方根倒数算法</title>
    <url>/2024/01/24/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="平方根倒数算法"><a href="#平方根倒数算法" class="headerlink" title="平方根倒数算法"></a>平方根倒数算法</h3><script type="math/tex; mode=display">
1/\sqrt{x}</script><h4 id="求一个数的平方根倒数"><a href="#求一个数的平方根倒数" class="headerlink" title="求一个数的平方根倒数"></a>求一个数的平方根倒数</h4><p>对于计算机来说求一个数的平方根一般有两种方式，二分法和牛顿迭代法</p>
<ul>
<li><p>二分法</p>
<p>EXP表示精度，从0-num不断开始计算mid的平方，直到left&gt;right，此时返回right的值即为所求的平方根，其中注意边界条件：</p>
<p>当mid <em> mid = num时，此时left需要加上EXP，往后的循环中mid </em> mid 都会大于num，所以right还会不停减小，直到right &lt; left，返回right，这时right已经在精度范围内</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;<br>    <span class="hljs-type">double</span> left = <span class="hljs-number">0</span>, right = num;<br> <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">double</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br> <br>        <span class="hljs-keyword">if</span> (mid * mid &lt;= num)<br>            left = mid + EXP;<br>        <span class="hljs-keyword">else</span><br>            right = mid - EXP;<br>    &#125;   <br> <br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>牛顿迭代法</p>
<p>牛顿迭代法是将原来的求开方问题转化为数学函数问题，即假设<code>x * x = n</code>，求n的开方转化为<code>x * x - n = 0</code>的解，即<code>y = x * x - n</code>与x轴的交点</p>
<p>代码中last表示上一次的切线与x轴的交点的x坐标，初始值为num，ret表示x = last时的切线与x轴的交点，不断迭代，直到ret - last小于精度，即达到精度返回ret。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">Sqrt</span><span class="hljs-params">(<span class="hljs-type">double</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == num)<br>        <span class="hljs-keyword">return</span> num;<br> <br>    <span class="hljs-type">double</span> last = num, ret = num;<br> <br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        last = <span class="hljs-number">0.5</span> * (ret + num / ret);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span>(ret - last) &lt; EXP)<br>            <span class="hljs-keyword">break</span>;<br>        ret = last;<br>    &#125;   <br> <br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>计算完平方根过后，再计算其倒数，也是一个对计算机来说并不是很友好的运算</p>
<h4 id="快速平方根倒数计算推导"><a href="#快速平方根倒数计算推导" class="headerlink" title="快速平方根倒数计算推导"></a>快速平方根倒数计算推导</h4><p>快速平方根算法是利用了计算机存储浮点数的特性并和牛顿迭代法来共同完成的，也是一个近似计算。对于牛顿迭代法，其精髓是如果能够找到一个接近于解的初始值，是有可能通过一次迭代或者较少次数的迭代达到比较高的近似解，而快速平方根算法旨在于找到一个较为近似的初始值。具体的运算如下。</p>
<p><strong>笔记中有一处笔误0xD5F400000应改成0x5F400000</strong></p>
<img src="/2024/01/24/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E7%AE%97%E6%B3%95/%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B.png" class="" title="运算过程">
<p>快速平方根算法代码</p>
<ul>
<li>初始值由0x5F400000改为了0x5f3759df，对于X/2代码中使用了位运算加速求解</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Q_rsqrt</span><span class="hljs-params">(<span class="hljs-type">float</span> number)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> i;<br>    <span class="hljs-type">float</span> x2, y;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> threehalfs = <span class="hljs-number">1.5F</span>;<br>    x2 = number * <span class="hljs-number">0.5F</span>;<br>    y = number;<br>    i = * ( <span class="hljs-type">long</span>* ) &amp;y;							<span class="hljs-comment">// evil floating point bit hack</span><br>    i = <span class="hljs-number">0x5f3759df</span> - (i &gt;&gt; <span class="hljs-number">1</span>);					<span class="hljs-comment">// what the fuck? </span><br>    y = * ( <span class="hljs-type">float</span> * ) &amp;i;<br>    y = y * (threehalfs - ( x2 * y * y ) );		<span class="hljs-comment">// 1st iteration</span><br><span class="hljs-comment">//  y = y * (threehalfs - ( x2 * y * y ) );		// 2st iteration, can be removed</span><br>    <br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间的通信方式</title>
    <url>/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h2><p>每个进程的用户地址空间是独立的，一般情况之下，不同的进程是<strong>无法</strong>通过进程间各自的地址空间来进行互相访问，但是不同的进程所拥有的内核空间是共享的，因此如果不同进程之间需要进行通信必须要通过内核。</p>
<h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道通信分为匿名管道和命名管道，通过名字可以区分，匿名管道是无法获取和控制的管道，命名管道是通过用户可以自己建立的管道。</p>
<p>管道智能进行半双工的通信，即数据传输是单向的，如果想要实现互相通信，就需要创建两个管道。</p>
<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><ul>
<li>在linux中的<code>|</code>竖线就是一个管道，将管道符前的操作的输出作为管道符后的操作的输入</li>
</ul>
<p>一个匿名管道的创建会使用到下面的系统调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure>
<p>表示创建了一个匿名管道并返回了两个文件描述符，一个是管道读取端的描述符<code>fd[0]</code>，另一个是管道写入端的描述符<code>fd[1]</code>，<strong>匿名管道是特殊的文件，只存在于内存当中，不存在于文件系统中</strong></p>
<p>管道实际上就是内核中的一串缓存，进程通过文件描述符来对这一串缓存进行读写操作</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130223824673.png" class="" title="image-20240130223824673">
<p><strong>如果说需要实现多个进程之间的通信</strong>，可以使用<code>fork</code>操作来创建子进程，创建子进程时，子进程会同时复制父进程的文件描述符，两个进程便可以通过各自的文件描述符来进行跨进程之间的通信。</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130224638178.png" class="" title="image-20240130224638178">
<p>通过对文件描述符的开放和关闭，可以控制父进程和子进程之间的读写操作。</p>
<ul>
<li>如：父进程关闭读取的 fd[0]，只保留写入的 fd[1]；子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>
<li>便可以实现从父进程向子进程的数据写入</li>
</ul>
<p>实现多个进程之间匿名管道的通信另一种方式就是fork两个子进程，关闭父进程的文件描述符，开启子进程的<code>fd</code>，实现子进程之间的通信。</p>
<p>可以看出来，匿名管道的通信范围仅限于父子关系的进程。因为管道没有实体，没有管道文件，只能通过复制父进程的fd来使用文件描述符。</p>
<h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><ul>
<li>在linux中可以通过<code>mkfifo</code>命令来创建并指定管道名字</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkfifo</span> myPipe<br></code></pre></td></tr></table></figure>
<p>因为命名管道，提前创建了一个类型为管道的设备文件，在进程中只要使用到这个设备，便可以互相通信。</p>
<p><strong>管道的通信方式，效率较低，不适合进程间的频繁交换数据</strong></p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><blockquote>
<p>在管道通信的缺点下，消息队列可以解决进程间频繁交换数据的问题。</p>
</blockquote>
<p>消息队列是保护在内核中的消息列表，如果进程之间需要进行通信，只需要将消息放在对应的消息队列中便可以正常返回，无需阻塞等待，等到另一个进程需要的时候去消息队列中去读取便可以。</p>
<p>如果消息队列没有释放或者没有关闭操作系统，消息队列会一直存在，而匿名管道则是随着进程的生命周期的结束而销毁。</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>解决频繁交换数据的问题</p>
<p>两个进程之间就像发邮件一样可以你来我往进行沟通</p>
</li>
<li><p>进程发送消息后无需阻塞等待消息的接收</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>不适合比较大的数据传输</p>
<p>消息队列中的消息体是由结构化的数据结构来组织的，有最大长度的限制。</p>
</li>
<li><p>消息队列的通信过程中，存在用户态与内核态之间的数据拷贝开销</p>
</li>
</ul>
</li>
</ul>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存用到的是现代操作系统中的内存管理的<strong>虚拟内存技术</strong>，每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。</p>
<p><strong>共享内存的机制：拿出一块虚拟地址空间，映射到相同的物理内存中。</strong>不同的进程可以使用各自的虚拟地址访问到这一片相同的物理内存。</p>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130232827259.png" class="" title="image-20240130232827259">
<ul>
<li><p>优点</p>
<ul>
<li>解决了消息队列中不适合大的数据的通信</li>
<li>不同进程之间无需进行频繁的用户态和内核态的转换，因为进程都是在自己的用户地址空间中来进行操作</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>对共享内存的读写问题</p>
<p>因为共享内存存储的信息一旦发生改变对于不同的进程都是可见的，所以会涉及到读写一致性的问题</p>
</li>
<li><p>共享内存也变为了临界资源，存在进程进程之间的竞争</p>
<p>需要保护机制，使得共享资源在任意时刻只能被一个进程访问。</p>
</li>
</ul>
</li>
</ul>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote>
<p>信号量可以提供对临界资源的保护</p>
</blockquote>
<p>信号量是一个整型的计数器，可以用于实现进程间的互斥以及同步，不是用于缓存进程间通信的数据。</p>
<p>信号量的大小表示为资源的数量，对信号量的操作方式有两种原子操作</p>
<ul>
<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li>
<li>一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>
</ul>
<p>通过PV操作可以控制进程对资源的互斥访问以及控制进程的同步顺序，<strong>涉及到操作系统的知识</strong></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><blockquote>
<p>在进程工作异常情况下，需要通过信号来通知进程</p>
</blockquote>
<p>信号是进程间通信机制中的唯一的异步通信方式，因为可以在任何时候发送信号到某一进程，一旦有信号产生，用户就可以进行对信号处理。</p>
<ul>
<li><p>信号的处理方式</p>
<ul>
<li>执行默认操作： 例如linux中的SIGTERM 信号，就是终止进程的意思</li>
<li>捕捉信号：可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数</li>
<li>忽略信号：当不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。</li>
</ul>
</li>
<li><p><code>SIGKILL</code> 和 <code>SEGSTOP</code>无法被捕捉和忽略。</p>
</li>
</ul>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket通信实现的是在不同主机之间的通信，分为两种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式</p>
<blockquote>
<p>基于 TCP 协议的通信方式需要客户和服务器之间建立TCP连接，进行三次握手。</p>
</blockquote>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234627976.png" class="" title="image-20240130234627976">
<ul>
<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>
<li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li>
<li>服务端调用 <code>listen</code>，进行监听；</li>
<li>服务端调用 <code>accept</code>，等待客户端连接；</li>
<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>
<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>
<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>
</ul>
<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<blockquote>
<p>基于UDP的Socket通信</p>
</blockquote>
<img src="/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234754230.png" class="" title="image-20240130234754230">
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>
<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>
<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>
]]></content>
      <categories>
        <category>技术研究</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程通信</tag>
      </tags>
  </entry>
</search>
