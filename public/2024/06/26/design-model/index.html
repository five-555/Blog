<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>设计模式 | Zdon</title><meta name="author" content="Zdon"><meta name="copyright" content="Zdon"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="设计模式 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的代码编写经验。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。  设计模式六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://zdon.fun/2024/06/26/design-model/">
<meta property="og:site_name" content="Zdon">
<meta property="og:description" content="设计模式 设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的代码编写经验。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。  设计模式六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://zdon.fun/img/default_cover10.jpg">
<meta property="article:published_time" content="2024-06-26T06:19:26.000Z">
<meta property="article:modified_time" content="2024-07-12T01:51:34.627Z">
<meta property="article:author" content="Zdon">
<meta property="article:tag" content="设计模式">
<meta property="article:tag" content="UML">
<meta property="article:tag" content="软件工程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zdon.fun/img/default_cover10.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://zdon.fun/2024/06/26/design-model/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '设计模式',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-12 09:51:34'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_cover10.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Zdon"><span class="site-name">Zdon</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">设计模式</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-06-26T06:19:26.000Z" title="发表于 2024-06-26 14:19:26">2024-06-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/">技术研究</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="设计模式"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote>
<p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的代码编写经验。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
</blockquote>
<h2 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p>
<p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
<p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p>
<p>里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p>
<p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p>
<p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p>
<p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p>
<p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p>
<p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p>
<h2 id="一、工厂模式"><a href="#一、工厂模式" class="headerlink" title="一、工厂模式"></a>一、工厂模式</h2><blockquote>
<p>工厂模式是一种创建对象的方式，类似于利用统一工厂类去创建不同的对象，这样就能够让创建对象的过程和使用对象的过程进行分离。</p>
</blockquote>
<img src="/2024/06/26/design-model/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_01.png" class="" title="工厂模式_01">
<ul>
<li><p>简单工厂模式</p>
<p>  根据工厂类传入的参数来决定创建哪种类型的对象</p>
</li>
<li><p>工厂方法模式</p>
<p>  定义一个创建对象的接口，但由子类来决定实例化哪一个类，将对象的创建延迟到子类</p>
<p>  不同的产品类继承于同一个抽象产品基类，同时为每一个产品类分配一个单独的创建类，创建类继承于创建基类，创建基类中有一个用于接收产品基类返回值的抽象方法，所有的创建类会重新这个方法，并在这个方法中，创建对应的产品对象，返回给产品基类接收。</p>
<p>  在创建基类中，同时会定义一个接口方法，这个方法的实现会先通过抽象方法先创建出一个产品抽象类，并调用产品抽象类中的抽象方法，就能够达到统一调用子类方法的目的。</p>
<p>  在实际使用中，用户只需要知道创建抽象类以及抽象类中的方法即可，当我们需要使用某一个产品的时候，我们只需要通过使用创建基类的指针指向一个某一个产品的创建子类的对象，通过调用创建基类中的方法就可以完成对应的功能。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 产品基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Product</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result of the ConcreteProductA&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB</span> : <span class="hljs-keyword">public</span> Product &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">Operation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result of the ConcreteProductB&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建者基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Creator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Creator</span>() &#123;&#125;<br>    <span class="hljs-comment">// 工厂方法，用于创建产品对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Product* <span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 创建者类的业务逻辑</span><br>    <span class="hljs-function">std::string <span class="hljs-title">SomeOperation</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 调用工厂方法来创建一个产品对象</span><br>        <span class="hljs-function">std::unique_ptr&lt;Product&gt; <span class="hljs-title">product</span><span class="hljs-params">(<span class="hljs-keyword">this</span>-&gt;FactoryMethod())</span></span>;<br>        <span class="hljs-comment">// 使用产品</span><br>        std::string result = <span class="hljs-string">&quot;Creator: The same creator&#x27;s code has just worked with &quot;</span> + product-&gt;<span class="hljs-built_in">Operation</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体创建者A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreatorA</span> : <span class="hljs-keyword">public</span> Creator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Product* <span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductA</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体创建者B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCreatorB</span> : <span class="hljs-keyword">public</span> Creator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Product* <span class="hljs-title">FactoryMethod</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteProductB</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> Creator&amp; creator)</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client: I&#x27;m not aware of the creator&#x27;s class, but it still works.\n&quot;</span><br>            &lt;&lt; creator.<span class="hljs-built_in">SomeOperation</span>() &lt;&lt; std::endl;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::unique_ptr&lt;Creator&gt; creator = std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteCreatorA&gt;();<br>    <span class="hljs-built_in">ClientCode</span>(*creator);<br><br>    std::cout &lt;&lt; std::endl;<br>    <br>    creator = std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteCreatorB&gt;();<br>    <span class="hljs-built_in">ClientCode</span>(*creator);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>抽象工厂模式</p>
  <img src="/2024/06/26/design-model/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F_02.png" class="" title="工厂模式_02">
<p>  提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类</p>
<p>  我们可以看出来工厂方法模式只关注某一类产品的构建，但是我们可以通过对抽象产品的继承来丰富这一类产品的类型。如果我们有多类产品的话，那就需要用到抽象工厂了。</p>
<p>  因为我们有多类产品，所以我们会定义多个产品的抽象基类，这些产品基类会由多个产品子类来继承生成不同产品，在子类中会分别实现不同产品基类的抽象方法，如果我们需要在不同的产品类中进行通信的话，我们的抽象产品基类中应该还有一个能够将另一个产品基类作为形参传入的方法，在我们的具体产品中重写这一个方法。</p>
<p>  同样我们会有一个抽象工厂，抽象工厂中会有创建不同产品的方法，这些方法都是以抽象产品基类指针作为返回值接收。抽象工厂子类会实现这些方法，它们可以选择性的去创建不同的产品子类，只需要实现对应的抽象产品方法即可，也就是说一个工厂是有可能可以创建多类产品的，尤其是当这些产品需要进行交互的时候。</p>
<p>  下面的例子便是在具体工厂中实现多个产品的创建，当然我们只想让一个工厂对应某一类产品的话，我们只需要在对应的抽象方法中，返回<code>nullptr</code>就好了。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 抽象产品A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProductA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractProductA</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">UsefulFunctionA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 抽象产品B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractProductB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractProductB</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">UsefulFunctionB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 抽象方法，示例产品B能够与产品A进行交互</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">AnotherUsefulFunctionB</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractProductA&amp; collaborator)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品A1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA1</span> : <span class="hljs-keyword">public</span> AbstractProductA &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">UsefulFunctionA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the product A1.&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品A2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductA2</span> : <span class="hljs-keyword">public</span> AbstractProductA &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">UsefulFunctionA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the product A2.&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品B1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB1</span> : <span class="hljs-keyword">public</span> AbstractProductB &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">UsefulFunctionB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the product B1.&quot;</span>;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">AnotherUsefulFunctionB</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractProductA&amp; collaborator)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">const</span> std::string result = collaborator.<span class="hljs-built_in">UsefulFunctionA</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the B1 collaborating with ( &quot;</span> + result + <span class="hljs-string">&quot; )&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体产品B2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteProductB2</span> : <span class="hljs-keyword">public</span> AbstractProductB &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">UsefulFunctionB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the product B2.&quot;</span>;<br>    &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">AnotherUsefulFunctionB</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractProductA&amp; collaborator)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">const</span> std::string result = collaborator.<span class="hljs-built_in">UsefulFunctionA</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;The result of the B2 collaborating with ( &quot;</span> + result + <span class="hljs-string">&quot; )&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 抽象工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AbstractFactory</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;AbstractProductA&gt; <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::unique_ptr&lt;AbstractProductB&gt; <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span> : <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::unique_ptr&lt;AbstractProductA&gt; <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteProductA1&gt;();<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;AbstractProductB&gt; <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteProductB1&gt;();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体工厂2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory2</span> : <span class="hljs-keyword">public</span> AbstractFactory &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::unique_ptr&lt;AbstractProductA&gt; <span class="hljs-title">CreateProductA</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteProductA2&gt;();<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;AbstractProductB&gt; <span class="hljs-title">CreateProductB</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_unique</span>&lt;ConcreteProductB2&gt;();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClientCode</span><span class="hljs-params">(<span class="hljs-type">const</span> AbstractFactory&amp; factory)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> product_a = factory.<span class="hljs-built_in">CreateProductA</span>();<br>    <span class="hljs-keyword">auto</span> product_b = factory.<span class="hljs-built_in">CreateProductB</span>();<br>    std::cout &lt;&lt; product_b-&gt;<span class="hljs-built_in">UsefulFunctionB</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    std::cout &lt;&lt; product_b-&gt;<span class="hljs-built_in">AnotherUsefulFunctionB</span>(*product_a) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client: Testing client code with the first factory type:\n&quot;</span>;<br>    ConcreteFactory1 f1;<br>    <span class="hljs-built_in">ClientCode</span>(f1);<br><br>    std::cout &lt;&lt; std::endl;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Client: Testing the same client code with the second factory type:\n&quot;</span>;<br>    ConcreteFactory2 f2;<br>    <span class="hljs-built_in">ClientCode</span>(f2);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h2><blockquote>
<p>单例模式是一种比较常见的设计模式，在应用中十分广泛，在使用过程中用于确保一个对象中只有一个实例，并且会为这个实例提供一个全局访问点。在我们实际应用中，经常会用于一些控制资源共享的场景中，比如日志记录。因为只存在一个实例，所以需要考虑到这个实例在多线程的情况下资源竞争的问题。</p>
</blockquote>
<img src="/2024/06/26/design-model/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F_01.png" class="" title="单例模式_01">
<p>在我们的单例模式实际应用中，通常会提供一个统一的静态全局访问方法，方法名一般叫做<code>getinstance()</code>，用于获取当前单例的实例对象，而我们会根据单例的创建时机将单例模式分为两种，懒汉式和饿汉式。</p>
<ul>
<li><p>懒汉式</p>
<p>  懒汉式单例模式，指的是在我的当前工作进程中，不一定程序启动以后，单例跟着也同样进行实例化，而是只有当我们需要用到这一个单例的时候才会对这个单例进行实例化，具体的实现过程就是把单例的实例化代码写入到<code>getinstance()</code>函数中，当我们第一次调用到<code>getinstance()</code>的时候，我们会实例化这一个单例。</p>
<p>  我们会把<code>instance</code>权限设置为私有，并且提供一个静态方法，用于创建并返回单例。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 私有静态指针变量，用于持有类的唯一实例</span><br>    <span class="hljs-type">static</span> LazySingleton* instance;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// 受保护的构造函数，防止外部通过 new 创建实例</span><br>    <span class="hljs-built_in">LazySingleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 删除拷贝构造函数和赋值操作符</span><br>    <span class="hljs-built_in">LazySingleton</span>(<span class="hljs-type">const</span> LazySingleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    LazySingleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> LazySingleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 在类中提供公共的静态方法来获取实例</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> LazySingleton* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 检查是否为空</span><br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">LazySingleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>  我们可以看到在单线程的情况下，这样的代码是没有问题的，但是如果是多线程的环境下，如果我们有多个线程同时到达<code>GetInstance</code>这个函数，那么就存在有多次创建这个单例的风险，违背了我们单例模式的初衷。</p>
<p>  很显然，我们可以通过加锁来完成不同线程创建多个单例的风险规避。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-type">static</span> std::mutex mutex;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>; <span class="hljs-comment">// 加锁</span><br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::mutex Singleton::mutex;<br></code></pre></td></tr></table></figure>
<p>  这样的实现方式我们可以很明显的看出来有一些小问题，就是需要处理多线程之间的同步问题，在上面的实现方式中，无论我的实例是否已经被创建，都需要获取到锁以后才能够进入到后面的代码当中，在实际应用中，我们只有在单例未被创建的时候完成同步就可以了，如果单例已经在进程当中，那我们直接返回这个单例就行。</p>
<p>  所以，我们有了另一种实现方式</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> Singleton* instance;<br>    <span class="hljs-type">static</span> std::mutex mutex;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-built_in">Singleton</span>() &#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton* <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 第一次检查，如果单例已经存在，不需要加锁直接返回单例</span><br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mutex)</span></span>; <span class="hljs-comment">// 加锁</span><br>            <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">// 第二次检查，只有当单例不存在的时候，才会确保只有一个线程创建了单例</span><br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;;<br><br>Singleton* Singleton::instance = <span class="hljs-literal">nullptr</span>;<br>std::mutex Singleton::mutex;<br></code></pre></td></tr></table></figure>
</li>
<li><p>饿汉式</p>
<p>  可以看到，我们的主进程在初始化这个单例的时候，我们不像之前一样，把单例初始化为<code>nullptr</code>，而是切切实实的创建了这一个单例，而在我们的<code>GetInstance()</code>方法中会直接返回这一个单例，因为我们的单例已经不可能为空了。</p>
<p>  这样的方式能够避免多个单例的创建，因为创建指挥发生在主进程对类加载的时候，但是牺牲的代价是便是内存的耗费，并且我们不应该提供对这个单例销毁的方法，因为，我们销毁以后想要再次用到这个单例的话，就没有单例创建的入口了。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EagerSingleton</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 在定义变量的时候就初始化实例</span><br>    <span class="hljs-type">static</span> EagerSingleton instance;<br><br>    <span class="hljs-comment">// 私有构造函数，防止外部通过 new 创建实例</span><br>    <span class="hljs-built_in">EagerSingleton</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 删除拷贝构造函数和赋值操作符，防止拷贝和赋值</span><br>    <span class="hljs-built_in">EagerSingleton</span>(<span class="hljs-type">const</span> EagerSingleton&amp;) = <span class="hljs-keyword">delete</span>;<br>    EagerSingleton&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> EagerSingleton&amp;) = <span class="hljs-keyword">delete</span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 提供公共的静态方法来获取实例的引用</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> EagerSingleton&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-comment">// 类静态成员变量，在程序开始时即完成初始化</span><br>EagerSingleton EagerSingleton::instance;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、适配器模式"><a href="#三、适配器模式" class="headerlink" title="三、适配器模式"></a>三、适配器模式</h2><blockquote>
<p>适配器可以充当两个不兼容接口之间的桥梁，通过一个中间件，将一个类的接口转换成客户期望的另一个接口，使得原本不能工作的类能够协同工作。</p>
</blockquote>
<img src="/2024/06/26/design-model/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F_01.png" class="" title="适配器模式-01">
<p>适配器模式一般有两种方式来实现，分别是对象适配器模式，和类适配器模式。在对象适配器模式中，适配器类会继承于目标类的接口，并拥有一个需要适配的类的引用，在适配器类中就能够通过引用来调用是需要适配的方法。类适配器模式则是用到的多继承思想，适配器类通过多继承的方式，同时拥有目标类和适配类的方法。</p>
<ul>
<li>对象适配器模式  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 目标接口（Target），客户端期望的接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Target: Default behavior.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 被适配的类（Adaptee），拥有一个特殊的请求方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adaptee</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpecificRequest</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Adaptee: Specific request.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 适配器类（Adapter），使 Adaptee 与 Target 接口兼容</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adapter</span> : <span class="hljs-keyword">public</span> Target &#123;<br><span class="hljs-keyword">private</span>:<br>    Adaptee* adaptee;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Adapter</span>(Adaptee* a) : <span class="hljs-built_in">adaptee</span>(a) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        adaptee-&gt;<span class="hljs-built_in">SpecificRequest</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Adaptee* adaptee = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Adaptee</span>();<br>    Target* target = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Adapter</span>(adaptee);<br>    <br>    target-&gt;<span class="hljs-built_in">Request</span>();<br><br>    <span class="hljs-keyword">delete</span> adaptee;<br>    <span class="hljs-keyword">delete</span> target;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、装饰器模式"><a href="#四、装饰器模式" class="headerlink" title="四、装饰器模式"></a>四、装饰器模式</h2><img src="/2024/06/26/design-model/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F_01.png" class="" title="装饰器模式-01">
<p>通常我们在需要在不改变某一个类的功能的前提下为这个类提供新的拓展功能和方法的时候，我们会考虑的一种方式是通过对象的继承，在子类中写一些新的方法，这样子就能够通过使用子类来达到拓展父类功能的目的。而使用继承的方式，我们通常在编译的时候就确定了子类的相关行为。与此同时，如果一个父类存在有多个可能的变化方向，那么我们就需要通过继承的方式实现每一种组合，这样子无疑会使得我们子类的数量呈指数型暴增。</p>
<p>在这样的背景下，我们有了装饰器模式的产生。装饰器可以独立存在，更加灵活，能够动态地扩展对象的功能并且可以通过组合的方式将多个装饰应用在对象上。</p>
<p>装饰器模式通常涉及以下几个角色：</p>
<ul>
<li>Component：定义一个对象接口，可以给这些对象动态地添加职责。</li>
<li>ConcreteComponent：定义了一个具体的对象，也可以给这个对象添加一些额外的职责。</li>
<li>Decorator：持有一个组件（Component）对象的实例，并定义一个与组件接口一致的接口。</li>
<li>ConcreteDecorator：具体的装饰类，实现了在组件的接口中定义的操作，并添加新的操作，以给组件对象增加额外的职责。</li>
</ul>
<p>我们会使用一个装饰器类继承于抽象基类，并在这个装饰器类中持有一个基类的指针对象，在实现基类的方法的时候，通过这一个指针来调用其他具体子类实体的方法。同时我们会有另一个类继承于这一个装饰器类，我们可以叫做拓展装饰器类，在我们的拓展装饰器类中，我们可以拓展具体子类的新功能。这个功能的拓展可以包裹在原始功能的前后，类似于附加一个行为层。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// &quot;Component&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// &quot;ConcreteComponent&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Shape: Circle&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Shape: Rectangle&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// &quot;Decorator&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShapeDecorator</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">protected</span>:<br>    Shape* decoratedShape;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ShapeDecorator</span>(Shape* shape) : <span class="hljs-built_in">decoratedShape</span>(shape) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        decoratedShape-&gt;<span class="hljs-built_in">draw</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ShapeDecorator</span>() &#123;<br>        <span class="hljs-keyword">delete</span> decoratedShape;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// &quot;ConcreteDecorator&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedShapeDecorator</span> : <span class="hljs-keyword">public</span> ShapeDecorator &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RedShapeDecorator</span>(Shape* decoratedShape) : <span class="hljs-built_in">ShapeDecorator</span>(decoratedShape) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        ShapeDecorator::<span class="hljs-built_in">draw</span>();<br>        <span class="hljs-built_in">setRedBorder</span>(decoratedShape);   <span class="hljs-comment">// 附加的行为</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setRedBorder</span><span class="hljs-params">(Shape* decoratedShape)</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Border Color: Red&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Shape* circle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>();<br>    Shape* redCircle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RedShapeDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Circle</span>());<br>    Shape* redRectangle = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RedShapeDecorator</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Rectangle</span>());<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Circle with normal border:&quot;</span> &lt;&lt; std::endl;<br>    circle-&gt;<span class="hljs-built_in">draw</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nCircle of red border:&quot;</span> &lt;&lt; std::endl;<br>    redCircle-&gt;<span class="hljs-built_in">draw</span>();<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;\nRectangle of red border:&quot;</span> &lt;&lt; std::endl;<br>    redRectangle-&gt;<span class="hljs-built_in">draw</span>();<br><br>    <span class="hljs-keyword">delete</span> circle;<br>    <span class="hljs-keyword">delete</span> redCircle;<br>    <span class="hljs-keyword">delete</span> redRectangle;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="五、享元模式"><a href="#五、享元模式" class="headerlink" title="五、享元模式"></a>五、享元模式</h2><blockquote>
<p>享元模式主要用于减少创建对象的数量，用于减少内存占用和提高性能。享元模式会尝试重用现有的同类对象，如果我们找到了这个对象，那么就会对这个对象进行返回，如果未找这个对象，才会重新申请一个新的对象。主要目的是支持大量的细粒度对象，这些对象中有相当部分的状态可以共享。通过共享，可以在有限的内存资源下支持大规模的对象数量。</p>
</blockquote>
<img src="/2024/06/26/design-model/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F_01.png" class="" title="享元模式-01">
<p>在我们的使用过程中，通常享元模式需要定义享元抽象类，抽象类中会有子类需要共享的方法和属性，并且通过子类继承抽象类，实现对应的抽象方法，我们的子类也会拥有属于子类的独有的属性和方法。</p>
<p>同时，我们会定义一个享元工厂，享元工厂负责创建和管理享元对象，管理的方式通常使用<code>HashMap</code>哈希表的映射来完成，如果需要创建某一个对象的<code>key</code>已经存在，则说明这个对象已经存在在内存当中，可以作为享元对象直接返回，当在哈希表中找不到<code>key</code>时，才会新建一个新的对象。</p>
<p>在我们的客户端只需要维护对享元对象的引用，并计算或存储享元对象的外部状态即可。外部状态指的是，客户端用于标识具体对象的一些标志。所以在使用的过程中，应该注意的是要明确区分内部状态和外部状态，实现状态分离，以免混淆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 享元接口类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Character</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Character</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体享元类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteCharacter</span> : <span class="hljs-keyword">public</span> Character &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> glyph; <span class="hljs-comment">// 内部状态：字符本身</span><br>    <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ConcreteCharacter</span>(<span class="hljs-type">char</span> argGlyph) : <span class="hljs-built_in">glyph</span>(argGlyph) &#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Displaying character: &quot;</span> &lt;&lt; glyph &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 享元工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterFactory</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::map&lt;<span class="hljs-type">char</span>, Character*&gt; characters; <span class="hljs-comment">// 缓存已创建的享元对象</span><br>    <br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">CharacterFactory</span>() &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : characters) &#123;<br>            <span class="hljs-keyword">delete</span> pair.second;<br>        &#125;<br>        characters.<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <br>    <span class="hljs-function">Character* <span class="hljs-title">getCharacter</span><span class="hljs-params">(<span class="hljs-type">char</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (characters.<span class="hljs-built_in">find</span>(key) == characters.<span class="hljs-built_in">end</span>()) &#123;<br>            <span class="hljs-comment">// 如果字符不存在，则创建一个新的ConcreteCharacter并加入映射中</span><br>            characters[key] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteCharacter</span>(key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> characters[key];<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 客户端代码</span><br>    CharacterFactory factory;<br><br>    <span class="hljs-comment">// 创建几个字符对象</span><br>    Character* characterA = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>    Character* characterB = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;B&#x27;</span>);<br>    Character* characterA2 = factory.<span class="hljs-built_in">getCharacter</span>(<span class="hljs-string">&#x27;A&#x27;</span>); <span class="hljs-comment">// 再次请求&#x27;A&#x27;，应该得到相同的实例</span><br><br>    <span class="hljs-comment">// 显示字符</span><br>    characterA-&gt;<span class="hljs-built_in">display</span>();<br>    characterB-&gt;<span class="hljs-built_in">display</span>();<br>    characterA2-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-comment">// 检查两个‘A’是否相同</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Are the two &#x27;A&#x27; instances the same? &quot;</span> &lt;&lt; (characterA == characterA2 ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 不需要手动删除字符对象，因为由CharacterFactory管理</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="六、责任链模式"><a href="#六、责任链模式" class="headerlink" title="六、责任链模式"></a>六、责任链模式</h2><blockquote>
<p>责任链模式为请求创建了一个接收者对象的链，它允许多个对象来处理一个请求，而无需发送者知道接收者的具体信息。请求在一系列接收者对象之间传递直到被处理，每一个接收者持有下一个接收者的引用，这样接收者就形成了一条链，并且每个链上的对象将决定自己能否处理请求或者应该将请求传递给链上的下一个对象。</p>
</blockquote>
<p>责任链模式主要解决的问题是解耦发送者和接收者，使得多个对象都有可能接收请求，而发送者不需要知道哪个对象会处理它。就好像我们的发送者只需要将需要处理的请求丢给<code>handle</code>责任链上，而无需在意最后的请求是谁处理的一样，这样可以简化对象之间的连接，达到解耦的目的。</p>
<p>我们会定义一个抽象处理类，在这个处理类中会拥有一个指向下一个处理类的指针，并使用接口完成责任链的构建，我们责任链上的不同任务会通过传入的不同参数来进行标识。</p>
<p>在我们的抽象处理类中，会有一个处理请求的抽象方法，这个方法是用于遍历责任链的，如果我们的子处理类无法处理当前的请求时，我们会调用下一个处理类来完成这个请求的处理。</p>
<p>使用这样的责任链方式，我们可以减少请求方和具体实现方的耦合，我们可以发现这样的设计模式能够很好的满足设计模式中的依赖倒置原则，请求方和实现方都依赖的是抽象接口而不各自依赖。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 抽象处理器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    std::shared_ptr&lt;Handler&gt; next_handler;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Handler</span>() = <span class="hljs-keyword">default</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(std::shared_ptr&lt;Handler&gt; handler)</span> </span>&#123;<br>        next_handler = handler;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (next_handler) &#123;<br>            next_handler-&gt;<span class="hljs-built_in">handleRequest</span>(request);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体处理器类A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandlerA</span> : <span class="hljs-keyword">public</span> Handler &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (request &lt; <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 可以处理小于10的请求</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Handler A is handling request: &quot;</span> &lt;&lt; request &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_handler) &#123;<br>            next_handler-&gt;<span class="hljs-built_in">handleRequest</span>(request);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体处理器类B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteHandlerB</span> : <span class="hljs-keyword">public</span> Handler &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(<span class="hljs-type">int</span> request)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (request &gt;= <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 可以处理大于等于10的请求</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Handler B is handling request: &quot;</span> &lt;&lt; request &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (next_handler) &#123;<br>            next_handler-&gt;<span class="hljs-built_in">handleRequest</span>(request);<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> handlerA = std::<span class="hljs-built_in">make_shared</span>&lt;ConcreteHandlerA&gt;();<br>    <span class="hljs-keyword">auto</span> handlerB = std::<span class="hljs-built_in">make_shared</span>&lt;ConcreteHandlerB&gt;();<br>    <br>    handlerA-&gt;<span class="hljs-built_in">setNext</span>(handlerB); <span class="hljs-comment">// 设置责任链</span><br>    <br>    <span class="hljs-comment">// 发出请求</span><br>    handlerA-&gt;<span class="hljs-built_in">handleRequest</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">// 将由HandlerA处理</span><br>    handlerA-&gt;<span class="hljs-built_in">handleRequest</span>(<span class="hljs-number">20</span>); <span class="hljs-comment">// 将由HandlerB处理</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="七、代理模式"><a href="#七、代理模式" class="headerlink" title="七、代理模式"></a>七、代理模式</h2><blockquote>
<p>代理模式通过引入一个代理对象来控制原对象的访问。代理对象在客户端和目标对象之间充当中介，负责将客户端的请求转发给目标对象，同时可以在转发请求前后进行额外的处理，比如安全控制，延迟初始化，远程通信，记录日志等。</p>
</blockquote>
<p>代理模式实际上就是在客户端和实际服务对象之间建立一个中介层，用于在请求被送达给服务对象之前或之后执行某些操作</p>
<p>在我们的代理类中，会继承于抽象类，并拥有一个具体类的实例，如果我们想要在真实类的某一个接口的前后添加譬如日志之类的额外处理，我们可以在代理类中实现抽象类中的接口，并在这个接口的前后添加对应的功能。</p>
<ul>
<li><p>问题一、代理模式和适配器模式的区别</p>
<p>  代理模式，实现的是对另一个对象（原始被代理的对象）的控制访问，可以添加一些额外的功能，但是不应该改变原始对象的行为和功能。</p>
<p>  适配器模式，适用于连接两个不兼容的接口，涉及到两类对象，通常会由适配器继承于一个对象，并拥有另一个对象的实例，在使用适配器进行适配的时候，通过修改所继承的接口方法来调用到被适配对象的行为，即把原接口适配成另一个客户想要的接口。</p>
</li>
<li><p>问题二、代理模式和装饰器模式的区别</p>
<p>  代理模式主要用于控制对资源的访问，通常只有一个代理类，而装饰器模式旨在不改变对象的接口的情况下，为对象添加行为，可以使用多个装饰器来增强对象的功能。</p>
<p>  代理模式通常在编译时就确定了，它管理对象的生命周期并可以进行一些特定的任务，如懒加载、权限控制等；而装饰器可以在运行时递归地将装饰层嵌套起来，以此在不改变原始对象代码的基础上增强对象的行为。</p>
<p>  代理模式关注于对对象的控制，例如为远程对象提供本地代理的过程中可能会处理网络通信、线程同步等问题；装饰器模式关注于增加对象的新功能，强调的是扩展对象的行为。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 抽象主题类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Subject</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 真实主题类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSubject</span> : <span class="hljs-keyword">public</span> Subject &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;RealSubject: Handling request.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> : <span class="hljs-keyword">public</span> Subject &#123;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;RealSubject&gt; real_subject;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkAccess</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 检查访问权限的逻辑</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Proxy: Checking access prior to firing a real request.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 假设访问权限得到了验证</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logAccess</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 日志记录的逻辑</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Proxy: Logging the time of request.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Proxy</span>(std::shared_ptr&lt;RealSubject&gt; real_subject) : <span class="hljs-built_in">real_subject</span>(real_subject) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">request</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">checkAccess</span>()) &#123;<br>            <span class="hljs-keyword">this</span>-&gt;real_subject-&gt;<span class="hljs-built_in">request</span>(); <span class="hljs-comment">// 调用真实主题的方法</span><br>            <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">logAccess</span>(); <span class="hljs-comment">// 记录请求日志</span><br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 客户端代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> real_subject = std::<span class="hljs-built_in">make_shared</span>&lt;RealSubject&gt;();<br>    <span class="hljs-function">Proxy <span class="hljs-title">proxy</span><span class="hljs-params">(real_subject)</span></span>;<br>    <br>    proxy.<span class="hljs-built_in">request</span>(); <span class="hljs-comment">// 客户端使用代理完成工作</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="八、观察者模式"><a href="#八、观察者模式" class="headerlink" title="八、观察者模式"></a>八、观察者模式</h2><blockquote>
<p>观察者模式定义了一种一对多的依赖关系，当一个对象的状态发生改变时，其所有依赖者都会收到通知，并自动更新，主要用于分布式事件处理系统、消息发布/订阅机制，以及各种需要对象间解耦的场景。关键在于主题和观察者之间不直接进行通信，而是通过注册和通知机制进行交互。</p>
</blockquote>
<p>观察者模式通常包含几个核心角色</p>
<ul>
<li>主题：它是具有状态的对象，并维护这一个观察这列表。一般我们主题会提供添加、删除和通知观察者的方法</li>
<li>观察者：观察者是接收主题通知的对象。观察者会实现一个更新方法，当我们收到主题的通知时，会调用该方法进行更新操作</li>
<li>具体主题：具体主题时主题的具体实现类，会维护具体主题需要通知的观察者列表，并且在状态发生改变的时候通知观察者</li>
<li>具体观察者：具体观察者是观察者的具体实现类。不同的观察者可能会实现各自的更新方法，方法中会定义收到主题通知时要执行的具体操作</li>
</ul>
<p>在我们使用的时候，基本逻辑就是，主题维护一个观察者列表，我们需要关注这个主题的观察者通过主题的实例对象来进行注册，注册到对应的主题当中，在我们的主题中会通过实现<code>notify</code>的方法，主动的调用观察者的更新函数。</p>
<p>比较常见的场景就是<code>ros</code>的发布与订阅机制，订阅的节点通过订阅来将自己加入到具体的主题当中，当有主题到来的时候，就是状态触发的过程，就会通知各个订阅者进行相应的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-comment">// 前向声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span>;<br><br><span class="hljs-comment">// Observer接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Observer</span>() &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Subject* subject)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// Subject接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::list&lt;Observer*&gt; observers; <span class="hljs-comment">// 观察者列表</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Subject</span>() &#123;&#125;<br><br>    <span class="hljs-comment">// 注册观察者</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer* obs)</span> </span>&#123;<br>        observers.<span class="hljs-built_in">push_back</span>(obs);<br>    &#125;<br><br>    <span class="hljs-comment">// 注销观察者</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer* obs)</span> </span>&#123;<br>        observers.<span class="hljs-built_in">remove</span>(obs);<br>    &#125;<br><br>    <span class="hljs-comment">// 通知所有注册的观察者</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; observer : observers) &#123;<br>            observer-&gt;<span class="hljs-built_in">update</span>(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取状态（必须由具体的主题实现）</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体的Subject实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> : <span class="hljs-keyword">public</span> Subject &#123;<br><span class="hljs-keyword">private</span>:<br>    std::string state;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 设置新状态并通知观察者</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; newState)</span> </span>&#123;<br>        state = newState;<br>        <span class="hljs-built_in">notify</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 覆盖getState方法</span><br>    <span class="hljs-function">std::string <span class="hljs-title">getState</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体的Observer实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteObserver</span> : <span class="hljs-keyword">public</span> Observer &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Subject* subject)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (subject) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Observer received a new state: &quot;</span> &lt;&lt; subject-&gt;<span class="hljs-built_in">getState</span>() &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建主题和观察者</span><br>    ConcreteSubject* concreteSubject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteSubject</span>();<br>    Observer* observer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteObserver</span>();<br>    Observer* observer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ConcreteObserver</span>();<br><br>    <span class="hljs-comment">// 注册观察者</span><br>    concreteSubject-&gt;<span class="hljs-built_in">attach</span>(observer1);<br>    concreteSubject-&gt;<span class="hljs-built_in">attach</span>(observer2);<br><br>    <span class="hljs-comment">// 改变状态并通知观察者</span><br>    concreteSubject-&gt;<span class="hljs-built_in">setState</span>(<span class="hljs-string">&quot;state1&quot;</span>);<br><br>    <span class="hljs-comment">// 注销一个观察者并再次改变状态</span><br>    concreteSubject-&gt;<span class="hljs-built_in">detach</span>(observer1);<br>    concreteSubject-&gt;<span class="hljs-built_in">setState</span>(<span class="hljs-string">&quot;state2&quot;</span>);<br><br>    <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-keyword">delete</span> observer1;<br>    <span class="hljs-keyword">delete</span> observer2;<br>    <span class="hljs-keyword">delete</span> concreteSubject;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="九、策略模式"><a href="#九、策略模式" class="headerlink" title="九、策略模式"></a>九、策略模式</h2><p>策略模式可以定义一系列的算法行为，并且把它们封装起来，提供给客户一定的自由度，能够使它们进行互相替换，策略模式允许算法独立于使用它们的客户端的变化。</p>
<img src="/2024/06/26/design-model/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F_01.png" class="" title="策略模式-01">
<p>在C++中我们会定义一个抽象策略基类，不同的策略会继承于这个抽象类，并重写基类中需要进行策略呼唤的方法。</p>
<p>在我们客户端需要使用策略的对象当中，会有一个抽象策略基类的指针，用于引用到子类的不同策略对象实例。通过不同的策略实例的调用就能够在我们客户端用到不同的方法了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span> <span class="hljs-comment">// std::sort</span></span><br><br><span class="hljs-comment">// Strategy Interface</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortingStrategy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dataset)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">SortingStrategy</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-comment">// Concrete Strategy A: Bubble Sort</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> : <span class="hljs-keyword">public</span> SortingStrategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dataset)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-type">bool</span> swapped = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (swapped) &#123;<br>            swapped = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; dataset.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span> (dataset[i - <span class="hljs-number">1</span>] &gt; dataset[i]) &#123;<br>                    std::<span class="hljs-built_in">swap</span>(dataset[i - <span class="hljs-number">1</span>], dataset[i]);<br>                    swapped = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Concrete Strategy B: Standard Library Sort</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StdSort</span> : <span class="hljs-keyword">public</span> SortingStrategy &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; dataset)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        std::<span class="hljs-built_in">sort</span>(dataset.<span class="hljs-built_in">begin</span>(), dataset.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Context</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SortedList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; m_items;<br>    SortingStrategy* m_strategy;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SortedList</span>(SortingStrategy* strategy) : <span class="hljs-built_in">m_strategy</span>(strategy) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_strategy</span><span class="hljs-params">(SortingStrategy* strategy)</span> </span>&#123;<br>        m_strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        m_items.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span> </span>&#123;<br>        m_strategy-&gt;<span class="hljs-built_in">sort</span>(m_items);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> item : m_items) &#123;<br>            std::cout &lt;&lt; item &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">SortedList</span>() &#123;<br>        <span class="hljs-keyword">delete</span> m_strategy;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Client Code</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; dataset = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br><br>    <span class="hljs-comment">// Use BubbleSort</span><br>    SortedList* bubble_sorted_list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SortedList</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">BubbleSort</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : dataset) &#123;<br>        bubble_sorted_list-&gt;<span class="hljs-built_in">add</span>(value);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Bubble Sorted: &quot;</span>;<br>    bubble_sorted_list-&gt;<span class="hljs-built_in">sort</span>();<br>    <span class="hljs-keyword">delete</span> bubble_sorted_list;<br><br>    <span class="hljs-comment">// Use StdSort</span><br>    SortedList* std_sorted_list = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SortedList</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">StdSort</span>());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : dataset) &#123;<br>        std_sorted_list-&gt;<span class="hljs-built_in">add</span>(value);<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Std Sorted: &quot;</span>;<br>    std_sorted_list-&gt;<span class="hljs-built_in">sort</span>();<br>    <span class="hljs-keyword">delete</span> std_sorted_list;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">菜鸟教程</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://zdon.fun">Zdon</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://zdon.fun/2024/06/26/design-model/">http://zdon.fun/2024/06/26/design-model/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://zdon.fun" target="_blank">Zdon</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><a class="post-meta__tags" href="/tags/UML/">UML</a><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a></div><div class="post_share"><div class="social-share" data-image="/img/default_cover10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/09/go-function/" title="Go语言学习-函数、方法、接口"><img class="cover" src="/img/default_cover08.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go语言学习-函数、方法、接口</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/06/c-priority-queue/" title="C++优先队列用法"><img class="cover" src="/img/default_cover10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++优先队列用法</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zdon</div><div class="author-info__description">我来自偶然，像一颗尘土。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">64</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/wzd520"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://gitee.com/wzd520" target="_blank" title="Gitee"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:wuzdon@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.</span> <span class="toc-text">设计模式六大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">一、工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">二、单例模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">三、适配器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.5.</span> <span class="toc-text">四、装饰器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.</span> <span class="toc-text">五、享元模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.</span> <span class="toc-text">六、责任链模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">七、代理模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.9.</span> <span class="toc-text">八、观察者模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.10.</span> <span class="toc-text">九、策略模式</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/24/paper-mapreduce/" title="论文-MapReduce"><img src="/img/default_cover10.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论文-MapReduce"/></a><div class="content"><a class="title" href="/2024/07/24/paper-mapreduce/" title="论文-MapReduce">论文-MapReduce</a><time datetime="2024-07-24T02:18:03.000Z" title="发表于 2024-07-24 10:18:03">2024-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/12/c-stl-use/" title="C++中常见容器的使用方法"><img src="/img/default_cover09.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++中常见容器的使用方法"/></a><div class="content"><a class="title" href="/2024/07/12/c-stl-use/" title="C++中常见容器的使用方法">C++中常见容器的使用方法</a><time datetime="2024-07-12T01:52:08.000Z" title="发表于 2024-07-12 09:52:08">2024-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/11/gdb-debug/" title="如何使用GDB进行调试"><img src="/img/default_cover02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="如何使用GDB进行调试"/></a><div class="content"><a class="title" href="/2024/07/11/gdb-debug/" title="如何使用GDB进行调试">如何使用GDB进行调试</a><time datetime="2024-07-11T07:12:23.000Z" title="发表于 2024-07-11 15:12:23">2024-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/go-mutil-routine/" title="Go语言学习-协程、管道、并发"><img src="/img/default_cover01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言学习-协程、管道、并发"/></a><div class="content"><a class="title" href="/2024/07/10/go-mutil-routine/" title="Go语言学习-协程、管道、并发">Go语言学习-协程、管道、并发</a><time datetime="2024-07-10T14:10:44.000Z" title="发表于 2024-07-10 22:10:44">2024-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/10/go-base/" title="Go语言学习-基本语法"><img src="/img/default_cover05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Go语言学习-基本语法"/></a><div class="content"><a class="title" href="/2024/07/10/go-base/" title="Go语言学习-基本语法">Go语言学习-基本语法</a><time datetime="2024-07-10T09:16:50.000Z" title="发表于 2024-07-10 17:16:50">2024-07-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/default_cover10.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By Zdon</div><div class="footer_custom_text">没有人是一座孤岛</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'QABC9cDUiFvfbJkVsG3I0mp1-gzGzoHsz',
      appKey: '7s6lJmCCK7Bczu8Z93wTmEWb',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div></body></html>