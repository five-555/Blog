{"meta":{"version":1,"warehouse":"5.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/default_cover01.jpg","path":"img/default_cover01.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/default_cover.jpg","path":"img/default_cover.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/default_cover02.jpg","path":"img/default_cover02.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/default_cover03.jpg","path":"img/default_cover03.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/default_cover04.jpg","path":"img/default_cover04.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/default_cover05.jpg","path":"img/default_cover05.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon1.png","path":"img/favicon1.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/top.jpg","path":"img/top.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/top1.jpg","path":"img/top1.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/_drafts/Go语言学习笔记.md","hash":"c3b5d5ea4957dda1210ce82e0bee1e7a3b5c68cb","modified":1708412283688},{"_id":"source/_drafts/build-sample-redis.md","hash":"7db5fc67b778098984e33e066503df1a62fa1188","modified":1708251414574},{"_id":"source/_drafts/the-go-programming-language.md","hash":"8f2004b50c85098ea8f34b983afb10182a15ede1","modified":1708219369947},{"_id":"source/_drafts/database-mysql.md","hash":"57430da2308ef7873f5cfed489673f31db8f5a07","modified":1708412601754},{"_id":"source/_posts/C-使用zlib库来压缩文件.md","hash":"7c8f80d753e141e778d0c0873b9480dbe2207c91","modified":1708412186644},{"_id":"source/_posts/GANES101现代计算机图形学入门-01.md","hash":"5809383febf2acb63a03c2628f35a9a87a76ff54","modified":1708412869269},{"_id":"source/_posts/GANES101现代计算机图形学入门-02.md","hash":"66bd1628e47e7e6ad1c0ce7e0f57b448e6dd6202","modified":1708412881738},{"_id":"source/_posts/git.md","hash":"b071f49c28d68ca691cc318ac3a8bed30a4218d3","modified":1708413230025},{"_id":"source/_posts/leetcode-0209.md","hash":"9081ffca2cb3ecf8067b6500244c10e02d67aa31","modified":1708412294396},{"_id":"source/_posts/大话设计模式.md","hash":"8662932121e7b4d00fb686bd46b79ccf619a7942","modified":1708413248993},{"_id":"source/_posts/平方根倒数算法.md","hash":"a9720f0c55868fe068f91797560ef145c80ec09b","modified":1708412270347},{"_id":"source/_posts/进程间的通信方式.md","hash":"3c59a2c6a80f4df0e758963a950eaacdfab77a8b","modified":1708412158677},{"_id":"source/categories/index.md","hash":"ec5aeaff4eefefc9ade6b411ecb33bedb0c65a2d","modified":1706498468000},{"_id":"source/tags/index.md","hash":"cfd3eddf84f4f3878ac150aaef576ccbcbfbb421","modified":1706498468001},{"_id":"source/_drafts/database-mysql/image-20240218204502697.png","hash":"16d59bdcc21b422a885e7da177c5458e43b38f16","modified":1708305231033},{"_id":"source/_drafts/database-mysql/image-20240218211138993.png","hash":"a7bf2310f5850960d3a45b2f4479af922ef0f18d","modified":1708305231033},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104165645532-17084112899535.png","hash":"713d7afbd431798d5715bec456b9f2de1b61bf93","modified":1708411289958},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104165645532.png","hash":"713d7afbd431798d5715bec456b9f2de1b61bf93","modified":1699088205547},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231116154858801-17084112899536.png","hash":"beccf9c890c54d964fb72d81cab34ea965672e03","modified":1708411289959},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231116154858801.png","hash":"beccf9c890c54d964fb72d81cab34ea965672e03","modified":1700120938823},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231116155210293-17084112899537.png","hash":"68a2653c7b86805026326fd91fd2987475c74ea3","modified":1708411289959},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231116155210293.png","hash":"68a2653c7b86805026326fd91fd2987475c74ea3","modified":1700121130306},{"_id":"source/_posts/git/image-20231204113304822.png","hash":"8c059b88dc8eac379a01ff2b842f59bc9c7dfcc7","modified":1701660784834},{"_id":"source/_posts/git/image-20231204112945547.png","hash":"eff5ebfc4a4c5539cfd8dfd9c4b5dfed83f0fe11","modified":1701660585562},{"_id":"source/_posts/git/image-20231204113208566.png","hash":"be5c376a4091dc37070325f85951ccb5cd214e74","modified":1701660728573},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116165833300.png","hash":"1df24f5f6956685a0e7de541460502be6186593a","modified":1700125113319},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116165833300-17084118809565.png","hash":"1df24f5f6956685a0e7de541460502be6186593a","modified":1708411880971},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116171040632.png","hash":"ca9ef6cf8fd95302600171e190ea1a3d230fb79c","modified":1700125840653},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116171041924-17084118809567.png","hash":"ca9ef6cf8fd95302600171e190ea1a3d230fb79c","modified":1708411880972},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116171041924.png","hash":"ca9ef6cf8fd95302600171e190ea1a3d230fb79c","modified":1700125841947},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231118142833380-170841188095612.png","hash":"d43526ac594854d0fec88480beddf17b456bac52","modified":1708411880974},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231118142833380.png","hash":"d43526ac594854d0fec88480beddf17b456bac52","modified":1700288913407},{"_id":"source/_posts/平方根倒数算法/运算过程.png","hash":"452225103f084e7ffb3be1aa9d5609cc1e505016","modified":1706498120675},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164540980.png","hash":"9aa07539cca172c5f9acefa3543c964048bc6de6","modified":1699087541010},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164542395.png","hash":"9aa07539cca172c5f9acefa3543c964048bc6de6","modified":1699087542428},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164606082.png","hash":"9aa07539cca172c5f9acefa3543c964048bc6de6","modified":1699087566114},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164849274-17084112899534.png","hash":"c74c7c09c3192ca3b60bbe42fcd0964a57326f6a","modified":1708411289961},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164849274.png","hash":"c74c7c09c3192ca3b60bbe42fcd0964a57326f6a","modified":1699087729312},{"_id":"source/_posts/git/image-20231204110955462.png","hash":"a0eb304ceda27842d706b29f5dd93e231ce5b5cb","modified":1701659395495},{"_id":"source/_posts/git/image-20231204111125551.png","hash":"225fa0eec9bca8d94a18d88c25a06a7a80c95de9","modified":1701659485593},{"_id":"source/_posts/git/image-20231204111350240.png","hash":"b10c40f287f5e8933502801fe32cb3562b3f5236","modified":1701659630286},{"_id":"source/_posts/git/image-20231204113100512.png","hash":"dea8dd3f1ac6c962555a2122bedaed5565c2f11b","modified":1701660660545},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161524873-17084118809551.png","hash":"9876f75069bbf3c2b82109404ef8039fe9d3cdc0","modified":1708411880972},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161524873.png","hash":"9876f75069bbf3c2b82109404ef8039fe9d3cdc0","modified":1700122524898},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161727694-17084118809562.png","hash":"2b54f27a1f295261f97ed01b913f5807155ca5df","modified":1708411880972},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161727694.png","hash":"2b54f27a1f295261f97ed01b913f5807155ca5df","modified":1700122647724},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116170519094.png","hash":"e7f0c7e589386f9da1127b7ec7e3da50aa8de0d3","modified":1700125519117},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116170520355-17084118809566.png","hash":"e7f0c7e589386f9da1127b7ec7e3da50aa8de0d3","modified":1708411880974},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116170520355.png","hash":"e7f0c7e589386f9da1127b7ec7e3da50aa8de0d3","modified":1700125520379},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201110927.png","hash":"356119b35abde3da95cbc63e7f3194b8ab55e77c","modified":1700136670957},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201112834-17084118809569.png","hash":"356119b35abde3da95cbc63e7f3194b8ab55e77c","modified":1708411880974},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201139440-170841188095610.png","hash":"f10b268c53316cdc2f77b6168d2d5803ac1416fd","modified":1708411880975},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201112834.png","hash":"356119b35abde3da95cbc63e7f3194b8ab55e77c","modified":1700136672865},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201139440.png","hash":"f10b268c53316cdc2f77b6168d2d5803ac1416fd","modified":1700136699471},{"_id":"source/_posts/平方根倒数算法/WTF.png","hash":"58a5cfc1e84918f49258973ec18f362bee15a510","modified":1706512915448},{"_id":"source/_posts/进程间的通信方式/image-20240130223824673.png","hash":"936c1b00abc4de2fb48bb478b04683e98d9f2fd3","modified":1706663488898},{"_id":"source/_posts/进程间的通信方式/image-20240130223920751.png","hash":"936c1b00abc4de2fb48bb478b04683e98d9f2fd3","modified":1706663488898},{"_id":"source/_drafts/database-mysql/Mysql.png","hash":"a88e0da8c928deb7a463092864da4ca1457807b9","modified":1708219369938},{"_id":"source/_drafts/database-mysql/image-20240210160421874.png","hash":"8f012f4795a0b4b44d76204a6dbd9e7f569c8f14","modified":1708219369939},{"_id":"source/_drafts/database-mysql/image-20240218221919863.png","hash":"6b143cda1f4a832532a3b02eaf4f17f822419218","modified":1708305231047},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104113151777-17084112899531.png","hash":"371116c9fa15e1f073c48e143e356dcf0ec6eda6","modified":1708411289959},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104113151777.png","hash":"371116c9fa15e1f073c48e143e356dcf0ec6eda6","modified":1699068711820},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104113201064.png","hash":"371116c9fa15e1f073c48e143e356dcf0ec6eda6","modified":1699068721113},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161842894.png","hash":"8baa04211e4bf3b301d6a804e2d00f80c9c58479","modified":1700122722924},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116164956551-17084118809564.png","hash":"3fa6c847173dd62697db1c1ada123010901501b4","modified":1708411880975},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161842894-17084118809563.png","hash":"8baa04211e4bf3b301d6a804e2d00f80c9c58479","modified":1708411880975},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116164956551.png","hash":"3fa6c847173dd62697db1c1ada123010901501b4","modified":1700124596581},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116200444279-17084118809568.png","hash":"0e3d6cc22828451b4bda030dfc545529f8728afb","modified":1708411881002},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116200444279.png","hash":"0e3d6cc22828451b4bda030dfc545529f8728afb","modified":1700136284319},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231118142130480-170841188095611.png","hash":"4f03cb3c8844b6927cc1877cdf73b1a9b230f649","modified":1708411881021},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231118142130480.png","hash":"4f03cb3c8844b6927cc1877cdf73b1a9b230f649","modified":1700288490526},{"_id":"source/_posts/进程间的通信方式/image-20240130224638178.png","hash":"3fc74a884e2c346ccf3ff5bdfb1c8d0923d91404","modified":1706663488900},{"_id":"source/_posts/进程间的通信方式/image-20240130232827259.png","hash":"fbf784ce1ad312d9fd7a41e90b73d800ae2e0fba","modified":1706663488902},{"_id":"source/_posts/进程间的通信方式/image-20240130234754230.png","hash":"fd658ca22bb8d21052c0f10e8225855134402c10","modified":1706663488907},{"_id":"source/_drafts/database-mysql/image-20240218212814126.png","hash":"55a69f62cda07a32605ef6c451eea99ff5772d1b","modified":1708305231039},{"_id":"source/_drafts/database-mysql/image-20240218212115878.png","hash":"86bcc05425e727adec4a58fb0d8d8374c43d6ac8","modified":1708305231035},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164704660-17084112899533.png","hash":"cfeacbbd7028c9598c655135169d4cc611841ee4","modified":1708411289965},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164704660.png","hash":"cfeacbbd7028c9598c655135169d4cc611841ee4","modified":1699087624718},{"_id":"source/_drafts/database-mysql/image-20240216163439353.png","hash":"839776a0910307166c289c050a25f340654055af","modified":1708219369946},{"_id":"source/_drafts/database-mysql/image-20240218212542921.png","hash":"0c5e855a8d2f1c2b6b256a96be4e664183c26035","modified":1708305231037},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104150955701-17084112899532.png","hash":"d1faec91913f175c08eea064a74a7ac6c5be6003","modified":1708411290002},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104150955701.png","hash":"d1faec91913f175c08eea064a74a7ac6c5be6003","modified":1699081795771},{"_id":"source/_posts/进程间的通信方式/image-20240130234556499.png","hash":"20d40b4a577854ace6eb9c63582074db879a5238","modified":1706663488904},{"_id":"source/_posts/进程间的通信方式/image-20240130234627976.png","hash":"aa7514d29a51d8d39068e1f27127c68c88501b9b","modified":1706663488905},{"_id":"source/_drafts/the-go-programming-language/top_img.png","hash":"7c8dfda83b70c5fffb637da49d3f165b52f61334","modified":1708219369949},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104112951691.png","hash":"0972bd7591904fe1733153f47e7e74284fdc8707","modified":1699068591768},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/IMG_0318(20231116-164749).PNG","hash":"09a82fb967e2f791df4bcc6f3c85ee4cc8148de2","modified":1700124586515},{"_id":"source/_posts/大话设计模式/image-20231008153018253.png","hash":"50691e5e0809c8e9fffe3965645d4101301b58b2","modified":1708412964316},{"_id":"source/_drafts/database-mysql/image-20240216162803064.png","hash":"d80d6df3550320d2e6b1dc5499772fb4f9297e85","modified":1708219369941},{"_id":"source/_drafts/database-mysql/image-20240216162850762.png","hash":"a71b628d4448bb69cc84eaf2ff3310619701b361","modified":1708219369943},{"_id":"source/_drafts/database-mysql/image-20240216162915509.png","hash":"a71b628d4448bb69cc84eaf2ff3310619701b361","modified":1708219369945},{"_id":"source/_drafts/database-mysql/image-20240218221534161.png","hash":"5066c5f9fef1b8e7e218baa3bb3fc172fc506c6a","modified":1708305231041},{"_id":"source/_drafts/database-mysql/image-20240218221539849.png","hash":"5066c5f9fef1b8e7e218baa3bb3fc172fc506c6a","modified":1708305231043},{"_id":"source/_drafts/database-mysql/image-20240218221642388.png","hash":"71d50c0b9c73756391dbeed74775fd4db4393103","modified":1708305231046},{"_id":"source/_drafts/database-mysql/image-20240218223950361.png","hash":"8f8cbaef5982874765d1c1a22ea909e01074e425","modified":1708305231050},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/games101.png","hash":"1a98c119c680bafa350624b8da492f2c4fb24283","modified":1708411653458},{"_id":"source/_drafts/database-mysql/image-20240218224016746.png","hash":"1e5fc6e8f4b410247d56509afce5304ff85c5a9f","modified":1708305231052},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1706498468001},{"_id":"themes/butterfly/README_CN.md","hash":"9d729ee2ffc5e5f703ccfbfbbb7b286d59071125","modified":1706498468002},{"_id":"themes/butterfly/README.md","hash":"20a91bea7f7ada8b8195d2abff106a7ce21bba20","modified":1706498468002},{"_id":"themes/butterfly/_config.yml","hash":"9000741d245a7624b5a544526d16e33e4c2530f7","modified":1708219369953},{"_id":"themes/butterfly/package.json","hash":"58300c8f776c115ac8e069a39e9460faafc60122","modified":1706498468037},{"_id":"themes/butterfly/plugins.yml","hash":"5dea6a045a9b33b35809c7f180f256431a6fba09","modified":1706498468037},{"_id":"themes/butterfly/languages/default.yml","hash":"90e9e2f36dc51aa77eb7804ae048b4876035b12d","modified":1706498468004},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"2dcc70a011b37890215ae0fd6d8f8c78aa8af6b0","modified":1706498468005},{"_id":"themes/butterfly/layout/archive.pug","hash":"bc77220dfc269b8faad0930e1a4142ebf68165e5","modified":1706498468005},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"1392e7b8c678cdfb54f55523693e66abc7d80538","modified":1706498468005},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1706498468005},{"_id":"themes/butterfly/languages/en.yml","hash":"68127be0e6b44cfc5f31353d8b275c02939b3ff9","modified":1706498468004},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1706498468036},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1706498468036},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1706498468005},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1706498468037},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1706498468036},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1706498468006},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1706498468005},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"ea8d4e8ac6af93cd268ba8f6ffcb80417bc2501e","modified":1706498468006},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1706498468011},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1706498468013},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1706498468015},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1706498468038},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"f448bf73103b88de4443e52d600e871cf3de3e32","modified":1706498468015},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1706498468038},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1706498468039},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1706498468039},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5ed2d7ef240c927fe1b7a7fb5bf9e55e2bfd55a5","modified":1706498468040},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"0df22d7dbfa766a65cb6032a1f003348f4307cfe","modified":1706498468041},{"_id":"themes/butterfly/scripts/events/merge_config.js","hash":"b1dfc3c898b886eab1241b068fc27d7a26a3b7d2","modified":1706498468039},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"0a336dfe5ed08952fa0df1532421df38a74a20d6","modified":1706498468040},{"_id":"themes/butterfly/source/css/var.styl","hash":"950250f66faeb611a67540e0fa6cedbcf5a7a321","modified":1706498468102},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1706498468041},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1706498468040},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"b12895e0765d596494e5526d121de0dd5a7c23d3","modified":1706498468041},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"cdd992c8577d583c237b6aac9f5077d8200879b2","modified":1706498468041},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1706498468101},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"b55f71347d2ead097c7f98c0ec792b091433345c","modified":1706498468042},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1706498468042},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c74d6a9b8f71e69447f7847a5f5e81555d68b140","modified":1706498468042},{"_id":"themes/butterfly/scripts/helpers/series.js","hash":"17c0095bc8d612a268cdcab000b1742dc4c6f811","modified":1706498468043},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"164d5f1c2d1b4cb5a813a6fc574016743a53c019","modified":1706498468084},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1706498468084},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"7ec77b3093f5de67e7032f40a5b12f1389f6f6ff","modified":1706498468084},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"5d08c3552f7d3c80a724ca628bff66321abe2e5a","modified":1706498468085},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"c863d2732ce4bdc084f2d0db92f50f80328c1007","modified":1706498468085},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"b013dc0a3d57d2caa18b89263f23871da9ec456d","modified":1706498468085},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"289f85847c58f0b2b7d98a68e370a2896edb8949","modified":1706498468086},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"e68d8d21f3a86e3646907a3685550ee20e8d4a9f","modified":1706498468086},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"7c448886f230adb4f4a0208c88fff809abcb5637","modified":1706498468087},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"35d54adc92e717cc32e13515122b025fd1a98ea2","modified":1706498468086},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"e611074a5a7f489a8b04afac0a3f7f882ce26532","modified":1706498468087},{"_id":"themes/butterfly/scripts/tag/series.js","hash":"dc56e5182dd3813dc977c9bf8556dcc7615e467b","modified":1706498468086},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1706498468102},{"_id":"themes/butterfly/source/img/favicon1.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1708219369988},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1706498468103},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1706498468006},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"d776c670e4076ad6049dbb64cdee7a734b51d37f","modified":1706498468105},{"_id":"themes/butterfly/source/js/utils.js","hash":"7b871fe0c4456660cff4c7b9cc4ed089adac2caf","modified":1706498468105},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1706498468006},{"_id":"themes/butterfly/source/js/main.js","hash":"59cd756a94ecdf3ec7b18f50691a8a6305f7a65a","modified":1706498468104},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"39e1ca0a54eb5fd3688a78737417a1aaa50914c9","modified":1706498468007},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1706498468007},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1706498468007},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1706498468009},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"a7c929b90ae52b78b39b1728e3ab0e3db1cb7b9a","modified":1706498468008},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1706498468010},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1706498468011},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1706498468009},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1706498468009},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1706498468010},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"e7b25a322ae861dca06d458d3f914220e92758cf","modified":1706498468010},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1706498468010},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1706498468011},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1706498468011},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"194a5f310dccecee3ae0b648e4e5318f6fbbddcd","modified":1706498468012},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1706498468012},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1706498468012},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"0abad416b1974a17e5be7817931d5fe799180170","modified":1706498468015},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1706498468013},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1706498468013},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"912df10a053db3135968e92b6fd1a707ee94c968","modified":1706498468015},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1706498468032},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1706498468011},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1706498468033},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1706498468034},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1706498468033},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1706498468034},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1706498468034},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1706498468034},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"d48d77af1670bd568d784794408bf524a448bfcc","modified":1706498468035},{"_id":"themes/butterfly/layout/includes/widget/card_post_series.pug","hash":"e0bb72fa0ce15964b11b8fe421cae3432394e35f","modified":1706498468034},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1706498468035},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1706498468035},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1706498468035},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1706498468016},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"8df529f71e25f1c0a00e533de7944ed3d1ba7bd8","modified":1706498468036},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"43014bfc63583d3ee8808d526dd165848c0ed52f","modified":1706498468025},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1706498468036},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"41054740cfbd1357138785464f6859681ca58493","modified":1706498468089},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1706498468029},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"9b734d99963f3e7f562597dcf60485ccbf6e961c","modified":1706498468029},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1706498468090},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1706498468030},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1706498468032},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"e920dae9ce00177922468db49240f5aca0af4f64","modified":1706498468088},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"0421da07907b3d98df64239e073b23fbb3f04149","modified":1706498468088},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"aae70ddd126b2e40158e45036abecbfa33cbfbba","modified":1706498468092},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"fbfce4d67cacd1df22fb73d89d008693f59d9d91","modified":1706498468092},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"5e27f7842af82ff7498d4b59787ce9ca90fa9e6f","modified":1706498468093},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1706498468092},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1706498468093},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"66a7a0e3c58ac23c81afe9fe18834b9db9c42698","modified":1706498468093},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1706498468093},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1706498468094},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"7ae27854a737a02eca89b0b92db94cb298fef59e","modified":1706498468094},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"c0b11a1a5f52e3a6af4e312a8134c93eda18a7dd","modified":1706498468094},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"0322237e762db401d7b4aa33168d0b9334a9ec26","modified":1706498468094},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"80ee9d0bfe5d38aac1f0cdcea5fc88b71d310041","modified":1706498468095},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1706498468096},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1706498468097},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1706498468095},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1706498468097},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1706498468097},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1706498468097},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1706498468098},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"a977cd8161ef4d6ddd5293e81403519076657430","modified":1706498468098},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"dbc855795a881f8c805bf5c9c5c4d5d542a648ec","modified":1706498468096},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"a22fd15048d21452f0015d0765d295d730203308","modified":1706498468096},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1706498468098},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1706498468099},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1706498468099},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"8a53d7ba5ca2f5eb4124b684e7845b648583f658","modified":1706498468099},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"3e9355b76f87e2ee90f652855282b37ab5ae0b3e","modified":1706498468100},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1706498468100},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1706498468100},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1706498468100},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1706498468101},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1706498468101},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"353b95f9a6c2c1e777d978118cb61f909ccbf89c","modified":1706498468101},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1706498468101},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"4929382bd60788d34752a66e2fe764ef797a72a0","modified":1706498468101},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"a7c2fe73cc05ad3525909b86ad0ede1a9f2d3b48","modified":1706498468104},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"ab3904451ae1d78903424b8b2ef815c8571e1749","modified":1706498468104},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"8f95aca305b56ccd7c8c7367b03d26db816ebd5f","modified":1706498468016},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1706498468016},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1706498468016},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d6fff5a7f84c8b09f282f9ddc0020a68a8aac9ea","modified":1706498468017},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1706498468017},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1706498468017},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1706498468017},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1706498468018},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1706498468018},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"fd2320ee25507bb8ef49f932c2d170586b44ea4d","modified":1706498468018},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1706498468019},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1706498468019},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"2dc9f36085ed33d040549fa3954e8fdecf1e5c6d","modified":1706498468021},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1706498468019},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1706498468020},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"364d1fd655baca9132038ef1e312abde2c0bc7de","modified":1706498468021},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1706498468020},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1706498468020},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"f78c9c20c86d58c7cf099f6f8d6097103d7d43e5","modified":1706498468021},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"11f5dca1432e59f22955aaf4ac3e9de6b286d887","modified":1706498468022},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"1c86c8fc1a28514a02a1f6a25ca9ec05eb3955b7","modified":1706498468022},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"1eab7ca1cb16c6786f9c3ca0efef8cc15e444ab4","modified":1706498468022},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1706498468022},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"09c2ef4bc6d005f96dfa48b1d9af1ec095c5266d","modified":1706498468022},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"7f450664e6323a076ae59c393b0f22167cfa82e5","modified":1706498468024},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"db6713d2b90eb8183f86ac92c26761a8501c0ddb","modified":1706498468022},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b65a42167df5fb07e2a63f312a58c321d3112a90","modified":1706498468024},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"0b44f6de0f5632b55298d506833f45dae46a6346","modified":1706498468024},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"6de0c412a4d9b65c576ec79e1949925823c90fa6","modified":1706498468026},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"a7d794987bde815607206254df6549a5a53e2cb0","modified":1706498468025},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"d8898e427acd91ceb97d6a7ee3acb011ca86b9fc","modified":1706498468026},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"4ed7c74087e81c6fcaf4fca7dced58b4e19f4cb1","modified":1706498468024},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1706498468026},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"a4e52188b6effeee1df2a01dcbf4105de76a61a8","modified":1706498468028},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"fc8814bd016d039874ec2fc24dcb78587892e2a6","modified":1706498468026},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"17520a86de12ae585289463c066d3ac91b78a2ff","modified":1706498468028},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"0544d91c0bc9e26e0fe1b5ff490f4a8540ed1ee1","modified":1706498468028},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1706498468025},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1706498468026},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1706498468026},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"c682e4d61017fb0dd2e837bfcc242371f1a13364","modified":1706498468026},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ecfff55b2c7f6d87ce4d5028fdf9f8c0bf155c73","modified":1706498468028},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"c16ee69b5ca8db016db0508d014ae0867c4ce929","modified":1706498468031},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1706498468031},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1706498468089},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1706498468031},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1706498468090},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1706498468089},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1706498468090},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"7c9cc43e1d2577f7151039d58e603c30860fd281","modified":1706498468090},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"52a06a2e039f44383085333cac69f3f4e7d0ad3a","modified":1706498468030},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1706498468030},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1706498468031},{"_id":"source/_drafts/database-mysql/image-20240218203730285.png","hash":"58aa795f7dd5051c2210c20e36c50eb6848a4894","modified":1708305231032},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"420a86e73d0d748ac234fd00d06d9e433ca5e3f2","modified":1706498468031},{"_id":"themes/butterfly/source/img/default_cover02.jpg","hash":"50a203fee7a6bf84dbfb0137f7722f77c84f5185","modified":1708219369976},{"_id":"themes/butterfly/source/img/favicon.png","hash":"ec2d958aec90f0f78f63204dc666249245d82874","modified":1708219369988},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/games101.png","hash":"a2e563a31f101e2738c018c49d06a7852f6991a2","modified":1708411794945},{"_id":"themes/butterfly/source/img/default_cover04.jpg","hash":"334596f7acdbef99d4c559373cd99d38c48443e1","modified":1708219369982},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/games101_top.png","hash":"4aa5011abc438708eedf39a4d8dc56f84e4c9cf9","modified":1708411830222},{"_id":"themes/butterfly/source/img/default_cover01.jpg","hash":"4dade0ce40b7859166847e1738648ce6baae16fb","modified":1708219369974},{"_id":"themes/butterfly/source/img/default_cover03.jpg","hash":"3a1d6989ee9d5bd02b9bd8a6f7a5c712933b5612","modified":1708219369980},{"_id":"themes/butterfly/source/img/top.jpg","hash":"7d273fdd1fe40b1963b785a2129ec50c0f5b9274","modified":1708219369991},{"_id":"themes/butterfly/source/img/top1.jpg","hash":"c0191d684560b2afeb1b35332afd9b2f4ded8a62","modified":1708219369995},{"_id":"themes/butterfly/source/img/default_cover05.jpg","hash":"869b63bab373166df318d3096ee731c4a8c2ebcc","modified":1708219369987},{"_id":"themes/butterfly/source/img/default_cover.jpg","hash":"b4569d598530850e667d2b80fd20c7b4e0ddfdcd","modified":1708219369971},{"_id":"public/search.xml","hash":"88f37d95e0f5498b8f9d242ce6710d292e77fbd1","modified":1708413495020},{"_id":"public/categories/index.html","hash":"9bab70dbf29d0db9f39d6e8a595cc25aed4c84de","modified":1708413495020},{"_id":"public/tags/index.html","hash":"133b07525e2f850fa8cec99187c4a6792ee23e69","modified":1708413495020},{"_id":"public/2024/02/20/大话设计模式/index.html","hash":"9e341483618a7f4580e7b2ab49ec853c76ac3f0f","modified":1708413495020},{"_id":"public/2024/02/09/leetcode-0209/index.html","hash":"df0526d10ffc33f9ba47f643399b015e1e4f4d0d","modified":1708413495020},{"_id":"public/2024/01/30/进程间的通信方式/index.html","hash":"3608f0fc4a15ac5deb0a87d0f3d7cdedea1efb9e","modified":1708413495020},{"_id":"public/2024/01/26/C-使用zlib库来压缩文件/index.html","hash":"abcd444f8711312500d4f141605e24cbffa732bb","modified":1708413495020},{"_id":"public/2024/01/24/平方根倒数算法/index.html","hash":"4d7bdef2be59ab0e3c2a74063e2ccaefd7bb903b","modified":1708413495020},{"_id":"public/2024/01/04/git/index.html","hash":"0d8440d60f3777a12f74c6bfa0cbcc26cbf25517","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/index.html","hash":"0810cb807c974e13a6341631bb9294343e10a4ed","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/index.html","hash":"f5b36e39ebb4f5e3a6d74163e376a5e3c9e05987","modified":1708413495020},{"_id":"public/archives/index.html","hash":"fcd52d50394e0e829f5d522b1d0d037592e5f22f","modified":1708413495020},{"_id":"public/archives/2023/index.html","hash":"02a7e8b57f85218064415e7c250592fe11f3bb6a","modified":1708413495020},{"_id":"public/archives/2023/12/index.html","hash":"0ac606e4b91c1106fd0e1e60901b11813b4dd288","modified":1708413495020},{"_id":"public/archives/2024/index.html","hash":"a3bbb6fc077267ea67b0af7390ded8aa191dd73a","modified":1708413495020},{"_id":"public/archives/2024/01/index.html","hash":"cc34995c62ce383054c418bdd58c3f0960e35433","modified":1708413495020},{"_id":"public/archives/2024/02/index.html","hash":"26ae4d3c04839642d45cba2207bc1385e0ea54b9","modified":1708413495020},{"_id":"public/categories/技术研究/index.html","hash":"2f6465ff4bc9609aea6a6990699ea04818b69b18","modified":1708413495020},{"_id":"public/categories/学习笔记/index.html","hash":"f6c330c64879af8398ba2fcbabb6ff37c5d6c014","modified":1708413495020},{"_id":"public/categories/算法实践/index.html","hash":"e0a58cd5bf7d05bda1deb32ac4e4dee42da08b95","modified":1708413495020},{"_id":"public/index.html","hash":"4b958d1c7f2743fdb5fde696253e71d94a08fa93","modified":1708413495020},{"_id":"public/tags/C/index.html","hash":"4c45317dd61b062b0c965a83a3949945f2a9630c","modified":1708413495020},{"_id":"public/tags/zlib/index.html","hash":"df0fe2cf35879f9907827f189af1fbd91cda5ae6","modified":1708413495020},{"_id":"public/tags/计算机图形学-GAMES101/index.html","hash":"339144373ca754121c75754b489eacafa56443ac","modified":1708413495020},{"_id":"public/tags/git/index.html","hash":"5e6b3b76347bd61ce5c3d0db84de7a2173f1c289","modified":1708413495020},{"_id":"public/tags/leetcode-算法-数组-字符串/index.html","hash":"dc64239bc04e46002cb8980325b1e7ad9013f020","modified":1708413495020},{"_id":"public/tags/设计模式-UML/index.html","hash":"6c52407a352f384daf6a0ad7c14120089bde9d6f","modified":1708413495020},{"_id":"public/tags/数学/index.html","hash":"d454984dca54104ff949eccb481801fa26db2495","modified":1708413495020},{"_id":"public/tags/算法/index.html","hash":"5d6e32581f4fa29914460e82fe23222799d330d3","modified":1708413495020},{"_id":"public/tags/操作系统/index.html","hash":"abc635414a4d2922a75ac04434632df362335b02","modified":1708413495020},{"_id":"public/tags/进程通信/index.html","hash":"ec5221c975f4708cab53f63695580069d166f4aa","modified":1708413495020},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1708413495020},{"_id":"public/img/favicon1.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1708413495020},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104165645532-17084112899535.png","hash":"713d7afbd431798d5715bec456b9f2de1b61bf93","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104165645532.png","hash":"713d7afbd431798d5715bec456b9f2de1b61bf93","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231116154858801-17084112899536.png","hash":"beccf9c890c54d964fb72d81cab34ea965672e03","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231116154858801.png","hash":"beccf9c890c54d964fb72d81cab34ea965672e03","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231116155210293-17084112899537.png","hash":"68a2653c7b86805026326fd91fd2987475c74ea3","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231116155210293.png","hash":"68a2653c7b86805026326fd91fd2987475c74ea3","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116165833300-17084118809565.png","hash":"1df24f5f6956685a0e7de541460502be6186593a","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116165833300.png","hash":"1df24f5f6956685a0e7de541460502be6186593a","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116171040632.png","hash":"ca9ef6cf8fd95302600171e190ea1a3d230fb79c","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116171041924-17084118809567.png","hash":"ca9ef6cf8fd95302600171e190ea1a3d230fb79c","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116171041924.png","hash":"ca9ef6cf8fd95302600171e190ea1a3d230fb79c","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231118142833380-170841188095612.png","hash":"d43526ac594854d0fec88480beddf17b456bac52","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231118142833380.png","hash":"d43526ac594854d0fec88480beddf17b456bac52","modified":1708413495020},{"_id":"public/2024/01/04/git/image-20231204112945547.png","hash":"eff5ebfc4a4c5539cfd8dfd9c4b5dfed83f0fe11","modified":1708413495020},{"_id":"public/2024/01/04/git/image-20231204113304822.png","hash":"8c059b88dc8eac379a01ff2b842f59bc9c7dfcc7","modified":1708413495020},{"_id":"public/2024/01/04/git/image-20231204113208566.png","hash":"be5c376a4091dc37070325f85951ccb5cd214e74","modified":1708413495020},{"_id":"public/2024/01/24/平方根倒数算法/运算过程.png","hash":"452225103f084e7ffb3be1aa9d5609cc1e505016","modified":1708413495020},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"982e19bbba01db904832ad94ecffb5c75036181a","modified":1708413495020},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1708413495020},{"_id":"public/css/index.css","hash":"57ca0dc0906ca46518668e83b0f0473a2fff7ff0","modified":1708413495020},{"_id":"public/js/tw_cn.js","hash":"f8d2e3f31468991a7f5171cbfdb157dfb86d3372","modified":1708413495020},{"_id":"public/js/main.js","hash":"0dac585446445e0c419b86eec5580bc9b0657dc6","modified":1708413495020},{"_id":"public/js/utils.js","hash":"8e6b48d294e7aeaba8ff6348c43b2271cf865547","modified":1708413495020},{"_id":"public/js/search/algolia.js","hash":"108988d046da9a4716148df43b3975217c8ceaae","modified":1708413495020},{"_id":"public/js/search/local-search.js","hash":"e1f60ebac53a3f596fd0a4769b4f9275c48c6542","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104164540980.png","hash":"9aa07539cca172c5f9acefa3543c964048bc6de6","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104164542395.png","hash":"9aa07539cca172c5f9acefa3543c964048bc6de6","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104164606082.png","hash":"9aa07539cca172c5f9acefa3543c964048bc6de6","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104164849274-17084112899534.png","hash":"c74c7c09c3192ca3b60bbe42fcd0964a57326f6a","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104164849274.png","hash":"c74c7c09c3192ca3b60bbe42fcd0964a57326f6a","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116161524873-17084118809551.png","hash":"9876f75069bbf3c2b82109404ef8039fe9d3cdc0","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116161727694.png","hash":"2b54f27a1f295261f97ed01b913f5807155ca5df","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116161727694-17084118809562.png","hash":"2b54f27a1f295261f97ed01b913f5807155ca5df","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116170519094.png","hash":"e7f0c7e589386f9da1127b7ec7e3da50aa8de0d3","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116170520355-17084118809566.png","hash":"e7f0c7e589386f9da1127b7ec7e3da50aa8de0d3","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116170520355.png","hash":"e7f0c7e589386f9da1127b7ec7e3da50aa8de0d3","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116201112834-17084118809569.png","hash":"356119b35abde3da95cbc63e7f3194b8ab55e77c","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116201110927.png","hash":"356119b35abde3da95cbc63e7f3194b8ab55e77c","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116201139440-170841188095610.png","hash":"f10b268c53316cdc2f77b6168d2d5803ac1416fd","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116201139440.png","hash":"f10b268c53316cdc2f77b6168d2d5803ac1416fd","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116201112834.png","hash":"356119b35abde3da95cbc63e7f3194b8ab55e77c","modified":1708413495020},{"_id":"public/2024/01/04/git/image-20231204110955462.png","hash":"a0eb304ceda27842d706b29f5dd93e231ce5b5cb","modified":1708413495020},{"_id":"public/2024/01/04/git/image-20231204111125551.png","hash":"225fa0eec9bca8d94a18d88c25a06a7a80c95de9","modified":1708413495020},{"_id":"public/2024/01/04/git/image-20231204111350240.png","hash":"b10c40f287f5e8933502801fe32cb3562b3f5236","modified":1708413495020},{"_id":"public/2024/01/04/git/image-20231204113100512.png","hash":"dea8dd3f1ac6c962555a2122bedaed5565c2f11b","modified":1708413495020},{"_id":"public/2024/01/24/平方根倒数算法/WTF.png","hash":"58a5cfc1e84918f49258973ec18f362bee15a510","modified":1708413495020},{"_id":"public/2024/01/30/进程间的通信方式/image-20240130223824673.png","hash":"936c1b00abc4de2fb48bb478b04683e98d9f2fd3","modified":1708413495020},{"_id":"public/2024/01/30/进程间的通信方式/image-20240130223920751.png","hash":"936c1b00abc4de2fb48bb478b04683e98d9f2fd3","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116161524873.png","hash":"9876f75069bbf3c2b82109404ef8039fe9d3cdc0","modified":1708413495020},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"0cc2b1c6000e9941268768ad3aff2ed9d6f1856f","modified":1708413495020},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"43d4529ba2f1204484109138f2bd7ff25afa24ff","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104113201064.png","hash":"371116c9fa15e1f073c48e143e356dcf0ec6eda6","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104113151777-17084112899531.png","hash":"371116c9fa15e1f073c48e143e356dcf0ec6eda6","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104113151777.png","hash":"371116c9fa15e1f073c48e143e356dcf0ec6eda6","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116161842894-17084118809563.png","hash":"8baa04211e4bf3b301d6a804e2d00f80c9c58479","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116161842894.png","hash":"8baa04211e4bf3b301d6a804e2d00f80c9c58479","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116164956551-17084118809564.png","hash":"3fa6c847173dd62697db1c1ada123010901501b4","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116164956551.png","hash":"3fa6c847173dd62697db1c1ada123010901501b4","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116200444279-17084118809568.png","hash":"0e3d6cc22828451b4bda030dfc545529f8728afb","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231116200444279.png","hash":"0e3d6cc22828451b4bda030dfc545529f8728afb","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231118142130480-170841188095611.png","hash":"4f03cb3c8844b6927cc1877cdf73b1a9b230f649","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/image-20231118142130480.png","hash":"4f03cb3c8844b6927cc1877cdf73b1a9b230f649","modified":1708413495020},{"_id":"public/2024/01/30/进程间的通信方式/image-20240130224638178.png","hash":"3fc74a884e2c346ccf3ff5bdfb1c8d0923d91404","modified":1708413495020},{"_id":"public/2024/01/30/进程间的通信方式/image-20240130232827259.png","hash":"fbf784ce1ad312d9fd7a41e90b73d800ae2e0fba","modified":1708413495020},{"_id":"public/2024/01/30/进程间的通信方式/image-20240130234754230.png","hash":"fd658ca22bb8d21052c0f10e8225855134402c10","modified":1708413495020},{"_id":"public/img/default_cover02.jpg","hash":"50a203fee7a6bf84dbfb0137f7722f77c84f5185","modified":1708413495020},{"_id":"public/img/favicon.png","hash":"ec2d958aec90f0f78f63204dc666249245d82874","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104164704660-17084112899533.png","hash":"cfeacbbd7028c9598c655135169d4cc611841ee4","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104164704660.png","hash":"cfeacbbd7028c9598c655135169d4cc611841ee4","modified":1708413495020},{"_id":"public/assets/algolia/algoliasearch.js","hash":"5ac1ea04228fc1fe7ba0e8d5d7e92422a6898352","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104150955701-17084112899532.png","hash":"d1faec91913f175c08eea064a74a7ac6c5be6003","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104150955701.png","hash":"d1faec91913f175c08eea064a74a7ac6c5be6003","modified":1708413495020},{"_id":"public/2024/01/30/进程间的通信方式/image-20240130234556499.png","hash":"20d40b4a577854ace6eb9c63582074db879a5238","modified":1708413495020},{"_id":"public/2024/01/30/进程间的通信方式/image-20240130234627976.png","hash":"aa7514d29a51d8d39068e1f27127c68c88501b9b","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/image-20231104112951691.png","hash":"0972bd7591904fe1733153f47e7e74284fdc8707","modified":1708413495020},{"_id":"public/2024/02/20/大话设计模式/image-20231008153018253.png","hash":"50691e5e0809c8e9fffe3965645d4101301b58b2","modified":1708413495020},{"_id":"public/img/default_cover04.jpg","hash":"334596f7acdbef99d4c559373cd99d38c48443e1","modified":1708413495020},{"_id":"public/2023/12/15/GANES101现代计算机图形学入门-01/games101.png","hash":"1a98c119c680bafa350624b8da492f2c4fb24283","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/IMG_0318(20231116-164749).PNG","hash":"09a82fb967e2f791df4bcc6f3c85ee4cc8148de2","modified":1708413495020},{"_id":"public/img/default_cover01.jpg","hash":"4dade0ce40b7859166847e1738648ce6baae16fb","modified":1708413495020},{"_id":"public/img/default_cover03.jpg","hash":"3a1d6989ee9d5bd02b9bd8a6f7a5c712933b5612","modified":1708413495020},{"_id":"public/img/top.jpg","hash":"7d273fdd1fe40b1963b785a2129ec50c0f5b9274","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/games101.png","hash":"a2e563a31f101e2738c018c49d06a7852f6991a2","modified":1708413495020},{"_id":"public/img/top1.jpg","hash":"c0191d684560b2afeb1b35332afd9b2f4ded8a62","modified":1708413495020},{"_id":"public/2023/12/16/GANES101现代计算机图形学入门-02/games101_top.png","hash":"4aa5011abc438708eedf39a4d8dc56f84e4c9cf9","modified":1708413495020},{"_id":"public/img/default_cover05.jpg","hash":"869b63bab373166df318d3096ee731c4a8c2ebcc","modified":1708413495020},{"_id":"public/img/default_cover.jpg","hash":"b4569d598530850e667d2b80fd20c7b4e0ddfdcd","modified":1708413495020}],"Category":[{"name":"技术研究","_id":"clsu1a9xq0008g4c2hs0wck01"},{"name":"学习笔记","_id":"clsu1a9xs000dg4c2ef2mbedu"},{"name":"算法实践","_id":"clsu1a9xw000pg4c2dgc1594l"}],"Data":[],"Page":[{"title":"分类","date":"2024-01-26T15:56:15.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2024-01-26 23:56:15\ntype: \"categories\"\n---\n","updated":"2024-01-29T03:21:08.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clsu1a9xi0000g4c22gl6dt16","content":"","cover":"/img/default_cover02.jpg","cover_type":"img","excerpt":"","more":""},{"title":"标签","date":"2024-01-26T15:53:19.000Z","type":"tags","orderby":"random","order":1,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2024-01-26 23:53:19\ntype: \"tags\"\norderby: random\norder: 1\n---\n","updated":"2024-01-29T03:21:08.001Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clsu1a9xm0002g4c277vpeg08","content":"","cover":"/img/default_cover03.jpg","cover_type":"img","excerpt":"","more":""}],"Post":[{"title":"Go语言基本语法","date":"2023-12-14T09:16:50.000Z","cover":"/img/default_cover05.jpg","top_img":null,"_content":"\n## 基本语法\n\n### GO语言特性\n\n* 并发编程\n\n  Go语言中引入了`goroutine`，通过调用`go`关键字，可以让函数以goroutine的方式进行运行，以协程为单位进行运行。\n\n  协程相比线程更加轻量级，也更节省系统资源。\n\n  goroutine内部采用管道`channel`进行消息传递，从而实现共享内存。\n\n* 错误处理\n\n  函数通过返回错误类型`error`或者`bool`类型表明函数执行结果，通过判断返回值是否为`nil`。\n\n  引入了defer关键字用于标准的错误处理流程，提供内置函数`panic`，`recover`完成异常抛出和捕捉\n\n* 垃圾回收\n\n  自带自动回收功能，不需要`delete`和`free`来释放内存\n\n* 多返回值\n\n  支持多返回值，可以用下划线作为占用符丢掉不要的返回值\n\n* 匿名函数\n\n  支持常规的匿名函数和闭包\n\n```go\n// hello.go\n\npackage main\n\nimport (\n    \"fmt\" //导入fmt包，调用其中的Println()函数\n)\n\nfunc main() {\n    fmt.Println(\"Hello，world！\")\n}\n```\n\n### 数据类型\n\n* 常量\n\n  使用`const`声明，可以限定常量类型，也可以不指定类型（称为字面常量）\n\n```\nconst limit = 512\nconst top uint16 = 1421\nconst Pi float64 = 3.1415926\n// 多重赋值\nconst x,y int = 1,2\n\n// 多个常量赋值\nconst (\n\tone = 1\n\ttwo = 2\n)\n```\n\n* iota\n\n  `iota`是一个可以被编译器修改的常量，在`const`关键字出现时被重置为`0`，在下一个`const`出现之前，每出现一次`iota`，所代表的数字自动加1\n\n```\nconst (\n    a = iota  //a == 0\n    b = iota  //b ==1\n    c = iota  //c == 2\n)\n\nconst d = iota //d==0,因为const的出现，iota被重置为0\n```\n\n* 变量\n\n  变量使用`var`进行声明，可以使用`:=`对变量之间进行初始化，Go编译器会自动推导出该变量的类型\n\n* 整型\n\n  可以通过`unsafe.Sizeof`函数来查看字节长度\n\n| 类型      | 说明                                                         |\n| :-------- | :----------------------------------------------------------- |\n| `byte`    | 等同于 uint8，uint8的别名                                    |\n| `int`     | 依赖于不同平台下的实现，可以是 int32 或者 int64              |\n| `int8`    | [-128, 127]                                                  |\n| `int16`   | [-32768, 32767]                                              |\n| `int32`   | [-2147483648, 2147483647]                                    |\n| `int64`   | [-9223372036854775808, 9223372036854775807]                  |\n| `rune`    | 等同于 int32，代表Unicode字符类型                            |\n| `uint`    | 依赖于不同平台下的实现，可以是 uint32 或者 uint64            |\n| `uint8`   | [0, 255]                                                     |\n| `uint16`  | [0, 65535]                                                   |\n| `uint32`  | [0, 4294967295]                                              |\n| `uint64`  | [0, 18446744073709551615]                                    |\n| `uintptr` | 一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64） |\n\n* 浮点类型\n\n| 类型      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| float32   | ±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数 |\n| float64   | ±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数 |\n| complex32 | 复数，实部和虚部都是 float32                                 |\n| complex64 | 复数，实部和虚部都是 float64                                 |\n\n* 布尔类型\n\n  `true`和`false`：布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。\n\n* 字符串\n\n  * 字符串可以使用双引号`(\"\")`或者反引号来创建。双引号用来创建可解析的字符串字面量，可解析的是指字符串中的一些符号可以被格式化为其他内容，如 `\\n` 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。\n\n  * 支持切片操作：对字符串中字符依次访问，可以使用 `range` 操作符。获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。\n\n  支持的操作\n\n| 语法             | 描述                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| `s += t`         | 将字符串 t 追加到 s 末尾                                     |\n| `s + t`          | 将字符串 s 和 t 级联                                         |\n| `s[n]`           | 从字符串 s 中索引位置为 n 处的原始字节                       |\n| `s[n:m]`         | 从位置 n 到位置 `m-1` 处取得的字符（字节）串                 |\n| `s[n:]`          | 从位置 n 到位置 `len(s)-1` 处取得的字符（字节）串            |\n| `s[:m]`          | 从位置 0 到位置 `m-1` 处取得的字符（字节）串                 |\n| `len(s)`         | 字符串 s 中的字节数                                          |\n| `len([]rune(s))` | 字符串 s 中字符的个数，可以使用更快的方法 `utf8.RuneCountInString()` |\n| `[]rune(s)`      | 将字符串 s 转换为一个 unicode 值组成的串                     |\n| `string(chars)`  | chars 类型是 `[]rune` 或者 `[]int32`, 将之转换为字符串       |\n| `[]byte(s)`      | 无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节 |\n\n### 顺序编程\n\n* if\n\n  `if`后面可以紧接一个表达式`optionalStatement1`，表达式会在进入`block`前执行，决定进入`block`分支的是布尔表达式`booleanExpression1`\n\n```go\nif optionalStatement1; booleanExpression1 {\n    block1\n} else if optionalStatement2; booleanExpression2 {\n    block2\n} else {\n    block3\n}\n```\n\n* for\n\n  `for`循环可以遍历数组，切片，映射等类型，也可以用于无限循环\n\n```go\nfor { // 无限循环\n    block\n}\n\nfor booleanExpression { // while循环，在Go语言中没有while关键字\n\n}\n\nfor index, char := range aString { // 迭代字符串\n\n}\n\nfor item := range aChannel { // 迭代通道\n\n}\n```\n\n* goto\n\n  `goto`可以实现跳转，在程序代码前定义一个标签以后可以使用goto跳转到标签\n\n* switch\n\n**类型处理**\n\n* 类型转换\n\n* 类型断言\n\n  将空接口类型转化为我们所需要的类型，这个操作称为类型断言。（有点难懂）\n\n**defer**\n\n* 当函数执行到最后时，`defer`语句会按照逆序执行，最后该函数返回，`defer`会在`return`之后执行。\n\n### 面向对象编程\n\n* 自定义类型及结构体\n\n  Go的代码是以包结构来组织的，如果标识符（变量名，函数名，自定义类型），以大写字母开头的标识符是可以导出的，可以在任何导入了定义该标识符的包中使用，Go语言不支持继承，只支持组合。\n\n  * \n\n* 方法\n\n* 组合\n\n* 接口\n\n  > 接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。接口指定类型应具有的方法，类型决定如何实现这些方法。\n\n  接口定义了一组方法的集合，任何类型只要实现了接口中定义的所有方法，就被认为实现了该接口。\n\n  接口在Go中的实现方式是隐式的，无需显性地声明，这种设计允许对象在不同的上下文中被看作是不同的类型，从而实现了多态性。\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Animal 接口定义了 Speak 方法\ntype Animal interface {\n    Speak() string\n}\n\n// Dog 类型实现了 Animal 接口\ntype Dog struct{}\n\nfunc (d Dog) Speak() string {\n    return \"Woof!\"\n}\n\n// Cat 类型实现了 Animal 接口\ntype Cat struct{}\n\nfunc (c Cat) Speak() string {\n    return \"Meow!\"\n}\n\nfunc main() {\n    // 定义一个接口类型的变量\n    var animal Animal\n\n    // 可以将不同类型的对象赋值给接口变量\n    animal = Dog{}\n    fmt.Println(animal.Speak()) // 输出: Woof!\n\n    animal = Cat{}\n    fmt.Println(animal.Speak()) // 输出: Meow!\n}\n```\n\n","source":"_drafts/Go语言学习笔记.md","raw":"---\ntitle: Go语言基本语法\ndate: 2023-12-14 17:16:50\ntags: [go语言 并发]\ncategories: 学习笔记\ncover: /img/default_cover05.jpg\ntop_img:\n---\n\n## 基本语法\n\n### GO语言特性\n\n* 并发编程\n\n  Go语言中引入了`goroutine`，通过调用`go`关键字，可以让函数以goroutine的方式进行运行，以协程为单位进行运行。\n\n  协程相比线程更加轻量级，也更节省系统资源。\n\n  goroutine内部采用管道`channel`进行消息传递，从而实现共享内存。\n\n* 错误处理\n\n  函数通过返回错误类型`error`或者`bool`类型表明函数执行结果，通过判断返回值是否为`nil`。\n\n  引入了defer关键字用于标准的错误处理流程，提供内置函数`panic`，`recover`完成异常抛出和捕捉\n\n* 垃圾回收\n\n  自带自动回收功能，不需要`delete`和`free`来释放内存\n\n* 多返回值\n\n  支持多返回值，可以用下划线作为占用符丢掉不要的返回值\n\n* 匿名函数\n\n  支持常规的匿名函数和闭包\n\n```go\n// hello.go\n\npackage main\n\nimport (\n    \"fmt\" //导入fmt包，调用其中的Println()函数\n)\n\nfunc main() {\n    fmt.Println(\"Hello，world！\")\n}\n```\n\n### 数据类型\n\n* 常量\n\n  使用`const`声明，可以限定常量类型，也可以不指定类型（称为字面常量）\n\n```\nconst limit = 512\nconst top uint16 = 1421\nconst Pi float64 = 3.1415926\n// 多重赋值\nconst x,y int = 1,2\n\n// 多个常量赋值\nconst (\n\tone = 1\n\ttwo = 2\n)\n```\n\n* iota\n\n  `iota`是一个可以被编译器修改的常量，在`const`关键字出现时被重置为`0`，在下一个`const`出现之前，每出现一次`iota`，所代表的数字自动加1\n\n```\nconst (\n    a = iota  //a == 0\n    b = iota  //b ==1\n    c = iota  //c == 2\n)\n\nconst d = iota //d==0,因为const的出现，iota被重置为0\n```\n\n* 变量\n\n  变量使用`var`进行声明，可以使用`:=`对变量之间进行初始化，Go编译器会自动推导出该变量的类型\n\n* 整型\n\n  可以通过`unsafe.Sizeof`函数来查看字节长度\n\n| 类型      | 说明                                                         |\n| :-------- | :----------------------------------------------------------- |\n| `byte`    | 等同于 uint8，uint8的别名                                    |\n| `int`     | 依赖于不同平台下的实现，可以是 int32 或者 int64              |\n| `int8`    | [-128, 127]                                                  |\n| `int16`   | [-32768, 32767]                                              |\n| `int32`   | [-2147483648, 2147483647]                                    |\n| `int64`   | [-9223372036854775808, 9223372036854775807]                  |\n| `rune`    | 等同于 int32，代表Unicode字符类型                            |\n| `uint`    | 依赖于不同平台下的实现，可以是 uint32 或者 uint64            |\n| `uint8`   | [0, 255]                                                     |\n| `uint16`  | [0, 65535]                                                   |\n| `uint32`  | [0, 4294967295]                                              |\n| `uint64`  | [0, 18446744073709551615]                                    |\n| `uintptr` | 一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64） |\n\n* 浮点类型\n\n| 类型      | 说明                                                         |\n| --------- | ------------------------------------------------------------ |\n| float32   | ±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数 |\n| float64   | ±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数 |\n| complex32 | 复数，实部和虚部都是 float32                                 |\n| complex64 | 复数，实部和虚部都是 float64                                 |\n\n* 布尔类型\n\n  `true`和`false`：布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。\n\n* 字符串\n\n  * 字符串可以使用双引号`(\"\")`或者反引号来创建。双引号用来创建可解析的字符串字面量，可解析的是指字符串中的一些符号可以被格式化为其他内容，如 `\\n` 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。\n\n  * 支持切片操作：对字符串中字符依次访问，可以使用 `range` 操作符。获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。\n\n  支持的操作\n\n| 语法             | 描述                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| `s += t`         | 将字符串 t 追加到 s 末尾                                     |\n| `s + t`          | 将字符串 s 和 t 级联                                         |\n| `s[n]`           | 从字符串 s 中索引位置为 n 处的原始字节                       |\n| `s[n:m]`         | 从位置 n 到位置 `m-1` 处取得的字符（字节）串                 |\n| `s[n:]`          | 从位置 n 到位置 `len(s)-1` 处取得的字符（字节）串            |\n| `s[:m]`          | 从位置 0 到位置 `m-1` 处取得的字符（字节）串                 |\n| `len(s)`         | 字符串 s 中的字节数                                          |\n| `len([]rune(s))` | 字符串 s 中字符的个数，可以使用更快的方法 `utf8.RuneCountInString()` |\n| `[]rune(s)`      | 将字符串 s 转换为一个 unicode 值组成的串                     |\n| `string(chars)`  | chars 类型是 `[]rune` 或者 `[]int32`, 将之转换为字符串       |\n| `[]byte(s)`      | 无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节 |\n\n### 顺序编程\n\n* if\n\n  `if`后面可以紧接一个表达式`optionalStatement1`，表达式会在进入`block`前执行，决定进入`block`分支的是布尔表达式`booleanExpression1`\n\n```go\nif optionalStatement1; booleanExpression1 {\n    block1\n} else if optionalStatement2; booleanExpression2 {\n    block2\n} else {\n    block3\n}\n```\n\n* for\n\n  `for`循环可以遍历数组，切片，映射等类型，也可以用于无限循环\n\n```go\nfor { // 无限循环\n    block\n}\n\nfor booleanExpression { // while循环，在Go语言中没有while关键字\n\n}\n\nfor index, char := range aString { // 迭代字符串\n\n}\n\nfor item := range aChannel { // 迭代通道\n\n}\n```\n\n* goto\n\n  `goto`可以实现跳转，在程序代码前定义一个标签以后可以使用goto跳转到标签\n\n* switch\n\n**类型处理**\n\n* 类型转换\n\n* 类型断言\n\n  将空接口类型转化为我们所需要的类型，这个操作称为类型断言。（有点难懂）\n\n**defer**\n\n* 当函数执行到最后时，`defer`语句会按照逆序执行，最后该函数返回，`defer`会在`return`之后执行。\n\n### 面向对象编程\n\n* 自定义类型及结构体\n\n  Go的代码是以包结构来组织的，如果标识符（变量名，函数名，自定义类型），以大写字母开头的标识符是可以导出的，可以在任何导入了定义该标识符的包中使用，Go语言不支持继承，只支持组合。\n\n  * \n\n* 方法\n\n* 组合\n\n* 接口\n\n  > 接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。接口指定类型应具有的方法，类型决定如何实现这些方法。\n\n  接口定义了一组方法的集合，任何类型只要实现了接口中定义的所有方法，就被认为实现了该接口。\n\n  接口在Go中的实现方式是隐式的，无需显性地声明，这种设计允许对象在不同的上下文中被看作是不同的类型，从而实现了多态性。\n\n```go\npackage main\n\nimport \"fmt\"\n\n// Animal 接口定义了 Speak 方法\ntype Animal interface {\n    Speak() string\n}\n\n// Dog 类型实现了 Animal 接口\ntype Dog struct{}\n\nfunc (d Dog) Speak() string {\n    return \"Woof!\"\n}\n\n// Cat 类型实现了 Animal 接口\ntype Cat struct{}\n\nfunc (c Cat) Speak() string {\n    return \"Meow!\"\n}\n\nfunc main() {\n    // 定义一个接口类型的变量\n    var animal Animal\n\n    // 可以将不同类型的对象赋值给接口变量\n    animal = Dog{}\n    fmt.Println(animal.Speak()) // 输出: Woof!\n\n    animal = Cat{}\n    fmt.Println(animal.Speak()) // 输出: Meow!\n}\n```\n\n","slug":"Go语言学习笔记","published":0,"updated":"2024-02-20T06:58:03.688Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xk0001g4c2fqeo1na1","content":"<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"GO语言特性\"><a href=\"#GO语言特性\" class=\"headerlink\" title=\"GO语言特性\"></a>GO语言特性</h3><ul>\n<li><p>并发编程</p>\n<p>Go语言中引入了<code>goroutine</code>，通过调用<code>go</code>关键字，可以让函数以goroutine的方式进行运行，以协程为单位进行运行。</p>\n<p>协程相比线程更加轻量级，也更节省系统资源。</p>\n<p>goroutine内部采用管道<code>channel</code>进行消息传递，从而实现共享内存。</p>\n</li>\n<li><p>错误处理</p>\n<p>函数通过返回错误类型<code>error</code>或者<code>bool</code>类型表明函数执行结果，通过判断返回值是否为<code>nil</code>。</p>\n<p>引入了defer关键字用于标准的错误处理流程，提供内置函数<code>panic</code>，<code>recover</code>完成异常抛出和捕捉</p>\n</li>\n<li><p>垃圾回收</p>\n<p>自带自动回收功能，不需要<code>delete</code>和<code>free</code>来释放内存</p>\n</li>\n<li><p>多返回值</p>\n<p>支持多返回值，可以用下划线作为占用符丢掉不要的返回值</p>\n</li>\n<li><p>匿名函数</p>\n<p>支持常规的匿名函数和闭包</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// hello.go</span><br><br><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>    <span class=\"hljs-string\">&quot;fmt&quot;</span> <span class=\"hljs-comment\">//导入fmt包，调用其中的Println()函数</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;Hello，world！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ul>\n<li><p>常量</p>\n<p>使用<code>const</code>声明，可以限定常量类型，也可以不指定类型（称为字面常量）</p>\n</li>\n</ul>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">const</span> limit = <span class=\"hljs-number\">512</span><br><span class=\"hljs-keyword\">const</span> top <span class=\"hljs-built_in\">uint16</span> = <span class=\"hljs-number\">1421</span><br><span class=\"hljs-keyword\">const</span> Pi <span class=\"hljs-built_in\">float</span>64 = <span class=\"hljs-number\">3.1415926</span><br><span class=\"hljs-comment\">// 多重赋值</span><br><span class=\"hljs-keyword\">const</span> x,y <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\">// 多个常量赋值</span><br><span class=\"hljs-keyword\">const</span> (<br>\tone = <span class=\"hljs-number\">1</span><br>\ttwo = <span class=\"hljs-number\">2</span><br>)<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>iota</p>\n<p><code>iota</code>是一个可以被编译器修改的常量，在<code>const</code>关键字出现时被重置为<code>0</code>，在下一个<code>const</code>出现之前，每出现一次<code>iota</code>，所代表的数字自动加1</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">const</span> (<br>    a = <span class=\"hljs-literal\">iota</span>  <span class=\"hljs-comment\">//a == 0</span><br>    b = <span class=\"hljs-literal\">iota</span>  <span class=\"hljs-comment\">//b ==1</span><br>    c = <span class=\"hljs-literal\">iota</span>  <span class=\"hljs-comment\">//c == 2</span><br>)<br><br><span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-literal\">iota</span> <span class=\"hljs-comment\">//d==0,因为const的出现，iota被重置为0</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>变量</p>\n<p>变量使用<code>var</code>进行声明，可以使用<code>:=</code>对变量之间进行初始化，Go编译器会自动推导出该变量的类型</p>\n</li>\n<li><p>整型</p>\n<p>可以通过<code>unsafe.Sizeof</code>函数来查看字节长度</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>byte</code></td>\n<td style=\"text-align:left\">等同于 uint8，uint8的别名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int</code></td>\n<td style=\"text-align:left\">依赖于不同平台下的实现，可以是 int32 或者 int64</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int8</code></td>\n<td style=\"text-align:left\">[-128, 127]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int16</code></td>\n<td style=\"text-align:left\">[-32768, 32767]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int32</code></td>\n<td style=\"text-align:left\">[-2147483648, 2147483647]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int64</code></td>\n<td style=\"text-align:left\">[-9223372036854775808, 9223372036854775807]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>rune</code></td>\n<td style=\"text-align:left\">等同于 int32，代表Unicode字符类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint</code></td>\n<td style=\"text-align:left\">依赖于不同平台下的实现，可以是 uint32 或者 uint64</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint8</code></td>\n<td style=\"text-align:left\">[0, 255]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint16</code></td>\n<td style=\"text-align:left\">[0, 65535]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint32</code></td>\n<td style=\"text-align:left\">[0, 4294967295]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint64</code></td>\n<td style=\"text-align:left\">[0, 18446744073709551615]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uintptr</code></td>\n<td style=\"text-align:left\">一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>浮点类型</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float32</td>\n<td>±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数</td>\n</tr>\n<tr>\n<td>float64</td>\n<td>±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数</td>\n</tr>\n<tr>\n<td>complex32</td>\n<td>复数，实部和虚部都是 float32</td>\n</tr>\n<tr>\n<td>complex64</td>\n<td>复数，实部和虚部都是 float64</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><p>布尔类型</p>\n<p><code>true</code>和<code>false</code>：布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。</p>\n</li>\n<li><p>字符串</p>\n<ul>\n<li><p>字符串可以使用双引号<code>(&quot;&quot;)</code>或者反引号来创建。双引号用来创建可解析的字符串字面量，可解析的是指字符串中的一些符号可以被格式化为其他内容，如 <code>\\n</code> 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。</p>\n</li>\n<li><p>支持切片操作：对字符串中字符依次访问，可以使用 <code>range</code> 操作符。获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。</p>\n</li>\n</ul>\n<p>支持的操作</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>s += t</code></td>\n<td>将字符串 t 追加到 s 末尾</td>\n</tr>\n<tr>\n<td><code>s + t</code></td>\n<td>将字符串 s 和 t 级联</td>\n</tr>\n<tr>\n<td><code>s[n]</code></td>\n<td>从字符串 s 中索引位置为 n 处的原始字节</td>\n</tr>\n<tr>\n<td><code>s[n:m]</code></td>\n<td>从位置 n 到位置 <code>m-1</code> 处取得的字符（字节）串</td>\n</tr>\n<tr>\n<td><code>s[n:]</code></td>\n<td>从位置 n 到位置 <code>len(s)-1</code> 处取得的字符（字节）串</td>\n</tr>\n<tr>\n<td><code>s[:m]</code></td>\n<td>从位置 0 到位置 <code>m-1</code> 处取得的字符（字节）串</td>\n</tr>\n<tr>\n<td><code>len(s)</code></td>\n<td>字符串 s 中的字节数</td>\n</tr>\n<tr>\n<td><code>len([]rune(s))</code></td>\n<td>字符串 s 中字符的个数，可以使用更快的方法 <code>utf8.RuneCountInString()</code></td>\n</tr>\n<tr>\n<td><code>[]rune(s)</code></td>\n<td>将字符串 s 转换为一个 unicode 值组成的串</td>\n</tr>\n<tr>\n<td><code>string(chars)</code></td>\n<td>chars 类型是 <code>[]rune</code> 或者 <code>[]int32</code>, 将之转换为字符串</td>\n</tr>\n<tr>\n<td><code>[]byte(s)</code></td>\n<td>无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"顺序编程\"><a href=\"#顺序编程\" class=\"headerlink\" title=\"顺序编程\"></a>顺序编程</h3><ul>\n<li><p>if</p>\n<p><code>if</code>后面可以紧接一个表达式<code>optionalStatement1</code>，表达式会在进入<code>block</code>前执行，决定进入<code>block</code>分支的是布尔表达式<code>booleanExpression1</code></p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">if</span> optionalStatement1; booleanExpression1 &#123;<br>    block1<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> optionalStatement2; booleanExpression2 &#123;<br>    block2<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    block3<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>for</p>\n<p><code>for</code>循环可以遍历数组，切片，映射等类型，也可以用于无限循环</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">for</span> &#123; <span class=\"hljs-comment\">// 无限循环</span><br>    block<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> booleanExpression &#123; <span class=\"hljs-comment\">// while循环，在Go语言中没有while关键字</span><br><br>&#125;<br><br><span class=\"hljs-keyword\">for</span> index, char := <span class=\"hljs-keyword\">range</span> aString &#123; <span class=\"hljs-comment\">// 迭代字符串</span><br><br>&#125;<br><br><span class=\"hljs-keyword\">for</span> item := <span class=\"hljs-keyword\">range</span> aChannel &#123; <span class=\"hljs-comment\">// 迭代通道</span><br><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>goto</p>\n<p><code>goto</code>可以实现跳转，在程序代码前定义一个标签以后可以使用goto跳转到标签</p>\n</li>\n<li><p>switch</p>\n</li>\n</ul>\n<p><strong>类型处理</strong></p>\n<ul>\n<li><p>类型转换</p>\n</li>\n<li><p>类型断言</p>\n<p>将空接口类型转化为我们所需要的类型，这个操作称为类型断言。（有点难懂）</p>\n</li>\n</ul>\n<p><strong>defer</strong></p>\n<ul>\n<li>当函数执行到最后时，<code>defer</code>语句会按照逆序执行，最后该函数返回，<code>defer</code>会在<code>return</code>之后执行。</li>\n</ul>\n<h3 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h3><ul>\n<li><p>自定义类型及结构体</p>\n<p>Go的代码是以包结构来组织的，如果标识符（变量名，函数名，自定义类型），以大写字母开头的标识符是可以导出的，可以在任何导入了定义该标识符的包中使用，Go语言不支持继承，只支持组合。</p>\n<ul>\n<li></li>\n</ul>\n</li>\n<li><p>方法</p>\n</li>\n<li><p>组合</p>\n</li>\n<li><p>接口</p>\n<blockquote>\n<p>接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。接口指定类型应具有的方法，类型决定如何实现这些方法。</p>\n</blockquote>\n<p>接口定义了一组方法的集合，任何类型只要实现了接口中定义的所有方法，就被认为实现了该接口。</p>\n<p>接口在Go中的实现方式是隐式的，无需显性地声明，这种设计允许对象在不同的上下文中被看作是不同的类型，从而实现了多态性。</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-comment\">// Animal 接口定义了 Speak 方法</span><br><span class=\"hljs-keyword\">type</span> Animal <span class=\"hljs-keyword\">interface</span> &#123;<br>    Speak() <span class=\"hljs-type\">string</span><br>&#125;<br><br><span class=\"hljs-comment\">// Dog 类型实现了 Animal 接口</span><br><span class=\"hljs-keyword\">type</span> Dog <span class=\"hljs-keyword\">struct</span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(d Dog)</span></span> Speak() <span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Woof!&quot;</span><br>&#125;<br><br><span class=\"hljs-comment\">// Cat 类型实现了 Animal 接口</span><br><span class=\"hljs-keyword\">type</span> Cat <span class=\"hljs-keyword\">struct</span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c Cat)</span></span> Speak() <span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Meow!&quot;</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-comment\">// 定义一个接口类型的变量</span><br>    <span class=\"hljs-keyword\">var</span> animal Animal<br><br>    <span class=\"hljs-comment\">// 可以将不同类型的对象赋值给接口变量</span><br>    animal = Dog&#123;&#125;<br>    fmt.Println(animal.Speak()) <span class=\"hljs-comment\">// 输出: Woof!</span><br><br>    animal = Cat&#123;&#125;<br>    fmt.Println(animal.Speak()) <span class=\"hljs-comment\">// 输出: Meow!</span><br>&#125;<br></code></pre></td></tr></table></figure>\n","cover_type":"img","excerpt":"","more":"<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h3 id=\"GO语言特性\"><a href=\"#GO语言特性\" class=\"headerlink\" title=\"GO语言特性\"></a>GO语言特性</h3><ul>\n<li><p>并发编程</p>\n<p>Go语言中引入了<code>goroutine</code>，通过调用<code>go</code>关键字，可以让函数以goroutine的方式进行运行，以协程为单位进行运行。</p>\n<p>协程相比线程更加轻量级，也更节省系统资源。</p>\n<p>goroutine内部采用管道<code>channel</code>进行消息传递，从而实现共享内存。</p>\n</li>\n<li><p>错误处理</p>\n<p>函数通过返回错误类型<code>error</code>或者<code>bool</code>类型表明函数执行结果，通过判断返回值是否为<code>nil</code>。</p>\n<p>引入了defer关键字用于标准的错误处理流程，提供内置函数<code>panic</code>，<code>recover</code>完成异常抛出和捕捉</p>\n</li>\n<li><p>垃圾回收</p>\n<p>自带自动回收功能，不需要<code>delete</code>和<code>free</code>来释放内存</p>\n</li>\n<li><p>多返回值</p>\n<p>支持多返回值，可以用下划线作为占用符丢掉不要的返回值</p>\n</li>\n<li><p>匿名函数</p>\n<p>支持常规的匿名函数和闭包</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-comment\">// hello.go</span><br><br><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> (<br>    <span class=\"hljs-string\">&quot;fmt&quot;</span> <span class=\"hljs-comment\">//导入fmt包，调用其中的Println()函数</span><br>)<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    fmt.Println(<span class=\"hljs-string\">&quot;Hello，world！&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><ul>\n<li><p>常量</p>\n<p>使用<code>const</code>声明，可以限定常量类型，也可以不指定类型（称为字面常量）</p>\n</li>\n</ul>\n<figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">const</span> limit = <span class=\"hljs-number\">512</span><br><span class=\"hljs-keyword\">const</span> top <span class=\"hljs-built_in\">uint16</span> = <span class=\"hljs-number\">1421</span><br><span class=\"hljs-keyword\">const</span> Pi <span class=\"hljs-built_in\">float</span>64 = <span class=\"hljs-number\">3.1415926</span><br><span class=\"hljs-comment\">// 多重赋值</span><br><span class=\"hljs-keyword\">const</span> x,y <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\">// 多个常量赋值</span><br><span class=\"hljs-keyword\">const</span> (<br>\tone = <span class=\"hljs-number\">1</span><br>\ttwo = <span class=\"hljs-number\">2</span><br>)<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>iota</p>\n<p><code>iota</code>是一个可以被编译器修改的常量，在<code>const</code>关键字出现时被重置为<code>0</code>，在下一个<code>const</code>出现之前，每出现一次<code>iota</code>，所代表的数字自动加1</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">const</span> (<br>    a = <span class=\"hljs-literal\">iota</span>  <span class=\"hljs-comment\">//a == 0</span><br>    b = <span class=\"hljs-literal\">iota</span>  <span class=\"hljs-comment\">//b ==1</span><br>    c = <span class=\"hljs-literal\">iota</span>  <span class=\"hljs-comment\">//c == 2</span><br>)<br><br><span class=\"hljs-keyword\">const</span> d = <span class=\"hljs-literal\">iota</span> <span class=\"hljs-comment\">//d==0,因为const的出现，iota被重置为0</span><br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>变量</p>\n<p>变量使用<code>var</code>进行声明，可以使用<code>:=</code>对变量之间进行初始化，Go编译器会自动推导出该变量的类型</p>\n</li>\n<li><p>整型</p>\n<p>可以通过<code>unsafe.Sizeof</code>函数来查看字节长度</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">类型</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><code>byte</code></td>\n<td style=\"text-align:left\">等同于 uint8，uint8的别名</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int</code></td>\n<td style=\"text-align:left\">依赖于不同平台下的实现，可以是 int32 或者 int64</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int8</code></td>\n<td style=\"text-align:left\">[-128, 127]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int16</code></td>\n<td style=\"text-align:left\">[-32768, 32767]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int32</code></td>\n<td style=\"text-align:left\">[-2147483648, 2147483647]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>int64</code></td>\n<td style=\"text-align:left\">[-9223372036854775808, 9223372036854775807]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>rune</code></td>\n<td style=\"text-align:left\">等同于 int32，代表Unicode字符类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint</code></td>\n<td style=\"text-align:left\">依赖于不同平台下的实现，可以是 uint32 或者 uint64</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint8</code></td>\n<td style=\"text-align:left\">[0, 255]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint16</code></td>\n<td style=\"text-align:left\">[0, 65535]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint32</code></td>\n<td style=\"text-align:left\">[0, 4294967295]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uint64</code></td>\n<td style=\"text-align:left\">[0, 18446744073709551615]</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>uintptr</code></td>\n<td style=\"text-align:left\">一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64）</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li>浮点类型</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float32</td>\n<td>±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数</td>\n</tr>\n<tr>\n<td>float64</td>\n<td>±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数</td>\n</tr>\n<tr>\n<td>complex32</td>\n<td>复数，实部和虚部都是 float32</td>\n</tr>\n<tr>\n<td>complex64</td>\n<td>复数，实部和虚部都是 float64</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><p>布尔类型</p>\n<p><code>true</code>和<code>false</code>：布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。</p>\n</li>\n<li><p>字符串</p>\n<ul>\n<li><p>字符串可以使用双引号<code>(&quot;&quot;)</code>或者反引号来创建。双引号用来创建可解析的字符串字面量，可解析的是指字符串中的一些符号可以被格式化为其他内容，如 <code>\\n</code> 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。</p>\n</li>\n<li><p>支持切片操作：对字符串中字符依次访问，可以使用 <code>range</code> 操作符。获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。</p>\n</li>\n</ul>\n<p>支持的操作</p>\n</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>s += t</code></td>\n<td>将字符串 t 追加到 s 末尾</td>\n</tr>\n<tr>\n<td><code>s + t</code></td>\n<td>将字符串 s 和 t 级联</td>\n</tr>\n<tr>\n<td><code>s[n]</code></td>\n<td>从字符串 s 中索引位置为 n 处的原始字节</td>\n</tr>\n<tr>\n<td><code>s[n:m]</code></td>\n<td>从位置 n 到位置 <code>m-1</code> 处取得的字符（字节）串</td>\n</tr>\n<tr>\n<td><code>s[n:]</code></td>\n<td>从位置 n 到位置 <code>len(s)-1</code> 处取得的字符（字节）串</td>\n</tr>\n<tr>\n<td><code>s[:m]</code></td>\n<td>从位置 0 到位置 <code>m-1</code> 处取得的字符（字节）串</td>\n</tr>\n<tr>\n<td><code>len(s)</code></td>\n<td>字符串 s 中的字节数</td>\n</tr>\n<tr>\n<td><code>len([]rune(s))</code></td>\n<td>字符串 s 中字符的个数，可以使用更快的方法 <code>utf8.RuneCountInString()</code></td>\n</tr>\n<tr>\n<td><code>[]rune(s)</code></td>\n<td>将字符串 s 转换为一个 unicode 值组成的串</td>\n</tr>\n<tr>\n<td><code>string(chars)</code></td>\n<td>chars 类型是 <code>[]rune</code> 或者 <code>[]int32</code>, 将之转换为字符串</td>\n</tr>\n<tr>\n<td><code>[]byte(s)</code></td>\n<td>无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"顺序编程\"><a href=\"#顺序编程\" class=\"headerlink\" title=\"顺序编程\"></a>顺序编程</h3><ul>\n<li><p>if</p>\n<p><code>if</code>后面可以紧接一个表达式<code>optionalStatement1</code>，表达式会在进入<code>block</code>前执行，决定进入<code>block</code>分支的是布尔表达式<code>booleanExpression1</code></p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">if</span> optionalStatement1; booleanExpression1 &#123;<br>    block1<br>&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> optionalStatement2; booleanExpression2 &#123;<br>    block2<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    block3<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>for</p>\n<p><code>for</code>循环可以遍历数组，切片，映射等类型，也可以用于无限循环</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">for</span> &#123; <span class=\"hljs-comment\">// 无限循环</span><br>    block<br>&#125;<br><br><span class=\"hljs-keyword\">for</span> booleanExpression &#123; <span class=\"hljs-comment\">// while循环，在Go语言中没有while关键字</span><br><br>&#125;<br><br><span class=\"hljs-keyword\">for</span> index, char := <span class=\"hljs-keyword\">range</span> aString &#123; <span class=\"hljs-comment\">// 迭代字符串</span><br><br>&#125;<br><br><span class=\"hljs-keyword\">for</span> item := <span class=\"hljs-keyword\">range</span> aChannel &#123; <span class=\"hljs-comment\">// 迭代通道</span><br><br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>goto</p>\n<p><code>goto</code>可以实现跳转，在程序代码前定义一个标签以后可以使用goto跳转到标签</p>\n</li>\n<li><p>switch</p>\n</li>\n</ul>\n<p><strong>类型处理</strong></p>\n<ul>\n<li><p>类型转换</p>\n</li>\n<li><p>类型断言</p>\n<p>将空接口类型转化为我们所需要的类型，这个操作称为类型断言。（有点难懂）</p>\n</li>\n</ul>\n<p><strong>defer</strong></p>\n<ul>\n<li>当函数执行到最后时，<code>defer</code>语句会按照逆序执行，最后该函数返回，<code>defer</code>会在<code>return</code>之后执行。</li>\n</ul>\n<h3 id=\"面向对象编程\"><a href=\"#面向对象编程\" class=\"headerlink\" title=\"面向对象编程\"></a>面向对象编程</h3><ul>\n<li><p>自定义类型及结构体</p>\n<p>Go的代码是以包结构来组织的，如果标识符（变量名，函数名，自定义类型），以大写字母开头的标识符是可以导出的，可以在任何导入了定义该标识符的包中使用，Go语言不支持继承，只支持组合。</p>\n<ul>\n<li></li>\n</ul>\n</li>\n<li><p>方法</p>\n</li>\n<li><p>组合</p>\n</li>\n<li><p>接口</p>\n<blockquote>\n<p>接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。接口指定类型应具有的方法，类型决定如何实现这些方法。</p>\n</blockquote>\n<p>接口定义了一组方法的集合，任何类型只要实现了接口中定义的所有方法，就被认为实现了该接口。</p>\n<p>接口在Go中的实现方式是隐式的，无需显性地声明，这种设计允许对象在不同的上下文中被看作是不同的类型，从而实现了多态性。</p>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\"><span class=\"hljs-keyword\">package</span> main<br><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;fmt&quot;</span><br><br><span class=\"hljs-comment\">// Animal 接口定义了 Speak 方法</span><br><span class=\"hljs-keyword\">type</span> Animal <span class=\"hljs-keyword\">interface</span> &#123;<br>    Speak() <span class=\"hljs-type\">string</span><br>&#125;<br><br><span class=\"hljs-comment\">// Dog 类型实现了 Animal 接口</span><br><span class=\"hljs-keyword\">type</span> Dog <span class=\"hljs-keyword\">struct</span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(d Dog)</span></span> Speak() <span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Woof!&quot;</span><br>&#125;<br><br><span class=\"hljs-comment\">// Cat 类型实现了 Animal 接口</span><br><span class=\"hljs-keyword\">type</span> Cat <span class=\"hljs-keyword\">struct</span>&#123;&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c Cat)</span></span> Speak() <span class=\"hljs-type\">string</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Meow!&quot;</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> &#123;<br>    <span class=\"hljs-comment\">// 定义一个接口类型的变量</span><br>    <span class=\"hljs-keyword\">var</span> animal Animal<br><br>    <span class=\"hljs-comment\">// 可以将不同类型的对象赋值给接口变量</span><br>    animal = Dog&#123;&#125;<br>    fmt.Println(animal.Speak()) <span class=\"hljs-comment\">// 输出: Woof!</span><br><br>    animal = Cat&#123;&#125;<br>    fmt.Println(animal.Speak()) <span class=\"hljs-comment\">// 输出: Meow!</span><br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"build_sample_redis","date":"2024-02-18T08:58:37.000Z","cover":"/img/default_cover.jpg","top_img":null,"_content":"\n### \n\n## 一、基础知识\n\n### Sockets编程\n\n客户/服务器模型\n\n定义协议解析\n\n事件循环和非阻塞型IO\n\n循环事件的执行\n\n提供基本服务：get,set,del\n\n","source":"_drafts/build-sample-redis.md","raw":"---\ntitle: build_sample_redis\ndate: 2024-02-18 16:58:37\ntags: \ncategories:\ncover:\ntop_img:\n---\n\n### \n\n## 一、基础知识\n\n### Sockets编程\n\n客户/服务器模型\n\n定义协议解析\n\n事件循环和非阻塞型IO\n\n循环事件的执行\n\n提供基本服务：get,set,del\n\n","slug":"build-sample-redis","published":0,"updated":"2024-02-18T10:16:54.574Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xm0003g4c25yh5gla9","content":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><h3 id=\"Sockets编程\"><a href=\"#Sockets编程\" class=\"headerlink\" title=\"Sockets编程\"></a>Sockets编程</h3><p>客户/服务器模型</p>\n<p>定义协议解析</p>\n<p>事件循环和非阻塞型IO</p>\n<p>循环事件的执行</p>\n<p>提供基本服务：get,set,del</p>\n","cover_type":"img","excerpt":"","more":"<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3><h2 id=\"一、基础知识\"><a href=\"#一、基础知识\" class=\"headerlink\" title=\"一、基础知识\"></a>一、基础知识</h2><h3 id=\"Sockets编程\"><a href=\"#Sockets编程\" class=\"headerlink\" title=\"Sockets编程\"></a>Sockets编程</h3><p>客户/服务器模型</p>\n<p>定义协议解析</p>\n<p>事件循环和非阻塞型IO</p>\n<p>循环事件的执行</p>\n<p>提供基本服务：get,set,del</p>\n"},{"title":"database_mysql","date":"2024-02-10T08:00:39.000Z","cover":"/img/default_cover02.jpg","top_img":null,"_content":"\n## 数据库-Mysql\n\n> Mysql数据库的关键词：事务、存储引擎、索引、SQL优化、**锁、日志、主从复制、读写分离、分库分表**\n\n![image-20240210160421874](database-mysql/image-20240210160421874.png)\n\n## 数据库基础\n\n### 1、Mysql概述\n\n关系型数据库：建立在关系模型基础上，由多张互连接的二维表组成的数据库\n\n特点：使用表存储数据，便于维护；使用sql语句操作，使用方便\n\n**MySQL数据模型**\n\n> 1、客户端通过与数据库管理系统进行连接\n>\n> 2、使用sql语句通过数据库管理系统对指定的数据库进行增删改查\n>\n> 3、一个数据库模型中可以对多个数据库进行管理，一个数据库中可以拥有多个表\n\n// TODO数据库模型的图\n\n### 2、SQL\n\n**SQL分类**\n\n| 分类 | 全称                       | 说明                                                 |\n| ---- | -------------------------- | ---------------------------------------------------- |\n| DDL  | Data Definition Language   | 数据库定义语句，定义数据库对象，数据库，表，字段等   |\n| DML  | Data Manipulation Language | 数据库操作语句，用于对数据库表中的数据进行增增删改   |\n| DQL  | Data Query Language        | 数据库查询语句，查询数据库表中的记录                 |\n| DCL  | Data Control Language      | 数据库控制语句，创建数据库用户，控制数据库的访问权限 |\n\n* #### DDL\n\n  **数据库层次**\n\n```mysql\n# 查询所有数据库表格\nSHOW DATABASES;\n# 查询当前所在的数据库\nSELECT DATABASE();\n# 创建数据库，方括号可以省略\nCREATE DATABASE [IF NOT EXISTS] 数据库名 [COLLATE 排序规则]\n# 删除数据库\nDROP DATABASE [IF EXISTS] 数据库名\n# 使用数据库，切换到数据库当中\nUSE 数据库名\n```\n\n​\t\t表结构\n\n```mysql\n# 查看所有表\nSHOW TABLES;\n# 查询表结构\nDESC 表名\n# 查询指定表的建表语句\nSHOW CREATE TABLE 表名;\n```\n\n​\t\tMySQL中的数据类型\n\n| 数据类型       | 描述                                   | 大小                                 |\n| -------------- | -------------------------------------- | ------------------------------------ |\n| TINYINT        | 微小整数，有符号或无符号（UNSIGNED）   | 1 字节                               |\n| SMALLINT       | 小整数，有符号或无符号                 | 2 字节                               |\n| MEDIUMINT      | 中等整数，有符号或无符号               | 3 字节                               |\n| INT 或 INTEGER | 整数，有符号或无符号                   | 4 字节                               |\n| BIGINT         | 大整数，有符号或无符号                 | 8 字节                               |\n| FLOAT(M,D)     | 单精度浮点数，M 是总位数，D 是小数位数 | 4 字节                               |\n| DOUBLE(M,D)    | 双精度浮点数，M 是总位数，D 是小数位数 | 8 字节                               |\n| DECIMAL(M,D)   | 定点数，M 是总位数，D 是小数位数       | 取决于 M 和 D                        |\n| DATE           | 日期 YYYY-MM-DD                        | 3 字节                               |\n| TIME           | 时间 HH:MM:SS                          | 3 字节                               |\n| DATETIME       | 日期和时间                             | 8 字节                               |\n| TIMESTAMP      | 时间戳                                 | 4 字节                               |\n| CHAR(N)        | **定长**字符串，最大长度为 N           | 最大 255 字节                        |\n| VARCHAR(N)     | **变长**字符串，最大长度为 N           | 最大 65,535 字节                     |\n| TEXT           | 变长文本，最大长度为 65,535 字节       | 最大 65,535 字节                     |\n| BLOB           | 二进制大对象，最大长度为 65,535 字节   | 最大 65,535 字节                     |\n| ENUM           | 枚举类型                               | 1 或 2 字节，取决于成员数量          |\n| SET            | 集合类型                               | 1、2、3、4 或 8 字节，取决于成员数量 |\n\n创建表：\n\n```mysql\nCREATE TABLE member(\n    number INT COMMENT '编号',\n    id CHAR(10) COMMENT '员工工号',\n    name VARCHAR(10) COMMENT '员工姓名',\n    gender CHAR(4) COMMENT '员工性别',\n    age INT UNSIGNED COMMENT '年龄',\n    id_number CHAR(18) COMMENT '身份证号',\n    time DATE COMMENT '入职时间'\n)\n```\n\n**表结构的修改**\n\n```mysql\n# 添加字段\nALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束];\n\n# 修改字段和字段类型\nALTER TABLE 表明 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束]\n\n# 删除字段\nALTER TABLE 表名 DROP 字段名;\n\n# 修改表名\nALTER TABLE 表名 RENAME TO 新表名;\n\n# 删除表\nDROP TABLE [IF EXSITS] 表名;\n# 删除指定表并重新创建该表，清空数据\nTRUNCATE TABLE 表名;\n```\n\n* #### DML（数据操作语言）\n\n**添加数据**\n\n```mysql\n# 给指定字段添加数据\nINSERT INTO 表名(字段名1, 字段名2, ...) VALUES (值1, 值2, ...);\n\n# 给全部字段添加数据\nINSERT INTO 表名 VALUES(值1, 值2, ...);\n```\n\n**修改数据**\n\n```mysql\n# 修改数据\nUPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ...[WHERE 条件];\n```\n\n**删除数据**\n\n```mysql\n# 删除数据\nDELETE FROM 表名 [WHERE 条件];\n```\n\n* #### DQL\n\n  > 数据库查询语言，用来查询数据库中的表的记录\n  >\n  > SELECT后面加上\\G可以将某一行转化为一列查看\n\n**语法结构**\n\n```mysql\nSELECT\n\t字段列表\nFROM\n\t表名列表\nWHERE\n\t条件列表(条件查询)\nGROUP BY\n\t分组字段列表(分组查询)\nHAVING\n\t分组后条件列表\nORDER BY\n\t排序字段列表\nLIMIT\n\t分页参数\n```\n\n**基本查询**\n\n```mysql\nSELECT 字段1 [AS 别名]，字段2 [AS 别名]， FROM 表名;\n\n# 去重\nSELECT DISTINCT 字段列表 FROM 表名;\n```\n\n**条件查询**\n\n条件运算符\n\n|     比较运算符      |                   功能                   |\n| :-----------------: | :--------------------------------------: |\n|       <>或!=        |                  不等于                  |\n| BETWEEN ... AND ... |              在某个范围之内              |\n|       IN(...)       |       在in之后的列表中的值，多选一       |\n|     LIKE 占位符     | 模糊匹配(_匹配单个字符，%匹配任意个字符) |\n|       IS NULL       |                  是NULL                  |\n\n**聚和函数**\n\n> 将一列数据作为一个整体，进行纵向计算。\n\n所有的null值不参与聚合函数的计算\n\n| 函数  |   功能   |\n| :---: | :------: |\n| count | 统计数量 |\n|  max  |  最大值  |\n|  min  |  最小值  |\n|  avg  |  平均值  |\n|  sum  |   求和   |\n\n```mysql\nSELECT 聚合函数(字段列表) FROM 表名;\n```\n\n**分组查询**\n\n> 在where中不可以使用聚合函数，在having中可以使用聚合函数\n>\n> 分组之前过滤用where，分组之后过滤条件用having\n\n```mysql\nSELECT 字段列表\tFROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\n```\n\n执行顺序：where > 聚合函数 > having\n\n**排序查询**\n\n```mysql\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2\n```\n\n排序方式： ASC升序（默认），DESC降序\n\n**分页查询**\n\n```mysql\nSELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;\n```\n\n显示从起始索引开始的记录数条的查询结果\n\n**DQL执行顺序**\n\nFROM > WHERE > GROUP BY > SELECT > ORDER BY > LIMIT\n\n* #### DCL\n\n> 数据控制语句，用来管理数据库用户，控制数据库访问权限\n\n**DCL用户管理**\n\n```mysql\n# 查询用户\nUSE mysql;\nSELECT * FROM user;\n\n# 创建用户，主机名换成\"%\"表示可以在任意主机访问数据库\nCREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n\n# 修改用户密码\nALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'\n\n# 删除用户\nDROP USER '用户名'@'主机名';\n```\n\n**权限控制**\n\n常用权限\n\n|        权限         |        说明        |\n| :-----------------: | :----------------: |\n| ALL, ALL PRIVILEGES |      所有权限      |\n|       SELECT        |      查询数据      |\n|       INSERT        |      插入数据      |\n|       UPDATE        |      修改数据      |\n|       DELETE        |      删除数据      |\n|        ALTER        |       修改表       |\n|        DROP         | 删除数据库/表/视图 |\n|       CREATE        |   创建数据库/表    |\n\n```mysql\n# 查询权限\nSHOW GRANTS FOR '用户名'@'主机名';\n\n# 授予权限\nGRANT 权限列表 ON 数据库名.表名(*.*所有表) TO '用户名'@'主机名';\n\n# 撤销权限\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n```\n\n### 3、函数\n\n* **字符串函数**\n\n|            函数            |                           功能                            |\n| :------------------------: | :-------------------------------------------------------: |\n|   CONCAT(S1,S2, ... Sn)    |            字符串拼接，将S1-Sn拼接成一个字符串            |\n|         LOWER(str)         |                  将字符串str全部转为小写                  |\n|         UPPER(str)         |                   将字符串全部转为大写                    |\n|     LPAD(str, n, pad)      | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |\n|     RPAD(str, n,  pad)     |                          右填充                           |\n|         TRIM(str)          |                去掉字符串头部和尾部的空格                 |\n| SUBSTRING(str, start, len) |         返回从字符串str从start起的len长度的字符串         |\n\n```mysql\nSELECT 函数;\n```\n\n* **数值函数**\n\n|    函数     |                功能                |\n| :---------: | :--------------------------------: |\n|   CEIL(x)   |              向上取整              |\n|  FLOOR(x)   |              向下取整              |\n|  MOD(x, y)  |            返回x/y的模             |\n|   RAND()    |         返回0~1内的随机数          |\n| ROUND(x, y) | 求参数x的四舍五入的值，保留y位小数 |\n\n* **日期函数**\n\n|                函数                |                             功能                             |\n| :--------------------------------: | :----------------------------------------------------------: |\n|             CURDATE()              |                         返回当前日期                         |\n|             CURTIME()              |                         返回当前时间                         |\n|               NOW()                |                      返回当前日期和时间                      |\n|             YEAR(date)             |                      获取指定date的年份                      |\n|            MONTH(date)             |                      获取指定date的月份                      |\n|             DAY(date)              |                      获取指定date的日期                      |\n| DATE_ADD(date, INTERVAL expr type) | 返回上一个日期加上时间间隔expr以后的时间值，type(year,month,day)指定年月天 |\n|       DATEDIFF(date1, date2)       | 返回起始时间date1和结束时间date2之间的天数，第一个时间减去第二个时间 |\n\n* **流程函数**\n\n|                            函数                            |                           功能                           |\n| :--------------------------------------------------------: | :------------------------------------------------------: |\n|                      IF(value, t. f)                       |            如果value为true，返回t，否则返回f             |\n|                   IFNULL(value1, value2)                   |       如果value1不为空，返回value1，否则返回value2       |\n|    CASE WHEN [val] THEN [res1] ... ELSE [ default ] END    |    如果val1为true，返回res1，...否则返回default默认值    |\n| CASE [expr] WHEN [val1] THEN [res1] ... ELSE [default] END | 如果expr的值等于val1，返回res1，...否则返回default默认值 |\n\n### 4、约束\n\n作用于表中字段上的规则，用于限制存储在表中的数据\n\n|   约束   | 描述 | 关键字 |\n| :------: | :--: | :----: |\n| 非空约束 |      |        |\n| 唯一约束 |      |        |\n| 主键约束 |      |        |\n| 默认约束 |      |        |\n| 检查约束 |      |        |\n| 外键约束 |      |        |\n\n\n\n### 5、多表查询\n\n* **多表关系**\n\n  一对多：在多的一方建立外键，指向一的一方的主键\n\n​\t\t多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方的主键\n\n​\t\t一对一：用于做单表拆分，基础字段放在一张表，详情字段放在另一张表。在任意一方加入外键，关联另一方的主键，并设置外键为唯一（UNIQUE）\n\n* **多表查询**\n\n  * 内连接\n\n    > 相当于查询A、B交集部分数据\n\n  ```mysql\n  # 隐式内连接\n  SELECT 字段列表 FROM 表1，表2 WHERE 条件...;\n  \n  # 显示内连接\n  SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n  ```\n\n  * 外连接\n\n    > 左外连接：查询左表所有数据，以及两张表交集部分数据，将左表的数据和右表的部分数据连接起来\n    >\n    > 右外连接：查询右表所有数据，以及两张表交集部分数据\n\n  ```mysql\n  # 左外连接，表1所有数据以及和表2交集部分的数据\n  SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;\n  \n  # 右外连接，表2所有数据以及和表1交集部分的数据\n  SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;\n  ```\n\n  * 自连接\n\n    > 自连接：当前表与自身的连接查询，自连接必须使用表别名\n\n  * 联合查询-union，union all\n\n  ```mysql\n  # 把多次查询的结果合并起来，形成一个新的查询结果集\n  # ALL去掉以后会对结果进行去重\n  SELECT 字段列表 表A\n  UNION [ALL]\n  SELECT 字段列表 表B;\n  ```\n\n* **子查询**\n\n  * 标量子查询，子查询返回一个标量\n\n  * 列子查询，子查询返回一列\n\n    | 操作符 |                 描述                 |\n    | :----: | :----------------------------------: |\n    |   IN   |     在指定的集合范围之内，多选一     |\n    | NOT IN |          不在指定的范围之内          |\n    |  ANY   | 子查询返回列表中，有任意一个满足即可 |\n    |  SOME  |              与ANY等同               |\n    |  ALL   |   子查询返回列表的所有值都必须满足   |\n\n  * 行子查询，子查询返回的结果是一行\n\n    此时column1可以使用(column1， column2)聚合成多个参数\n\n    操作符：=、<>、IN、NOT IN\n\n  * 表子查询，子查询的返回结果是一个表，可以和行子查询加上列子查询的操作符使用，表可以放到from后面\n\n```mysql\n# 对于子查询，可以将问题拆解成多个不同的查询步骤\nSELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);\n```\n\n### 6、事务\n\n> 一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么**同时成功，要么同时失败**\n>\n> 默认Mysql的事务是自动提交的，当执行一条DML语句，Mysql会立即隐式的提交事务\n\n* **事务操作**\n\n```mysql\n# 查看/设置事务提交方式\nSELECT @@autocommit;\n# 事务设置为手动提交\nSET @@autocommit = 0;\n\n# 提交事务\nCOMMIT;\n\n# 回滚事务\nROLLBACK;\n```\n\n```mysql\n# 不修改事务的提交方式操作事务\n# 开启事务\nSTART TRANSACTION 或 BEGIN;\n\n# 提交事务\nCOMMIT;\n\n# 回滚事务\nROLLBACK;\n```\n\n* **事务四大特性**\n\n  * 原子性(Atomicity)：事务时不可分割的最小操作单元，要么全部成功，要么全部失败\n  * 一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态\n  * 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n  * 持久性(Durability)：事务一旦提交或者回滚，它对数据库中的数据改变就是永久的\n\n* **并发事务问题**\n\n  |    问题    |                             描述                             |\n  | :--------: | :----------------------------------------------------------: |\n  |    脏读    |            一个事务读到另一个事务还没有提交的数据            |\n  | 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读 |\n  |    幻读    | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这一行数据已经存在 |\n\n* **事务隔离级别**\n\n  > 读未提交、读已提交、可重复读、串行化\n  >\n  > √表示会出现这个问题，×表示不会出现这个问题\n\n  |     隔离级别     | 脏读 | 不可重复读 | 幻读 |\n  | :--------------: | :--: | :--------: | :--: |\n  | Read uncommitted |  √   |     √      |  √   |\n  |  Read committed  |  ×   |     √      |  √   |\n  | Repeatable Read  |  ×   |     ×      |  √   |\n  |   Serializable   |  ×   |     ×      |  ×   |\n\n  ```mysql\n  # 查看事务的隔离级别\n  SELECT @@TRANSACTION_ISOLATION;\n  \n  # 设置事务隔离级别\n  SET [SESSION(只对当前窗口有效)|GLOBAL] TRANSACTION ISOLATION LEVEL {隔离级别}\n  ```\n\n  事务的隔离界别越高，数据越安全，但是性能越低\n\n## 数据库进阶\n\n### 1、存储引擎\n\n* Mysql体系结构 \n\n  连接层：完成一些类似于连接处理、授权认证及相关的安全方案\n\n  服务层：主要完成大多数的核心服务功能\n\n  引擎层：负责mysql中数据的存储和提取，服务器通过API和存储引擎进行通信\n\n  存储层：将数据存储在文件系统之上，并完成与存储引擎的交互\n\n  ![Mysql](database-mysql/Mysql.png)\n\n* 存储引擎\n\n  > 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎时基于表的，而不是基于库的。一个数据库的不同的表可以选择不同的存储引擎\n  >\n  > Mysql默认InnoDB\n\n```mysql\n# 查询支持的存储引擎\nshow engines;\n```\n\n* InnoDB\n\n  * DML操作遵循ACID模型，支持事务\n  * 行级锁，提高并发访问性能\n  * 支持外键，保证事务的完整性和正确性\n\n  文件：每个表对应一个.ibd文件，代表表空间文件，可以通过命令`idb2sdi 文件名`查看表结构json文件格式\n\n  ![image-20240216162915509](database-mysql/image-20240216162915509.png)\n\n* MyISAM\n\n  * 不支持事务，不支持外键\n  * 支持表锁、不支持行锁\n  * 访问速度快\n\n  文件.MYD（数据），.MYI（索引），.sdi（表结构）\n\n* Memory\n\n  * 表数据存储在内存当中，收到硬件问题或断电影响只能作为临时表或者缓存使用\n  * 内存存放\n  * hash索引（默认）\n\n![image-20240216163439353](database-mysql/image-20240216163439353.png)\n\n* 存储引擎选择\n\n  InnoDB：如果对事务的完整性有比较高的要求，在并发情况下要求事务的一致性，数据操作除了插入和查询意外，还包括很多的更新、删除操作，InnoDB引擎比较合适\n\n  MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性和并发现要求不是很高。**这个场景被Nosql数据库MongoDB替代了**\n\n  MEMORY：将所有数据保存在内存当中，访问速度快，通常用于临时表以及缓存。MEMORY对表的大小有限制，太大的表无法缓存在内存中。**这个场景被Redis替代了**\n\n### 2、索引\n\n* **索引概述**\n  * 索引的结构\n\n* #### **索引分类**\n\n|   分类   |                含义                |           特点           |  关键字  |\n| :------: | :--------------------------------: | :----------------------: | :------: |\n| 主键索引 |      针对于表中主键创建的索引      | 默认自动创建，只能有一个 | PRIMARY  |\n| 唯一索引 |  避免同一个表中某数据列中的值重复  |        可以有多个        |  UNIQUE  |\n| 常规索引 |          快速定位特定数据          |        可以有多个        |          |\n| 全文索引 | 全文索引查找的是文本中通过的关键词 |        可以有多个        | FULLTEXT |\n\n按照索引的存储形式分类\n\n|   分类   |                            含义                            |         特点         |\n| :------: | :--------------------------------------------------------: | :------------------: |\n| 聚集索引 |                 将数据存储与索引放到了一块                 | 必须有，而且只有一个 |\n| 二级索引 | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 |     可以存在多个     |\n\n![image-20240218203730285](database-mysql/image-20240218203730285.png)\n\n\n\n* #### **索引语法**\n\n```mysql\n# 创建索引\n# 一个索引可以关联多行，如果关联多行称为联合索引\nCREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name, )\n\n# 查看索引\nSHOW INDEX FROM table_name;\n\n# 删除索引\nDROP INDEX index_name ON table_name;\n```\n\n* #### **SQL性能分析**\n\n  > 使用于select的优化\n\n```mysql\n# SQL执行频率，查看当前数据库语句的访问频率\nSHOW [session|global] STATUS\n# Com七个下划线，模糊匹配\nSHOW GLOBAL STATUS LIKE 'Com_______'\n```\n\n**SQL语句的频率**\n\n![image-20240218204502697](database-mysql/image-20240218204502697.png)\n\n**慢查询日志**\n\n> 慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10)的所有SQL语句的日志\n\n```mysql\n# 查看是否开启，日志文件默认在/var/lib/mysql里面\nSHOW VARIABLES LIKE 'slow_query_log';\n\n# 修改/etc/my.cnf中配置开启，配置时间\nslow_query_log=1   \nlong_query_time=2\n```\n\n**profile详情**\n\n```mysql\n# 查看是否支持prifile\nSELECT @@have_profiling;\n\n# 设置为开\nSET profiling=1;\n\n# 查看profile\nSHOW PROFILES;\n```\n\n执行完SQL语句以后，通过以下指令查看执行耗时情况\n\n```mysql\n# 查看每一条SQL耗时基本情况\nSHOW PROFILES;\n\n# 查看指定query_id的SQL语句各个阶段的耗时情况\nSHOW PROFILE FOR QUERY query_id;\n\n# 查看指定SQL语句的CPU使用情况\nSHOW PROFILE CPU FOR QUERY query_id;\n```\n\n**explain执行计划**\n\n> EXPLAIN或者DESC命令获取Mysql如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序\n\n```mysql\nEXPLAIN SELECT SQL语句;\n```\n\n![image-20240218211138993](database-mysql/image-20240218211138993.png)\n\n表头的含义：\n\n![image-20240218212814126](database-mysql/image-20240218212814126.png)\n\n![image-20240218212115878](database-mysql/image-20240218212115878.png)\n\n```txt\ntype\nconst\t以主键或以唯一的列作为索引扫描\nref\t\t非唯一的值作为查询索引\nindex\t用了索引，但是会对整个索引进行遍历\nall\t\t全表扫描\n```\n\n* #### **索引使用**\n\n**联合索引**\n\n使用要遵循**最左前缀法则**：查询**从索引的最左列开始**，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n\n**范围查询**：联合索引中出现范围查询（>,<)，范围查询右侧的列索引失效。但是使用大于等于和小于等于索引并不会失效。\n\n例子\n\n```mysql\n# student有联合索引(id,name,age)\n# 1、索引都可以使用\nselect * from student where id = 1 and name = \"Lili\" and age = 20;\n\n# 2、索引name，age失效\nselect * from student where id = 1 and age = 20;\n\n# 范围查询\n# name和age索引均失效\nselect * from student where id > 1 and name = \"Lili\" and age = 20;\n```\n\n**索引失效**\n\n索引列操作：不要在索引上进行列操作，否则索引会失效\n\n字符串类型：不加单引号索引会失效\n\n模糊查询：**头部进行模糊匹配(%%某某)**，索引会失效，尾部进行模糊匹配（某某%%），索引不会失效。\n\nor连接的条件：如果or前面的条件列有索引，后面的条件没有索引，所涉及的索引都不会引用到，只有两侧都有索引的时候，才有效\n\n数据分布影响：如果索引比全表扫描更慢，则不使用索引，查询的数据大于一半，走全表不走索引。\n\n**SQL提示**\n\n> 在sql语句中加入一些认为的提示来达到优化操作的目的\n\n```mysql\n# use index指定使用哪个索引\nexplain select * from table use index(idxname) ...\n\n# ignore index\n# force index 同上\n```\n\n**覆盖索引**\n\n尽量使用覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到，减少使用select *\n\nusing index condition：查找使用了索引，但是需要回表查询数据\n\nusing where, using index：查询使用了索引，但是不需要回表\n\n![image-20240218221642388](database-mysql/image-20240218221642388.png)\n\n前两条不需要回表，后一条需要回表\n\n**前缀索引**\n\n> 将字符串的前缀提取出来，创建索引，可以节约索引空间\n\n```mysql\n# n表示取column_name列的前n个数据\nCREATE INDEX idx_XXX ON table_name(column_name(n));\n\n# 计算前缀长度的选择性，越接近1越好\nSELECT COUNT(DISTINCT substring(email, 1, 5)) / COUNT(*) FROM table_name;\n```\n\n**单列索引和联合索引选择**\n\n如果涉及到多个查询条件，推荐使用联合索引，联合索引会更少的回表查询\n\n#### Quetion\n\n![image-20240218221919863](database-mysql/image-20240218221919863.png)\n\n建立id主键，username，password联合索引\n\n* #### **索引设计原则**\n\n![image-20240218224016746](database-mysql/image-20240218224016746.png)\n\n### 3、SQL优化\n\n* #### **插入数据**insert优化\n\n  批量插入而不是单条插入：批量插入只需要建立一次连接即可\n\n  建议手动提交事务：不需要每一次插入时自动开启和关闭事务，而是将所有insert执行结束以后统一关闭\n\n  **建议主键顺序插入**\n\n  大批量插入数据：使用Mysql数据库提供的load指令进行插入\n\n  ```mysql\n  # 如何使用load\n  # 1、连接服务器时加上参数--local-infile\n  mysql --local-infile -u root -p\n  \n  # 2、设置全局参数local_infile为1\n  set global local_infile = 1;\n  \n  # 3、执行load指令将数据加载表结构中\n  load data local infile '文件名' into table '表名' fields teminated by '分割符' lines terminated by '行分隔符\\n';\n  ```\n\n* #### **主键优化**\n\n> InnoDB中表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表。\n\n页大小为16kb，每个页至少包含两行数据\n\n主键乱序插入可能会出现页分裂现象，执行删除操作会出现页合并现象\n\n主键设计原则：\n\n​\t满足业务需求的情况下，尽量降低主键的长度\n\n​\t插入时尽量按照主键顺序插入，选择自增主键\n\n​\t尽量不要使用无序的自然主键\n\n​\t业务操作，避免对主键的修改\n\n* **order by优化**\n\n排序方式\n\nUsing filesort：先找到数据再进行排序\n\nUsing index：通过有序索引直接返回，不需要额外排序\n\n默认会对索引进行升序排序\n\n* **limit优化**\n\n对于数据量大的，优化思路为使用覆盖索引+子查询\n\n* count\n\n  count(*)优于count(1)>count(主键)>count(字段)\n\n* #### **update优化**\n\n对需要更新的字段尽可能建立索引，这样如果处于多个事务情况下，只会使用行锁，如果没有建立索引，行锁会升级为表锁，无法进行并行\n\n### 4、视图/存储过程/触发器\n\n* #### 视图\n\n> 视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。\n\n* #### 存储过程\n\n* #### 存储函数\n\n* #### 触发器\n\n### 5、锁\n\n### 6、InnoDB核心\n\n### 7、MySQL管理\n\n\n\n## 数据库运维\n\n### 1、日志\n\n### 2、主从复制\n\n### 3、分库分表\n\n### 4、读写分离\n\n### \n","source":"_drafts/database-mysql.md","raw":"---\ntitle: database_mysql\ndate: 2024-02-10 16:00:39\ntags: [Database 数据库 Mysql SQL]\ncategories: 技术研究\ncover:\ntop_img:\n---\n\n## 数据库-Mysql\n\n> Mysql数据库的关键词：事务、存储引擎、索引、SQL优化、**锁、日志、主从复制、读写分离、分库分表**\n\n![image-20240210160421874](database-mysql/image-20240210160421874.png)\n\n## 数据库基础\n\n### 1、Mysql概述\n\n关系型数据库：建立在关系模型基础上，由多张互连接的二维表组成的数据库\n\n特点：使用表存储数据，便于维护；使用sql语句操作，使用方便\n\n**MySQL数据模型**\n\n> 1、客户端通过与数据库管理系统进行连接\n>\n> 2、使用sql语句通过数据库管理系统对指定的数据库进行增删改查\n>\n> 3、一个数据库模型中可以对多个数据库进行管理，一个数据库中可以拥有多个表\n\n// TODO数据库模型的图\n\n### 2、SQL\n\n**SQL分类**\n\n| 分类 | 全称                       | 说明                                                 |\n| ---- | -------------------------- | ---------------------------------------------------- |\n| DDL  | Data Definition Language   | 数据库定义语句，定义数据库对象，数据库，表，字段等   |\n| DML  | Data Manipulation Language | 数据库操作语句，用于对数据库表中的数据进行增增删改   |\n| DQL  | Data Query Language        | 数据库查询语句，查询数据库表中的记录                 |\n| DCL  | Data Control Language      | 数据库控制语句，创建数据库用户，控制数据库的访问权限 |\n\n* #### DDL\n\n  **数据库层次**\n\n```mysql\n# 查询所有数据库表格\nSHOW DATABASES;\n# 查询当前所在的数据库\nSELECT DATABASE();\n# 创建数据库，方括号可以省略\nCREATE DATABASE [IF NOT EXISTS] 数据库名 [COLLATE 排序规则]\n# 删除数据库\nDROP DATABASE [IF EXISTS] 数据库名\n# 使用数据库，切换到数据库当中\nUSE 数据库名\n```\n\n​\t\t表结构\n\n```mysql\n# 查看所有表\nSHOW TABLES;\n# 查询表结构\nDESC 表名\n# 查询指定表的建表语句\nSHOW CREATE TABLE 表名;\n```\n\n​\t\tMySQL中的数据类型\n\n| 数据类型       | 描述                                   | 大小                                 |\n| -------------- | -------------------------------------- | ------------------------------------ |\n| TINYINT        | 微小整数，有符号或无符号（UNSIGNED）   | 1 字节                               |\n| SMALLINT       | 小整数，有符号或无符号                 | 2 字节                               |\n| MEDIUMINT      | 中等整数，有符号或无符号               | 3 字节                               |\n| INT 或 INTEGER | 整数，有符号或无符号                   | 4 字节                               |\n| BIGINT         | 大整数，有符号或无符号                 | 8 字节                               |\n| FLOAT(M,D)     | 单精度浮点数，M 是总位数，D 是小数位数 | 4 字节                               |\n| DOUBLE(M,D)    | 双精度浮点数，M 是总位数，D 是小数位数 | 8 字节                               |\n| DECIMAL(M,D)   | 定点数，M 是总位数，D 是小数位数       | 取决于 M 和 D                        |\n| DATE           | 日期 YYYY-MM-DD                        | 3 字节                               |\n| TIME           | 时间 HH:MM:SS                          | 3 字节                               |\n| DATETIME       | 日期和时间                             | 8 字节                               |\n| TIMESTAMP      | 时间戳                                 | 4 字节                               |\n| CHAR(N)        | **定长**字符串，最大长度为 N           | 最大 255 字节                        |\n| VARCHAR(N)     | **变长**字符串，最大长度为 N           | 最大 65,535 字节                     |\n| TEXT           | 变长文本，最大长度为 65,535 字节       | 最大 65,535 字节                     |\n| BLOB           | 二进制大对象，最大长度为 65,535 字节   | 最大 65,535 字节                     |\n| ENUM           | 枚举类型                               | 1 或 2 字节，取决于成员数量          |\n| SET            | 集合类型                               | 1、2、3、4 或 8 字节，取决于成员数量 |\n\n创建表：\n\n```mysql\nCREATE TABLE member(\n    number INT COMMENT '编号',\n    id CHAR(10) COMMENT '员工工号',\n    name VARCHAR(10) COMMENT '员工姓名',\n    gender CHAR(4) COMMENT '员工性别',\n    age INT UNSIGNED COMMENT '年龄',\n    id_number CHAR(18) COMMENT '身份证号',\n    time DATE COMMENT '入职时间'\n)\n```\n\n**表结构的修改**\n\n```mysql\n# 添加字段\nALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束];\n\n# 修改字段和字段类型\nALTER TABLE 表明 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束]\n\n# 删除字段\nALTER TABLE 表名 DROP 字段名;\n\n# 修改表名\nALTER TABLE 表名 RENAME TO 新表名;\n\n# 删除表\nDROP TABLE [IF EXSITS] 表名;\n# 删除指定表并重新创建该表，清空数据\nTRUNCATE TABLE 表名;\n```\n\n* #### DML（数据操作语言）\n\n**添加数据**\n\n```mysql\n# 给指定字段添加数据\nINSERT INTO 表名(字段名1, 字段名2, ...) VALUES (值1, 值2, ...);\n\n# 给全部字段添加数据\nINSERT INTO 表名 VALUES(值1, 值2, ...);\n```\n\n**修改数据**\n\n```mysql\n# 修改数据\nUPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ...[WHERE 条件];\n```\n\n**删除数据**\n\n```mysql\n# 删除数据\nDELETE FROM 表名 [WHERE 条件];\n```\n\n* #### DQL\n\n  > 数据库查询语言，用来查询数据库中的表的记录\n  >\n  > SELECT后面加上\\G可以将某一行转化为一列查看\n\n**语法结构**\n\n```mysql\nSELECT\n\t字段列表\nFROM\n\t表名列表\nWHERE\n\t条件列表(条件查询)\nGROUP BY\n\t分组字段列表(分组查询)\nHAVING\n\t分组后条件列表\nORDER BY\n\t排序字段列表\nLIMIT\n\t分页参数\n```\n\n**基本查询**\n\n```mysql\nSELECT 字段1 [AS 别名]，字段2 [AS 别名]， FROM 表名;\n\n# 去重\nSELECT DISTINCT 字段列表 FROM 表名;\n```\n\n**条件查询**\n\n条件运算符\n\n|     比较运算符      |                   功能                   |\n| :-----------------: | :--------------------------------------: |\n|       <>或!=        |                  不等于                  |\n| BETWEEN ... AND ... |              在某个范围之内              |\n|       IN(...)       |       在in之后的列表中的值，多选一       |\n|     LIKE 占位符     | 模糊匹配(_匹配单个字符，%匹配任意个字符) |\n|       IS NULL       |                  是NULL                  |\n\n**聚和函数**\n\n> 将一列数据作为一个整体，进行纵向计算。\n\n所有的null值不参与聚合函数的计算\n\n| 函数  |   功能   |\n| :---: | :------: |\n| count | 统计数量 |\n|  max  |  最大值  |\n|  min  |  最小值  |\n|  avg  |  平均值  |\n|  sum  |   求和   |\n\n```mysql\nSELECT 聚合函数(字段列表) FROM 表名;\n```\n\n**分组查询**\n\n> 在where中不可以使用聚合函数，在having中可以使用聚合函数\n>\n> 分组之前过滤用where，分组之后过滤条件用having\n\n```mysql\nSELECT 字段列表\tFROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];\n```\n\n执行顺序：where > 聚合函数 > having\n\n**排序查询**\n\n```mysql\nSELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2\n```\n\n排序方式： ASC升序（默认），DESC降序\n\n**分页查询**\n\n```mysql\nSELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;\n```\n\n显示从起始索引开始的记录数条的查询结果\n\n**DQL执行顺序**\n\nFROM > WHERE > GROUP BY > SELECT > ORDER BY > LIMIT\n\n* #### DCL\n\n> 数据控制语句，用来管理数据库用户，控制数据库访问权限\n\n**DCL用户管理**\n\n```mysql\n# 查询用户\nUSE mysql;\nSELECT * FROM user;\n\n# 创建用户，主机名换成\"%\"表示可以在任意主机访问数据库\nCREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n\n# 修改用户密码\nALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'\n\n# 删除用户\nDROP USER '用户名'@'主机名';\n```\n\n**权限控制**\n\n常用权限\n\n|        权限         |        说明        |\n| :-----------------: | :----------------: |\n| ALL, ALL PRIVILEGES |      所有权限      |\n|       SELECT        |      查询数据      |\n|       INSERT        |      插入数据      |\n|       UPDATE        |      修改数据      |\n|       DELETE        |      删除数据      |\n|        ALTER        |       修改表       |\n|        DROP         | 删除数据库/表/视图 |\n|       CREATE        |   创建数据库/表    |\n\n```mysql\n# 查询权限\nSHOW GRANTS FOR '用户名'@'主机名';\n\n# 授予权限\nGRANT 权限列表 ON 数据库名.表名(*.*所有表) TO '用户名'@'主机名';\n\n# 撤销权限\nREVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n```\n\n### 3、函数\n\n* **字符串函数**\n\n|            函数            |                           功能                            |\n| :------------------------: | :-------------------------------------------------------: |\n|   CONCAT(S1,S2, ... Sn)    |            字符串拼接，将S1-Sn拼接成一个字符串            |\n|         LOWER(str)         |                  将字符串str全部转为小写                  |\n|         UPPER(str)         |                   将字符串全部转为大写                    |\n|     LPAD(str, n, pad)      | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |\n|     RPAD(str, n,  pad)     |                          右填充                           |\n|         TRIM(str)          |                去掉字符串头部和尾部的空格                 |\n| SUBSTRING(str, start, len) |         返回从字符串str从start起的len长度的字符串         |\n\n```mysql\nSELECT 函数;\n```\n\n* **数值函数**\n\n|    函数     |                功能                |\n| :---------: | :--------------------------------: |\n|   CEIL(x)   |              向上取整              |\n|  FLOOR(x)   |              向下取整              |\n|  MOD(x, y)  |            返回x/y的模             |\n|   RAND()    |         返回0~1内的随机数          |\n| ROUND(x, y) | 求参数x的四舍五入的值，保留y位小数 |\n\n* **日期函数**\n\n|                函数                |                             功能                             |\n| :--------------------------------: | :----------------------------------------------------------: |\n|             CURDATE()              |                         返回当前日期                         |\n|             CURTIME()              |                         返回当前时间                         |\n|               NOW()                |                      返回当前日期和时间                      |\n|             YEAR(date)             |                      获取指定date的年份                      |\n|            MONTH(date)             |                      获取指定date的月份                      |\n|             DAY(date)              |                      获取指定date的日期                      |\n| DATE_ADD(date, INTERVAL expr type) | 返回上一个日期加上时间间隔expr以后的时间值，type(year,month,day)指定年月天 |\n|       DATEDIFF(date1, date2)       | 返回起始时间date1和结束时间date2之间的天数，第一个时间减去第二个时间 |\n\n* **流程函数**\n\n|                            函数                            |                           功能                           |\n| :--------------------------------------------------------: | :------------------------------------------------------: |\n|                      IF(value, t. f)                       |            如果value为true，返回t，否则返回f             |\n|                   IFNULL(value1, value2)                   |       如果value1不为空，返回value1，否则返回value2       |\n|    CASE WHEN [val] THEN [res1] ... ELSE [ default ] END    |    如果val1为true，返回res1，...否则返回default默认值    |\n| CASE [expr] WHEN [val1] THEN [res1] ... ELSE [default] END | 如果expr的值等于val1，返回res1，...否则返回default默认值 |\n\n### 4、约束\n\n作用于表中字段上的规则，用于限制存储在表中的数据\n\n|   约束   | 描述 | 关键字 |\n| :------: | :--: | :----: |\n| 非空约束 |      |        |\n| 唯一约束 |      |        |\n| 主键约束 |      |        |\n| 默认约束 |      |        |\n| 检查约束 |      |        |\n| 外键约束 |      |        |\n\n\n\n### 5、多表查询\n\n* **多表关系**\n\n  一对多：在多的一方建立外键，指向一的一方的主键\n\n​\t\t多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方的主键\n\n​\t\t一对一：用于做单表拆分，基础字段放在一张表，详情字段放在另一张表。在任意一方加入外键，关联另一方的主键，并设置外键为唯一（UNIQUE）\n\n* **多表查询**\n\n  * 内连接\n\n    > 相当于查询A、B交集部分数据\n\n  ```mysql\n  # 隐式内连接\n  SELECT 字段列表 FROM 表1，表2 WHERE 条件...;\n  \n  # 显示内连接\n  SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n  ```\n\n  * 外连接\n\n    > 左外连接：查询左表所有数据，以及两张表交集部分数据，将左表的数据和右表的部分数据连接起来\n    >\n    > 右外连接：查询右表所有数据，以及两张表交集部分数据\n\n  ```mysql\n  # 左外连接，表1所有数据以及和表2交集部分的数据\n  SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;\n  \n  # 右外连接，表2所有数据以及和表1交集部分的数据\n  SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;\n  ```\n\n  * 自连接\n\n    > 自连接：当前表与自身的连接查询，自连接必须使用表别名\n\n  * 联合查询-union，union all\n\n  ```mysql\n  # 把多次查询的结果合并起来，形成一个新的查询结果集\n  # ALL去掉以后会对结果进行去重\n  SELECT 字段列表 表A\n  UNION [ALL]\n  SELECT 字段列表 表B;\n  ```\n\n* **子查询**\n\n  * 标量子查询，子查询返回一个标量\n\n  * 列子查询，子查询返回一列\n\n    | 操作符 |                 描述                 |\n    | :----: | :----------------------------------: |\n    |   IN   |     在指定的集合范围之内，多选一     |\n    | NOT IN |          不在指定的范围之内          |\n    |  ANY   | 子查询返回列表中，有任意一个满足即可 |\n    |  SOME  |              与ANY等同               |\n    |  ALL   |   子查询返回列表的所有值都必须满足   |\n\n  * 行子查询，子查询返回的结果是一行\n\n    此时column1可以使用(column1， column2)聚合成多个参数\n\n    操作符：=、<>、IN、NOT IN\n\n  * 表子查询，子查询的返回结果是一个表，可以和行子查询加上列子查询的操作符使用，表可以放到from后面\n\n```mysql\n# 对于子查询，可以将问题拆解成多个不同的查询步骤\nSELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);\n```\n\n### 6、事务\n\n> 一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么**同时成功，要么同时失败**\n>\n> 默认Mysql的事务是自动提交的，当执行一条DML语句，Mysql会立即隐式的提交事务\n\n* **事务操作**\n\n```mysql\n# 查看/设置事务提交方式\nSELECT @@autocommit;\n# 事务设置为手动提交\nSET @@autocommit = 0;\n\n# 提交事务\nCOMMIT;\n\n# 回滚事务\nROLLBACK;\n```\n\n```mysql\n# 不修改事务的提交方式操作事务\n# 开启事务\nSTART TRANSACTION 或 BEGIN;\n\n# 提交事务\nCOMMIT;\n\n# 回滚事务\nROLLBACK;\n```\n\n* **事务四大特性**\n\n  * 原子性(Atomicity)：事务时不可分割的最小操作单元，要么全部成功，要么全部失败\n  * 一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态\n  * 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行\n  * 持久性(Durability)：事务一旦提交或者回滚，它对数据库中的数据改变就是永久的\n\n* **并发事务问题**\n\n  |    问题    |                             描述                             |\n  | :--------: | :----------------------------------------------------------: |\n  |    脏读    |            一个事务读到另一个事务还没有提交的数据            |\n  | 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读 |\n  |    幻读    | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这一行数据已经存在 |\n\n* **事务隔离级别**\n\n  > 读未提交、读已提交、可重复读、串行化\n  >\n  > √表示会出现这个问题，×表示不会出现这个问题\n\n  |     隔离级别     | 脏读 | 不可重复读 | 幻读 |\n  | :--------------: | :--: | :--------: | :--: |\n  | Read uncommitted |  √   |     √      |  √   |\n  |  Read committed  |  ×   |     √      |  √   |\n  | Repeatable Read  |  ×   |     ×      |  √   |\n  |   Serializable   |  ×   |     ×      |  ×   |\n\n  ```mysql\n  # 查看事务的隔离级别\n  SELECT @@TRANSACTION_ISOLATION;\n  \n  # 设置事务隔离级别\n  SET [SESSION(只对当前窗口有效)|GLOBAL] TRANSACTION ISOLATION LEVEL {隔离级别}\n  ```\n\n  事务的隔离界别越高，数据越安全，但是性能越低\n\n## 数据库进阶\n\n### 1、存储引擎\n\n* Mysql体系结构 \n\n  连接层：完成一些类似于连接处理、授权认证及相关的安全方案\n\n  服务层：主要完成大多数的核心服务功能\n\n  引擎层：负责mysql中数据的存储和提取，服务器通过API和存储引擎进行通信\n\n  存储层：将数据存储在文件系统之上，并完成与存储引擎的交互\n\n  ![Mysql](database-mysql/Mysql.png)\n\n* 存储引擎\n\n  > 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎时基于表的，而不是基于库的。一个数据库的不同的表可以选择不同的存储引擎\n  >\n  > Mysql默认InnoDB\n\n```mysql\n# 查询支持的存储引擎\nshow engines;\n```\n\n* InnoDB\n\n  * DML操作遵循ACID模型，支持事务\n  * 行级锁，提高并发访问性能\n  * 支持外键，保证事务的完整性和正确性\n\n  文件：每个表对应一个.ibd文件，代表表空间文件，可以通过命令`idb2sdi 文件名`查看表结构json文件格式\n\n  ![image-20240216162915509](database-mysql/image-20240216162915509.png)\n\n* MyISAM\n\n  * 不支持事务，不支持外键\n  * 支持表锁、不支持行锁\n  * 访问速度快\n\n  文件.MYD（数据），.MYI（索引），.sdi（表结构）\n\n* Memory\n\n  * 表数据存储在内存当中，收到硬件问题或断电影响只能作为临时表或者缓存使用\n  * 内存存放\n  * hash索引（默认）\n\n![image-20240216163439353](database-mysql/image-20240216163439353.png)\n\n* 存储引擎选择\n\n  InnoDB：如果对事务的完整性有比较高的要求，在并发情况下要求事务的一致性，数据操作除了插入和查询意外，还包括很多的更新、删除操作，InnoDB引擎比较合适\n\n  MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性和并发现要求不是很高。**这个场景被Nosql数据库MongoDB替代了**\n\n  MEMORY：将所有数据保存在内存当中，访问速度快，通常用于临时表以及缓存。MEMORY对表的大小有限制，太大的表无法缓存在内存中。**这个场景被Redis替代了**\n\n### 2、索引\n\n* **索引概述**\n  * 索引的结构\n\n* #### **索引分类**\n\n|   分类   |                含义                |           特点           |  关键字  |\n| :------: | :--------------------------------: | :----------------------: | :------: |\n| 主键索引 |      针对于表中主键创建的索引      | 默认自动创建，只能有一个 | PRIMARY  |\n| 唯一索引 |  避免同一个表中某数据列中的值重复  |        可以有多个        |  UNIQUE  |\n| 常规索引 |          快速定位特定数据          |        可以有多个        |          |\n| 全文索引 | 全文索引查找的是文本中通过的关键词 |        可以有多个        | FULLTEXT |\n\n按照索引的存储形式分类\n\n|   分类   |                            含义                            |         特点         |\n| :------: | :--------------------------------------------------------: | :------------------: |\n| 聚集索引 |                 将数据存储与索引放到了一块                 | 必须有，而且只有一个 |\n| 二级索引 | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 |     可以存在多个     |\n\n![image-20240218203730285](database-mysql/image-20240218203730285.png)\n\n\n\n* #### **索引语法**\n\n```mysql\n# 创建索引\n# 一个索引可以关联多行，如果关联多行称为联合索引\nCREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name, )\n\n# 查看索引\nSHOW INDEX FROM table_name;\n\n# 删除索引\nDROP INDEX index_name ON table_name;\n```\n\n* #### **SQL性能分析**\n\n  > 使用于select的优化\n\n```mysql\n# SQL执行频率，查看当前数据库语句的访问频率\nSHOW [session|global] STATUS\n# Com七个下划线，模糊匹配\nSHOW GLOBAL STATUS LIKE 'Com_______'\n```\n\n**SQL语句的频率**\n\n![image-20240218204502697](database-mysql/image-20240218204502697.png)\n\n**慢查询日志**\n\n> 慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10)的所有SQL语句的日志\n\n```mysql\n# 查看是否开启，日志文件默认在/var/lib/mysql里面\nSHOW VARIABLES LIKE 'slow_query_log';\n\n# 修改/etc/my.cnf中配置开启，配置时间\nslow_query_log=1   \nlong_query_time=2\n```\n\n**profile详情**\n\n```mysql\n# 查看是否支持prifile\nSELECT @@have_profiling;\n\n# 设置为开\nSET profiling=1;\n\n# 查看profile\nSHOW PROFILES;\n```\n\n执行完SQL语句以后，通过以下指令查看执行耗时情况\n\n```mysql\n# 查看每一条SQL耗时基本情况\nSHOW PROFILES;\n\n# 查看指定query_id的SQL语句各个阶段的耗时情况\nSHOW PROFILE FOR QUERY query_id;\n\n# 查看指定SQL语句的CPU使用情况\nSHOW PROFILE CPU FOR QUERY query_id;\n```\n\n**explain执行计划**\n\n> EXPLAIN或者DESC命令获取Mysql如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序\n\n```mysql\nEXPLAIN SELECT SQL语句;\n```\n\n![image-20240218211138993](database-mysql/image-20240218211138993.png)\n\n表头的含义：\n\n![image-20240218212814126](database-mysql/image-20240218212814126.png)\n\n![image-20240218212115878](database-mysql/image-20240218212115878.png)\n\n```txt\ntype\nconst\t以主键或以唯一的列作为索引扫描\nref\t\t非唯一的值作为查询索引\nindex\t用了索引，但是会对整个索引进行遍历\nall\t\t全表扫描\n```\n\n* #### **索引使用**\n\n**联合索引**\n\n使用要遵循**最左前缀法则**：查询**从索引的最左列开始**，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。\n\n**范围查询**：联合索引中出现范围查询（>,<)，范围查询右侧的列索引失效。但是使用大于等于和小于等于索引并不会失效。\n\n例子\n\n```mysql\n# student有联合索引(id,name,age)\n# 1、索引都可以使用\nselect * from student where id = 1 and name = \"Lili\" and age = 20;\n\n# 2、索引name，age失效\nselect * from student where id = 1 and age = 20;\n\n# 范围查询\n# name和age索引均失效\nselect * from student where id > 1 and name = \"Lili\" and age = 20;\n```\n\n**索引失效**\n\n索引列操作：不要在索引上进行列操作，否则索引会失效\n\n字符串类型：不加单引号索引会失效\n\n模糊查询：**头部进行模糊匹配(%%某某)**，索引会失效，尾部进行模糊匹配（某某%%），索引不会失效。\n\nor连接的条件：如果or前面的条件列有索引，后面的条件没有索引，所涉及的索引都不会引用到，只有两侧都有索引的时候，才有效\n\n数据分布影响：如果索引比全表扫描更慢，则不使用索引，查询的数据大于一半，走全表不走索引。\n\n**SQL提示**\n\n> 在sql语句中加入一些认为的提示来达到优化操作的目的\n\n```mysql\n# use index指定使用哪个索引\nexplain select * from table use index(idxname) ...\n\n# ignore index\n# force index 同上\n```\n\n**覆盖索引**\n\n尽量使用覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到，减少使用select *\n\nusing index condition：查找使用了索引，但是需要回表查询数据\n\nusing where, using index：查询使用了索引，但是不需要回表\n\n![image-20240218221642388](database-mysql/image-20240218221642388.png)\n\n前两条不需要回表，后一条需要回表\n\n**前缀索引**\n\n> 将字符串的前缀提取出来，创建索引，可以节约索引空间\n\n```mysql\n# n表示取column_name列的前n个数据\nCREATE INDEX idx_XXX ON table_name(column_name(n));\n\n# 计算前缀长度的选择性，越接近1越好\nSELECT COUNT(DISTINCT substring(email, 1, 5)) / COUNT(*) FROM table_name;\n```\n\n**单列索引和联合索引选择**\n\n如果涉及到多个查询条件，推荐使用联合索引，联合索引会更少的回表查询\n\n#### Quetion\n\n![image-20240218221919863](database-mysql/image-20240218221919863.png)\n\n建立id主键，username，password联合索引\n\n* #### **索引设计原则**\n\n![image-20240218224016746](database-mysql/image-20240218224016746.png)\n\n### 3、SQL优化\n\n* #### **插入数据**insert优化\n\n  批量插入而不是单条插入：批量插入只需要建立一次连接即可\n\n  建议手动提交事务：不需要每一次插入时自动开启和关闭事务，而是将所有insert执行结束以后统一关闭\n\n  **建议主键顺序插入**\n\n  大批量插入数据：使用Mysql数据库提供的load指令进行插入\n\n  ```mysql\n  # 如何使用load\n  # 1、连接服务器时加上参数--local-infile\n  mysql --local-infile -u root -p\n  \n  # 2、设置全局参数local_infile为1\n  set global local_infile = 1;\n  \n  # 3、执行load指令将数据加载表结构中\n  load data local infile '文件名' into table '表名' fields teminated by '分割符' lines terminated by '行分隔符\\n';\n  ```\n\n* #### **主键优化**\n\n> InnoDB中表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表。\n\n页大小为16kb，每个页至少包含两行数据\n\n主键乱序插入可能会出现页分裂现象，执行删除操作会出现页合并现象\n\n主键设计原则：\n\n​\t满足业务需求的情况下，尽量降低主键的长度\n\n​\t插入时尽量按照主键顺序插入，选择自增主键\n\n​\t尽量不要使用无序的自然主键\n\n​\t业务操作，避免对主键的修改\n\n* **order by优化**\n\n排序方式\n\nUsing filesort：先找到数据再进行排序\n\nUsing index：通过有序索引直接返回，不需要额外排序\n\n默认会对索引进行升序排序\n\n* **limit优化**\n\n对于数据量大的，优化思路为使用覆盖索引+子查询\n\n* count\n\n  count(*)优于count(1)>count(主键)>count(字段)\n\n* #### **update优化**\n\n对需要更新的字段尽可能建立索引，这样如果处于多个事务情况下，只会使用行锁，如果没有建立索引，行锁会升级为表锁，无法进行并行\n\n### 4、视图/存储过程/触发器\n\n* #### 视图\n\n> 视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。\n\n* #### 存储过程\n\n* #### 存储函数\n\n* #### 触发器\n\n### 5、锁\n\n### 6、InnoDB核心\n\n### 7、MySQL管理\n\n\n\n## 数据库运维\n\n### 1、日志\n\n### 2、主从复制\n\n### 3、分库分表\n\n### 4、读写分离\n\n### \n","slug":"database-mysql","published":0,"updated":"2024-02-20T07:03:21.754Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xo0004g4c23jo2hymx","content":"<h2 id=\"数据库-Mysql\"><a href=\"#数据库-Mysql\" class=\"headerlink\" title=\"数据库-Mysql\"></a>数据库-Mysql</h2><blockquote>\n<p>Mysql数据库的关键词：事务、存储引擎、索引、SQL优化、<strong>锁、日志、主从复制、读写分离、分库分表</strong></p>\n</blockquote>\n\n<h2 id=\"数据库基础\"><a href=\"#数据库基础\" class=\"headerlink\" title=\"数据库基础\"></a>数据库基础</h2><h3 id=\"1、Mysql概述\"><a href=\"#1、Mysql概述\" class=\"headerlink\" title=\"1、Mysql概述\"></a>1、Mysql概述</h3><p>关系型数据库：建立在关系模型基础上，由多张互连接的二维表组成的数据库</p>\n<p>特点：使用表存储数据，便于维护；使用sql语句操作，使用方便</p>\n<p><strong>MySQL数据模型</strong></p>\n<blockquote>\n<p>1、客户端通过与数据库管理系统进行连接</p>\n<p>2、使用sql语句通过数据库管理系统对指定的数据库进行增删改查</p>\n<p>3、一个数据库模型中可以对多个数据库进行管理，一个数据库中可以拥有多个表</p>\n</blockquote>\n<p>// TODO数据库模型的图</p>\n<h3 id=\"2、SQL\"><a href=\"#2、SQL\" class=\"headerlink\" title=\"2、SQL\"></a>2、SQL</h3><p><strong>SQL分类</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>全称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DDL</td>\n<td>Data Definition Language</td>\n<td>数据库定义语句，定义数据库对象，数据库，表，字段等</td>\n</tr>\n<tr>\n<td>DML</td>\n<td>Data Manipulation Language</td>\n<td>数据库操作语句，用于对数据库表中的数据进行增增删改</td>\n</tr>\n<tr>\n<td>DQL</td>\n<td>Data Query Language</td>\n<td>数据库查询语句，查询数据库表中的记录</td>\n</tr>\n<tr>\n<td>DCL</td>\n<td>Data Control Language</td>\n<td>数据库控制语句，创建数据库用户，控制数据库的访问权限</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><h4 id=\"DDL\"><a href=\"#DDL\" class=\"headerlink\" title=\"DDL\"></a>DDL</h4><p><strong>数据库层次</strong></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查询所有数据库表格<br>SHOW DATABASES;<br># 查询当前所在的数据库<br>SELECT DATABASE();<br># 创建数据库，方括号可以省略<br>CREATE DATABASE [IF NOT EXISTS] 数据库名 [COLLATE 排序规则]<br># 删除数据库<br>DROP DATABASE [IF EXISTS] 数据库名<br># 使用数据库，切换到数据库当中<br>USE 数据库名<br></code></pre></td></tr></table></figure>\n<p>​        表结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看所有表<br>SHOW TABLES;<br># 查询表结构<br>DESC 表名<br># 查询指定表的建表语句<br>SHOW CREATE TABLE 表名;<br></code></pre></td></tr></table></figure>\n<p>​        MySQL中的数据类型</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>描述</th>\n<th>大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TINYINT</td>\n<td>微小整数，有符号或无符号（UNSIGNED）</td>\n<td>1 字节</td>\n</tr>\n<tr>\n<td>SMALLINT</td>\n<td>小整数，有符号或无符号</td>\n<td>2 字节</td>\n</tr>\n<tr>\n<td>MEDIUMINT</td>\n<td>中等整数，有符号或无符号</td>\n<td>3 字节</td>\n</tr>\n<tr>\n<td>INT 或 INTEGER</td>\n<td>整数，有符号或无符号</td>\n<td>4 字节</td>\n</tr>\n<tr>\n<td>BIGINT</td>\n<td>大整数，有符号或无符号</td>\n<td>8 字节</td>\n</tr>\n<tr>\n<td>FLOAT(M,D)</td>\n<td>单精度浮点数，M 是总位数，D 是小数位数</td>\n<td>4 字节</td>\n</tr>\n<tr>\n<td>DOUBLE(M,D)</td>\n<td>双精度浮点数，M 是总位数，D 是小数位数</td>\n<td>8 字节</td>\n</tr>\n<tr>\n<td>DECIMAL(M,D)</td>\n<td>定点数，M 是总位数，D 是小数位数</td>\n<td>取决于 M 和 D</td>\n</tr>\n<tr>\n<td>DATE</td>\n<td>日期 YYYY-MM-DD</td>\n<td>3 字节</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>时间 HH:MM:SS</td>\n<td>3 字节</td>\n</tr>\n<tr>\n<td>DATETIME</td>\n<td>日期和时间</td>\n<td>8 字节</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>时间戳</td>\n<td>4 字节</td>\n</tr>\n<tr>\n<td>CHAR(N)</td>\n<td><strong>定长</strong>字符串，最大长度为 N</td>\n<td>最大 255 字节</td>\n</tr>\n<tr>\n<td>VARCHAR(N)</td>\n<td><strong>变长</strong>字符串，最大长度为 N</td>\n<td>最大 65,535 字节</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>变长文本，最大长度为 65,535 字节</td>\n<td>最大 65,535 字节</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>二进制大对象，最大长度为 65,535 字节</td>\n<td>最大 65,535 字节</td>\n</tr>\n<tr>\n<td>ENUM</td>\n<td>枚举类型</td>\n<td>1 或 2 字节，取决于成员数量</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>集合类型</td>\n<td>1、2、3、4 或 8 字节，取决于成员数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>创建表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">CREATE TABLE member(<br>    number INT COMMENT &#x27;编号&#x27;,<br>    id CHAR(10) COMMENT &#x27;员工工号&#x27;,<br>    name VARCHAR(10) COMMENT &#x27;员工姓名&#x27;,<br>    gender CHAR(4) COMMENT &#x27;员工性别&#x27;,<br>    age INT UNSIGNED COMMENT &#x27;年龄&#x27;,<br>    id_number CHAR(18) COMMENT &#x27;身份证号&#x27;,<br>    time DATE COMMENT &#x27;入职时间&#x27;<br>)<br></code></pre></td></tr></table></figure>\n<p><strong>表结构的修改</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 添加字段<br>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束];<br><br># 修改字段和字段类型<br>ALTER TABLE 表明 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束]<br><br># 删除字段<br>ALTER TABLE 表名 DROP 字段名;<br><br># 修改表名<br>ALTER TABLE 表名 RENAME TO 新表名;<br><br># 删除表<br>DROP TABLE [IF EXSITS] 表名;<br># 删除指定表并重新创建该表，清空数据<br>TRUNCATE TABLE 表名;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"DML（数据操作语言）\"><a href=\"#DML（数据操作语言）\" class=\"headerlink\" title=\"DML（数据操作语言）\"></a>DML（数据操作语言）</h4></li>\n</ul>\n<p><strong>添加数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 给指定字段添加数据<br>INSERT INTO 表名(字段名1, 字段名2, ...) VALUES (值1, 值2, ...);<br><br># 给全部字段添加数据<br>INSERT INTO 表名 VALUES(值1, 值2, ...);<br></code></pre></td></tr></table></figure>\n<p><strong>修改数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 修改数据<br>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ...[WHERE 条件];<br></code></pre></td></tr></table></figure>\n<p><strong>删除数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 删除数据<br>DELETE FROM 表名 [WHERE 条件];<br></code></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"DQL\"><a href=\"#DQL\" class=\"headerlink\" title=\"DQL\"></a>DQL</h4><blockquote>\n<p>数据库查询语言，用来查询数据库中的表的记录</p>\n<p>SELECT后面加上\\G可以将某一行转化为一列查看</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>语法结构</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT<br>\t字段列表<br>FROM<br>\t表名列表<br>WHERE<br>\t条件列表(条件查询)<br>GROUP BY<br>\t分组字段列表(分组查询)<br>HAVING<br>\t分组后条件列表<br>ORDER BY<br>\t排序字段列表<br>LIMIT<br>\t分页参数<br></code></pre></td></tr></table></figure>\n<p><strong>基本查询</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 字段1 [AS 别名]，字段2 [AS 别名]， FROM 表名;<br><br># 去重<br>SELECT DISTINCT 字段列表 FROM 表名;<br></code></pre></td></tr></table></figure>\n<p><strong>条件查询</strong></p>\n<p>条件运算符</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">比较运算符</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">&lt;&gt;或!=</td>\n<td style=\"text-align:center\">不等于</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BETWEEN … AND …</td>\n<td style=\"text-align:center\">在某个范围之内</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IN(…)</td>\n<td style=\"text-align:center\">在in之后的列表中的值，多选一</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LIKE 占位符</td>\n<td style=\"text-align:center\">模糊匹配(_匹配单个字符，%匹配任意个字符)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IS NULL</td>\n<td style=\"text-align:center\">是NULL</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>聚和函数</strong></p>\n<blockquote>\n<p>将一列数据作为一个整体，进行纵向计算。</p>\n</blockquote>\n<p>所有的null值不参与聚合函数的计算</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">count</td>\n<td style=\"text-align:center\">统计数量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">max</td>\n<td style=\"text-align:center\">最大值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">min</td>\n<td style=\"text-align:center\">最小值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">avg</td>\n<td style=\"text-align:center\">平均值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sum</td>\n<td style=\"text-align:center\">求和</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 聚合函数(字段列表) FROM 表名;<br></code></pre></td></tr></table></figure>\n<p><strong>分组查询</strong></p>\n<blockquote>\n<p>在where中不可以使用聚合函数，在having中可以使用聚合函数</p>\n<p>分组之前过滤用where，分组之后过滤条件用having</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 字段列表\tFROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];<br></code></pre></td></tr></table></figure>\n<p>执行顺序：where &gt; 聚合函数 &gt; having</p>\n<p><strong>排序查询</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2<br></code></pre></td></tr></table></figure>\n<p>排序方式： ASC升序（默认），DESC降序</p>\n<p><strong>分页查询</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;<br></code></pre></td></tr></table></figure>\n<p>显示从起始索引开始的记录数条的查询结果</p>\n<p><strong>DQL执行顺序</strong></p>\n<p>FROM &gt; WHERE &gt; GROUP BY &gt; SELECT &gt; ORDER BY &gt; LIMIT</p>\n<ul>\n<li><h4 id=\"DCL\"><a href=\"#DCL\" class=\"headerlink\" title=\"DCL\"></a>DCL</h4></li>\n</ul>\n<blockquote>\n<p>数据控制语句，用来管理数据库用户，控制数据库访问权限</p>\n</blockquote>\n<p><strong>DCL用户管理</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查询用户<br>USE mysql;<br>SELECT * FROM user;<br><br># 创建用户，主机名换成&quot;%&quot;表示可以在任意主机访问数据库<br>CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;<br><br># 修改用户密码<br>ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;<br><br># 删除用户<br>DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></td></tr></table></figure>\n<p><strong>权限控制</strong></p>\n<p>常用权限</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">权限</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ALL, ALL PRIVILEGES</td>\n<td style=\"text-align:center\">所有权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SELECT</td>\n<td style=\"text-align:center\">查询数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">INSERT</td>\n<td style=\"text-align:center\">插入数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UPDATE</td>\n<td style=\"text-align:center\">修改数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DELETE</td>\n<td style=\"text-align:center\">删除数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ALTER</td>\n<td style=\"text-align:center\">修改表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DROP</td>\n<td style=\"text-align:center\">删除数据库/表/视图</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CREATE</td>\n<td style=\"text-align:center\">创建数据库/表</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查询权限<br>SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br># 授予权限<br>GRANT 权限列表 ON 数据库名.表名(*.*所有表) TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br># 撤销权限<br>REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3、函数\"><a href=\"#3、函数\" class=\"headerlink\" title=\"3、函数\"></a>3、函数</h3><ul>\n<li><strong>字符串函数</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CONCAT(S1,S2, … Sn)</td>\n<td style=\"text-align:center\">字符串拼接，将S1-Sn拼接成一个字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LOWER(str)</td>\n<td style=\"text-align:center\">将字符串str全部转为小写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UPPER(str)</td>\n<td style=\"text-align:center\">将字符串全部转为大写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LPAD(str, n, pad)</td>\n<td style=\"text-align:center\">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RPAD(str, n,  pad)</td>\n<td style=\"text-align:center\">右填充</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TRIM(str)</td>\n<td style=\"text-align:center\">去掉字符串头部和尾部的空格</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SUBSTRING(str, start, len)</td>\n<td style=\"text-align:center\">返回从字符串str从start起的len长度的字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 函数;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><strong>数值函数</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CEIL(x)</td>\n<td style=\"text-align:center\">向上取整</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FLOOR(x)</td>\n<td style=\"text-align:center\">向下取整</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MOD(x, y)</td>\n<td style=\"text-align:center\">返回x/y的模</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RAND()</td>\n<td style=\"text-align:center\">返回0~1内的随机数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ROUND(x, y)</td>\n<td style=\"text-align:center\">求参数x的四舍五入的值，保留y位小数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><strong>日期函数</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CURDATE()</td>\n<td style=\"text-align:center\">返回当前日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CURTIME()</td>\n<td style=\"text-align:center\">返回当前时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NOW()</td>\n<td style=\"text-align:center\">返回当前日期和时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">YEAR(date)</td>\n<td style=\"text-align:center\">获取指定date的年份</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MONTH(date)</td>\n<td style=\"text-align:center\">获取指定date的月份</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DAY(date)</td>\n<td style=\"text-align:center\">获取指定date的日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DATE_ADD(date, INTERVAL expr type)</td>\n<td style=\"text-align:center\">返回上一个日期加上时间间隔expr以后的时间值，type(year,month,day)指定年月天</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DATEDIFF(date1, date2)</td>\n<td style=\"text-align:center\">返回起始时间date1和结束时间date2之间的天数，第一个时间减去第二个时间</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><strong>流程函数</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IF(value, t. f)</td>\n<td style=\"text-align:center\">如果value为true，返回t，否则返回f</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IFNULL(value1, value2)</td>\n<td style=\"text-align:center\">如果value1不为空，返回value1，否则返回value2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CASE WHEN [val] THEN [res1] … ELSE [ default ] END</td>\n<td style=\"text-align:center\">如果val1为true，返回res1，…否则返回default默认值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td>\n<td style=\"text-align:center\">如果expr的值等于val1，返回res1，…否则返回default默认值</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"4、约束\"><a href=\"#4、约束\" class=\"headerlink\" title=\"4、约束\"></a>4、约束</h3><p>作用于表中字段上的规则，用于限制存储在表中的数据</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">约束</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">非空约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">唯一约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主键约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">默认约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">检查约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">外键约束</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"5、多表查询\"><a href=\"#5、多表查询\" class=\"headerlink\" title=\"5、多表查询\"></a>5、多表查询</h3><ul>\n<li><p><strong>多表关系</strong></p>\n<p>一对多：在多的一方建立外键，指向一的一方的主键</p>\n</li>\n</ul>\n<p>​        多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方的主键</p>\n<p>​        一对一：用于做单表拆分，基础字段放在一张表，详情字段放在另一张表。在任意一方加入外键，关联另一方的主键，并设置外键为唯一（UNIQUE）</p>\n<ul>\n<li><p><strong>多表查询</strong></p>\n<ul>\n<li><p>内连接</p>\n<blockquote>\n<p>相当于查询A、B交集部分数据</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 隐式内连接<br>SELECT 字段列表 FROM 表1，表2 WHERE 条件...;<br><br># 显示内连接<br>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>外连接</p>\n<blockquote>\n<p>左外连接：查询左表所有数据，以及两张表交集部分数据，将左表的数据和右表的部分数据连接起来</p>\n<p>右外连接：查询右表所有数据，以及两张表交集部分数据</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 左外连接，表1所有数据以及和表2交集部分的数据<br>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;<br><br># 右外连接，表2所有数据以及和表1交集部分的数据<br>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>自连接</p>\n<blockquote>\n<p>自连接：当前表与自身的连接查询，自连接必须使用表别名</p>\n</blockquote>\n</li>\n<li><p>联合查询-union，union all</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 把多次查询的结果合并起来，形成一个新的查询结果集<br># ALL去掉以后会对结果进行去重<br>SELECT 字段列表 表A<br>UNION [ALL]<br>SELECT 字段列表 表B;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>子查询</strong></p>\n<ul>\n<li><p>标量子查询，子查询返回一个标量</p>\n</li>\n<li><p>列子查询，子查询返回一列</p>\n<p>| 操作符 |                 描述                 |<br>| :——: | :—————————————————: |<br>|   IN   |     在指定的集合范围之内，多选一     |<br>| NOT IN |          不在指定的范围之内          |<br>|  ANY   | 子查询返回列表中，有任意一个满足即可 |<br>|  SOME  |              与ANY等同               |<br>|  ALL   |   子查询返回列表的所有值都必须满足   |</p>\n</li>\n<li><p>行子查询，子查询返回的结果是一行</p>\n<p>此时column1可以使用(column1， column2)聚合成多个参数</p>\n<p>操作符：=、&lt;&gt;、IN、NOT IN</p>\n</li>\n<li><p>表子查询，子查询的返回结果是一个表，可以和行子查询加上列子查询的操作符使用，表可以放到from后面</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 对于子查询，可以将问题拆解成多个不同的查询步骤<br>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);<br></code></pre></td></tr></table></figure>\n<h3 id=\"6、事务\"><a href=\"#6、事务\" class=\"headerlink\" title=\"6、事务\"></a>6、事务</h3><blockquote>\n<p>一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么<strong>同时成功，要么同时失败</strong></p>\n<p>默认Mysql的事务是自动提交的，当执行一条DML语句，Mysql会立即隐式的提交事务</p>\n</blockquote>\n<ul>\n<li><strong>事务操作</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看/设置事务提交方式<br>SELECT @@autocommit;<br># 事务设置为手动提交<br>SET @@autocommit = 0;<br><br># 提交事务<br>COMMIT;<br><br># 回滚事务<br>ROLLBACK;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 不修改事务的提交方式操作事务<br># 开启事务<br>START TRANSACTION 或 BEGIN;<br><br># 提交事务<br>COMMIT;<br><br># 回滚事务<br>ROLLBACK;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>事务四大特性</strong></p>\n<ul>\n<li>原子性(Atomicity)：事务时不可分割的最小操作单元，要么全部成功，要么全部失败</li>\n<li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态</li>\n<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>\n<li>持久性(Durability)：事务一旦提交或者回滚，它对数据库中的数据改变就是永久的</li>\n</ul>\n</li>\n<li><p><strong>并发事务问题</strong></p>\n<p>|    问题    |                             描述                             |<br>| :————: | :—————————————————————————————: |<br>|    脏读    |            一个事务读到另一个事务还没有提交的数据            |<br>| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读 |<br>|    幻读    | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这一行数据已经存在 |</p>\n</li>\n<li><p><strong>事务隔离级别</strong></p>\n<blockquote>\n<p>读未提交、读已提交、可重复读、串行化</p>\n<p>√表示会出现这个问题，×表示不会出现这个问题</p>\n</blockquote>\n<p>|     隔离级别     | 脏读 | 不可重复读 | 幻读 |<br>| :———————: | :—: | :————: | :—: |<br>| Read uncommitted |  √   |     √      |  √   |<br>|  Read committed  |  ×   |     √      |  √   |<br>| Repeatable Read  |  ×   |     ×      |  √   |<br>|   Serializable   |  ×   |     ×      |  ×   |</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看事务的隔离级别<br>SELECT @@TRANSACTION_ISOLATION;<br><br># 设置事务隔离级别<br>SET [SESSION(只对当前窗口有效)|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;<br></code></pre></td></tr></table></figure>\n<p>事务的隔离界别越高，数据越安全，但是性能越低</p>\n</li>\n</ul>\n<h2 id=\"数据库进阶\"><a href=\"#数据库进阶\" class=\"headerlink\" title=\"数据库进阶\"></a>数据库进阶</h2><h3 id=\"1、存储引擎\"><a href=\"#1、存储引擎\" class=\"headerlink\" title=\"1、存储引擎\"></a>1、存储引擎</h3><ul>\n<li><p>Mysql体系结构 </p>\n<p>连接层：完成一些类似于连接处理、授权认证及相关的安全方案</p>\n<p>服务层：主要完成大多数的核心服务功能</p>\n<p>引擎层：负责mysql中数据的存储和提取，服务器通过API和存储引擎进行通信</p>\n<p>存储层：将数据存储在文件系统之上，并完成与存储引擎的交互</p>\n\n</li>\n<li><p>存储引擎</p>\n<blockquote>\n<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎时基于表的，而不是基于库的。一个数据库的不同的表可以选择不同的存储引擎</p>\n<p>Mysql默认InnoDB</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查询支持的存储引擎<br>show engines;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>InnoDB</p>\n<ul>\n<li>DML操作遵循ACID模型，支持事务</li>\n<li>行级锁，提高并发访问性能</li>\n<li>支持外键，保证事务的完整性和正确性</li>\n</ul>\n<p>文件：每个表对应一个.ibd文件，代表表空间文件，可以通过命令<code>idb2sdi 文件名</code>查看表结构json文件格式</p>\n\n</li>\n<li><p>MyISAM</p>\n<ul>\n<li>不支持事务，不支持外键</li>\n<li>支持表锁、不支持行锁</li>\n<li>访问速度快</li>\n</ul>\n<p>文件.MYD（数据），.MYI（索引），.sdi（表结构）</p>\n</li>\n<li><p>Memory</p>\n<ul>\n<li>表数据存储在内存当中，收到硬件问题或断电影响只能作为临时表或者缓存使用</li>\n<li>内存存放</li>\n<li>hash索引（默认）</li>\n</ul>\n</li>\n</ul>\n\n<ul>\n<li><p>存储引擎选择</p>\n<p>InnoDB：如果对事务的完整性有比较高的要求，在并发情况下要求事务的一致性，数据操作除了插入和查询意外，还包括很多的更新、删除操作，InnoDB引擎比较合适</p>\n<p>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性和并发现要求不是很高。<strong>这个场景被Nosql数据库MongoDB替代了</strong></p>\n<p>MEMORY：将所有数据保存在内存当中，访问速度快，通常用于临时表以及缓存。MEMORY对表的大小有限制，太大的表无法缓存在内存中。<strong>这个场景被Redis替代了</strong></p>\n</li>\n</ul>\n<h3 id=\"2、索引\"><a href=\"#2、索引\" class=\"headerlink\" title=\"2、索引\"></a>2、索引</h3><ul>\n<li><p><strong>索引概述</strong></p>\n<ul>\n<li>索引的结构</li>\n</ul>\n</li>\n<li><h4 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a><strong>索引分类</strong></h4></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">分类</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">特点</th>\n<th style=\"text-align:center\">关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">主键索引</td>\n<td style=\"text-align:center\">针对于表中主键创建的索引</td>\n<td style=\"text-align:center\">默认自动创建，只能有一个</td>\n<td style=\"text-align:center\">PRIMARY</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">唯一索引</td>\n<td style=\"text-align:center\">避免同一个表中某数据列中的值重复</td>\n<td style=\"text-align:center\">可以有多个</td>\n<td style=\"text-align:center\">UNIQUE</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">常规索引</td>\n<td style=\"text-align:center\">快速定位特定数据</td>\n<td style=\"text-align:center\">可以有多个</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">全文索引</td>\n<td style=\"text-align:center\">全文索引查找的是文本中通过的关键词</td>\n<td style=\"text-align:center\">可以有多个</td>\n<td style=\"text-align:center\">FULLTEXT</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>按照索引的存储形式分类</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">分类</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">聚集索引</td>\n<td style=\"text-align:center\">将数据存储与索引放到了一块</td>\n<td style=\"text-align:center\">必须有，而且只有一个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">二级索引</td>\n<td style=\"text-align:center\">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>\n<td style=\"text-align:center\">可以存在多个</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n<ul>\n<li><h4 id=\"索引语法\"><a href=\"#索引语法\" class=\"headerlink\" title=\"索引语法\"></a><strong>索引语法</strong></h4></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 创建索引<br># 一个索引可以关联多行，如果关联多行称为联合索引<br>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name, )<br><br># 查看索引<br>SHOW INDEX FROM table_name;<br><br># 删除索引<br>DROP INDEX index_name ON table_name;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"SQL性能分析\"><a href=\"#SQL性能分析\" class=\"headerlink\" title=\"SQL性能分析\"></a><strong>SQL性能分析</strong></h4><blockquote>\n<p>使用于select的优化</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># SQL执行频率，查看当前数据库语句的访问频率<br>SHOW [session|global] STATUS<br># Com七个下划线，模糊匹配<br>SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;<br></code></pre></td></tr></table></figure>\n<p><strong>SQL语句的频率</strong></p>\n\n<p><strong>慢查询日志</strong></p>\n<blockquote>\n<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10)的所有SQL语句的日志</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看是否开启，日志文件默认在/var/lib/mysql里面<br>SHOW VARIABLES LIKE &#x27;slow_query_log&#x27;;<br><br># 修改/etc/my.cnf中配置开启，配置时间<br>slow_query_log=1   <br>long_query_time=2<br></code></pre></td></tr></table></figure>\n<p><strong>profile详情</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看是否支持prifile<br>SELECT @@have_profiling;<br><br># 设置为开<br>SET profiling=1;<br><br># 查看profile<br>SHOW PROFILES;<br></code></pre></td></tr></table></figure>\n<p>执行完SQL语句以后，通过以下指令查看执行耗时情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看每一条SQL耗时基本情况<br>SHOW PROFILES;<br><br># 查看指定query_id的SQL语句各个阶段的耗时情况<br>SHOW PROFILE FOR QUERY query_id;<br><br># 查看指定SQL语句的CPU使用情况<br>SHOW PROFILE CPU FOR QUERY query_id;<br></code></pre></td></tr></table></figure>\n<p><strong>explain执行计划</strong></p>\n<blockquote>\n<p>EXPLAIN或者DESC命令获取Mysql如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">EXPLAIN SELECT SQL语句;<br></code></pre></td></tr></table></figure>\n\n<p>表头的含义：</p>\n\n\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">type<br>const\t以主键或以唯一的列作为索引扫描<br>ref\t\t非唯一的值作为查询索引<br>index\t用了索引，但是会对整个索引进行遍历<br>all\t\t全表扫描<br></code></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"索引使用\"><a href=\"#索引使用\" class=\"headerlink\" title=\"索引使用\"></a><strong>索引使用</strong></h4></li>\n</ul>\n<p><strong>联合索引</strong></p>\n<p>使用要遵循<strong>最左前缀法则</strong>：查询<strong>从索引的最左列开始</strong>，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>\n<p><strong>范围查询</strong>：联合索引中出现范围查询（&gt;,&lt;)，范围查询右侧的列索引失效。但是使用大于等于和小于等于索引并不会失效。</p>\n<p>例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># student有联合索引(id,name,age)<br># 1、索引都可以使用<br>select * from student where id = 1 and name = &quot;Lili&quot; and age = 20;<br><br># 2、索引name，age失效<br>select * from student where id = 1 and age = 20;<br><br># 范围查询<br># name和age索引均失效<br>select * from student where id &gt; 1 and name = &quot;Lili&quot; and age = 20;<br></code></pre></td></tr></table></figure>\n<p><strong>索引失效</strong></p>\n<p>索引列操作：不要在索引上进行列操作，否则索引会失效</p>\n<p>字符串类型：不加单引号索引会失效</p>\n<p>模糊查询：<strong>头部进行模糊匹配(%%某某)</strong>，索引会失效，尾部进行模糊匹配（某某%%），索引不会失效。</p>\n<p>or连接的条件：如果or前面的条件列有索引，后面的条件没有索引，所涉及的索引都不会引用到，只有两侧都有索引的时候，才有效</p>\n<p>数据分布影响：如果索引比全表扫描更慢，则不使用索引，查询的数据大于一半，走全表不走索引。</p>\n<p><strong>SQL提示</strong></p>\n<blockquote>\n<p>在sql语句中加入一些认为的提示来达到优化操作的目的</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># use index指定使用哪个索引<br>explain select * from table use index(idxname) ...<br><br># ignore index<br># force index 同上<br></code></pre></td></tr></table></figure>\n<p><strong>覆盖索引</strong></p>\n<p>尽量使用覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到，减少使用select *</p>\n<p>using index condition：查找使用了索引，但是需要回表查询数据</p>\n<p>using where, using index：查询使用了索引，但是不需要回表</p>\n\n<p>前两条不需要回表，后一条需要回表</p>\n<p><strong>前缀索引</strong></p>\n<blockquote>\n<p>将字符串的前缀提取出来，创建索引，可以节约索引空间</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># n表示取column_name列的前n个数据<br>CREATE INDEX idx_XXX ON table_name(column_name(n));<br><br># 计算前缀长度的选择性，越接近1越好<br>SELECT COUNT(DISTINCT substring(email, 1, 5)) / COUNT(*) FROM table_name;<br></code></pre></td></tr></table></figure>\n<p><strong>单列索引和联合索引选择</strong></p>\n<p>如果涉及到多个查询条件，推荐使用联合索引，联合索引会更少的回表查询</p>\n<h4 id=\"Quetion\"><a href=\"#Quetion\" class=\"headerlink\" title=\"Quetion\"></a>Quetion</h4>\n<p>建立id主键，username，password联合索引</p>\n<ul>\n<li><h4 id=\"索引设计原则\"><a href=\"#索引设计原则\" class=\"headerlink\" title=\"索引设计原则\"></a><strong>索引设计原则</strong></h4></li>\n</ul>\n\n<h3 id=\"3、SQL优化\"><a href=\"#3、SQL优化\" class=\"headerlink\" title=\"3、SQL优化\"></a>3、SQL优化</h3><ul>\n<li><h4 id=\"插入数据insert优化\"><a href=\"#插入数据insert优化\" class=\"headerlink\" title=\"插入数据insert优化\"></a><strong>插入数据</strong>insert优化</h4><p>批量插入而不是单条插入：批量插入只需要建立一次连接即可</p>\n<p>建议手动提交事务：不需要每一次插入时自动开启和关闭事务，而是将所有insert执行结束以后统一关闭</p>\n<p><strong>建议主键顺序插入</strong></p>\n<p>大批量插入数据：使用Mysql数据库提供的load指令进行插入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 如何使用load<br># 1、连接服务器时加上参数--local-infile<br>mysql --local-infile -u root -p<br><br># 2、设置全局参数local_infile为1<br>set global local_infile = 1;<br><br># 3、执行load指令将数据加载表结构中<br>load data local infile &#x27;文件名&#x27; into table &#x27;表名&#x27; fields teminated by &#x27;分割符&#x27; lines terminated by &#x27;行分隔符\\n&#x27;;<br></code></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"主键优化\"><a href=\"#主键优化\" class=\"headerlink\" title=\"主键优化\"></a><strong>主键优化</strong></h4></li>\n</ul>\n<blockquote>\n<p>InnoDB中表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表。</p>\n</blockquote>\n<p>页大小为16kb，每个页至少包含两行数据</p>\n<p>主键乱序插入可能会出现页分裂现象，执行删除操作会出现页合并现象</p>\n<p>主键设计原则：</p>\n<p>​    满足业务需求的情况下，尽量降低主键的长度</p>\n<p>​    插入时尽量按照主键顺序插入，选择自增主键</p>\n<p>​    尽量不要使用无序的自然主键</p>\n<p>​    业务操作，避免对主键的修改</p>\n<ul>\n<li><strong>order by优化</strong></li>\n</ul>\n<p>排序方式</p>\n<p>Using filesort：先找到数据再进行排序</p>\n<p>Using index：通过有序索引直接返回，不需要额外排序</p>\n<p>默认会对索引进行升序排序</p>\n<ul>\n<li><strong>limit优化</strong></li>\n</ul>\n<p>对于数据量大的，优化思路为使用覆盖索引+子查询</p>\n<ul>\n<li><p>count</p>\n<p>count(*)优于count(1)&gt;count(主键)&gt;count(字段)</p>\n</li>\n<li><h4 id=\"update优化\"><a href=\"#update优化\" class=\"headerlink\" title=\"update优化\"></a><strong>update优化</strong></h4></li>\n</ul>\n<p>对需要更新的字段尽可能建立索引，这样如果处于多个事务情况下，只会使用行锁，如果没有建立索引，行锁会升级为表锁，无法进行并行</p>\n<h3 id=\"4、视图-存储过程-触发器\"><a href=\"#4、视图-存储过程-触发器\" class=\"headerlink\" title=\"4、视图/存储过程/触发器\"></a>4、视图/存储过程/触发器</h3><ul>\n<li><h4 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h4></li>\n</ul>\n<blockquote>\n<p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>\n</blockquote>\n<ul>\n<li><h4 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h4></li>\n<li><h4 id=\"存储函数\"><a href=\"#存储函数\" class=\"headerlink\" title=\"存储函数\"></a>存储函数</h4></li>\n<li><h4 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h4></li>\n</ul>\n<h3 id=\"5、锁\"><a href=\"#5、锁\" class=\"headerlink\" title=\"5、锁\"></a>5、锁</h3><h3 id=\"6、InnoDB核心\"><a href=\"#6、InnoDB核心\" class=\"headerlink\" title=\"6、InnoDB核心\"></a>6、InnoDB核心</h3><h3 id=\"7、MySQL管理\"><a href=\"#7、MySQL管理\" class=\"headerlink\" title=\"7、MySQL管理\"></a>7、MySQL管理</h3><h2 id=\"数据库运维\"><a href=\"#数据库运维\" class=\"headerlink\" title=\"数据库运维\"></a>数据库运维</h2><h3 id=\"1、日志\"><a href=\"#1、日志\" class=\"headerlink\" title=\"1、日志\"></a>1、日志</h3><h3 id=\"2、主从复制\"><a href=\"#2、主从复制\" class=\"headerlink\" title=\"2、主从复制\"></a>2、主从复制</h3><h3 id=\"3、分库分表\"><a href=\"#3、分库分表\" class=\"headerlink\" title=\"3、分库分表\"></a>3、分库分表</h3><h3 id=\"4、读写分离\"><a href=\"#4、读写分离\" class=\"headerlink\" title=\"4、读写分离\"></a>4、读写分离</h3><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3>","cover_type":"img","excerpt":"","more":"<h2 id=\"数据库-Mysql\"><a href=\"#数据库-Mysql\" class=\"headerlink\" title=\"数据库-Mysql\"></a>数据库-Mysql</h2><blockquote>\n<p>Mysql数据库的关键词：事务、存储引擎、索引、SQL优化、<strong>锁、日志、主从复制、读写分离、分库分表</strong></p>\n</blockquote>\n\n<h2 id=\"数据库基础\"><a href=\"#数据库基础\" class=\"headerlink\" title=\"数据库基础\"></a>数据库基础</h2><h3 id=\"1、Mysql概述\"><a href=\"#1、Mysql概述\" class=\"headerlink\" title=\"1、Mysql概述\"></a>1、Mysql概述</h3><p>关系型数据库：建立在关系模型基础上，由多张互连接的二维表组成的数据库</p>\n<p>特点：使用表存储数据，便于维护；使用sql语句操作，使用方便</p>\n<p><strong>MySQL数据模型</strong></p>\n<blockquote>\n<p>1、客户端通过与数据库管理系统进行连接</p>\n<p>2、使用sql语句通过数据库管理系统对指定的数据库进行增删改查</p>\n<p>3、一个数据库模型中可以对多个数据库进行管理，一个数据库中可以拥有多个表</p>\n</blockquote>\n<p>// TODO数据库模型的图</p>\n<h3 id=\"2、SQL\"><a href=\"#2、SQL\" class=\"headerlink\" title=\"2、SQL\"></a>2、SQL</h3><p><strong>SQL分类</strong></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>全称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DDL</td>\n<td>Data Definition Language</td>\n<td>数据库定义语句，定义数据库对象，数据库，表，字段等</td>\n</tr>\n<tr>\n<td>DML</td>\n<td>Data Manipulation Language</td>\n<td>数据库操作语句，用于对数据库表中的数据进行增增删改</td>\n</tr>\n<tr>\n<td>DQL</td>\n<td>Data Query Language</td>\n<td>数据库查询语句，查询数据库表中的记录</td>\n</tr>\n<tr>\n<td>DCL</td>\n<td>Data Control Language</td>\n<td>数据库控制语句，创建数据库用户，控制数据库的访问权限</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><h4 id=\"DDL\"><a href=\"#DDL\" class=\"headerlink\" title=\"DDL\"></a>DDL</h4><p><strong>数据库层次</strong></p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查询所有数据库表格<br>SHOW DATABASES;<br># 查询当前所在的数据库<br>SELECT DATABASE();<br># 创建数据库，方括号可以省略<br>CREATE DATABASE [IF NOT EXISTS] 数据库名 [COLLATE 排序规则]<br># 删除数据库<br>DROP DATABASE [IF EXISTS] 数据库名<br># 使用数据库，切换到数据库当中<br>USE 数据库名<br></code></pre></td></tr></table></figure>\n<p>​        表结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看所有表<br>SHOW TABLES;<br># 查询表结构<br>DESC 表名<br># 查询指定表的建表语句<br>SHOW CREATE TABLE 表名;<br></code></pre></td></tr></table></figure>\n<p>​        MySQL中的数据类型</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>数据类型</th>\n<th>描述</th>\n<th>大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TINYINT</td>\n<td>微小整数，有符号或无符号（UNSIGNED）</td>\n<td>1 字节</td>\n</tr>\n<tr>\n<td>SMALLINT</td>\n<td>小整数，有符号或无符号</td>\n<td>2 字节</td>\n</tr>\n<tr>\n<td>MEDIUMINT</td>\n<td>中等整数，有符号或无符号</td>\n<td>3 字节</td>\n</tr>\n<tr>\n<td>INT 或 INTEGER</td>\n<td>整数，有符号或无符号</td>\n<td>4 字节</td>\n</tr>\n<tr>\n<td>BIGINT</td>\n<td>大整数，有符号或无符号</td>\n<td>8 字节</td>\n</tr>\n<tr>\n<td>FLOAT(M,D)</td>\n<td>单精度浮点数，M 是总位数，D 是小数位数</td>\n<td>4 字节</td>\n</tr>\n<tr>\n<td>DOUBLE(M,D)</td>\n<td>双精度浮点数，M 是总位数，D 是小数位数</td>\n<td>8 字节</td>\n</tr>\n<tr>\n<td>DECIMAL(M,D)</td>\n<td>定点数，M 是总位数，D 是小数位数</td>\n<td>取决于 M 和 D</td>\n</tr>\n<tr>\n<td>DATE</td>\n<td>日期 YYYY-MM-DD</td>\n<td>3 字节</td>\n</tr>\n<tr>\n<td>TIME</td>\n<td>时间 HH:MM:SS</td>\n<td>3 字节</td>\n</tr>\n<tr>\n<td>DATETIME</td>\n<td>日期和时间</td>\n<td>8 字节</td>\n</tr>\n<tr>\n<td>TIMESTAMP</td>\n<td>时间戳</td>\n<td>4 字节</td>\n</tr>\n<tr>\n<td>CHAR(N)</td>\n<td><strong>定长</strong>字符串，最大长度为 N</td>\n<td>最大 255 字节</td>\n</tr>\n<tr>\n<td>VARCHAR(N)</td>\n<td><strong>变长</strong>字符串，最大长度为 N</td>\n<td>最大 65,535 字节</td>\n</tr>\n<tr>\n<td>TEXT</td>\n<td>变长文本，最大长度为 65,535 字节</td>\n<td>最大 65,535 字节</td>\n</tr>\n<tr>\n<td>BLOB</td>\n<td>二进制大对象，最大长度为 65,535 字节</td>\n<td>最大 65,535 字节</td>\n</tr>\n<tr>\n<td>ENUM</td>\n<td>枚举类型</td>\n<td>1 或 2 字节，取决于成员数量</td>\n</tr>\n<tr>\n<td>SET</td>\n<td>集合类型</td>\n<td>1、2、3、4 或 8 字节，取决于成员数量</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>创建表：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">CREATE TABLE member(<br>    number INT COMMENT &#x27;编号&#x27;,<br>    id CHAR(10) COMMENT &#x27;员工工号&#x27;,<br>    name VARCHAR(10) COMMENT &#x27;员工姓名&#x27;,<br>    gender CHAR(4) COMMENT &#x27;员工性别&#x27;,<br>    age INT UNSIGNED COMMENT &#x27;年龄&#x27;,<br>    id_number CHAR(18) COMMENT &#x27;身份证号&#x27;,<br>    time DATE COMMENT &#x27;入职时间&#x27;<br>)<br></code></pre></td></tr></table></figure>\n<p><strong>表结构的修改</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 添加字段<br>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释][约束];<br><br># 修改字段和字段类型<br>ALTER TABLE 表明 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释][约束]<br><br># 删除字段<br>ALTER TABLE 表名 DROP 字段名;<br><br># 修改表名<br>ALTER TABLE 表名 RENAME TO 新表名;<br><br># 删除表<br>DROP TABLE [IF EXSITS] 表名;<br># 删除指定表并重新创建该表，清空数据<br>TRUNCATE TABLE 表名;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"DML（数据操作语言）\"><a href=\"#DML（数据操作语言）\" class=\"headerlink\" title=\"DML（数据操作语言）\"></a>DML（数据操作语言）</h4></li>\n</ul>\n<p><strong>添加数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 给指定字段添加数据<br>INSERT INTO 表名(字段名1, 字段名2, ...) VALUES (值1, 值2, ...);<br><br># 给全部字段添加数据<br>INSERT INTO 表名 VALUES(值1, 值2, ...);<br></code></pre></td></tr></table></figure>\n<p><strong>修改数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 修改数据<br>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ...[WHERE 条件];<br></code></pre></td></tr></table></figure>\n<p><strong>删除数据</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 删除数据<br>DELETE FROM 表名 [WHERE 条件];<br></code></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"DQL\"><a href=\"#DQL\" class=\"headerlink\" title=\"DQL\"></a>DQL</h4><blockquote>\n<p>数据库查询语言，用来查询数据库中的表的记录</p>\n<p>SELECT后面加上\\G可以将某一行转化为一列查看</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>语法结构</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT<br>\t字段列表<br>FROM<br>\t表名列表<br>WHERE<br>\t条件列表(条件查询)<br>GROUP BY<br>\t分组字段列表(分组查询)<br>HAVING<br>\t分组后条件列表<br>ORDER BY<br>\t排序字段列表<br>LIMIT<br>\t分页参数<br></code></pre></td></tr></table></figure>\n<p><strong>基本查询</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 字段1 [AS 别名]，字段2 [AS 别名]， FROM 表名;<br><br># 去重<br>SELECT DISTINCT 字段列表 FROM 表名;<br></code></pre></td></tr></table></figure>\n<p><strong>条件查询</strong></p>\n<p>条件运算符</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">比较运算符</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">&lt;&gt;或!=</td>\n<td style=\"text-align:center\">不等于</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">BETWEEN … AND …</td>\n<td style=\"text-align:center\">在某个范围之内</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IN(…)</td>\n<td style=\"text-align:center\">在in之后的列表中的值，多选一</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LIKE 占位符</td>\n<td style=\"text-align:center\">模糊匹配(_匹配单个字符，%匹配任意个字符)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IS NULL</td>\n<td style=\"text-align:center\">是NULL</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><strong>聚和函数</strong></p>\n<blockquote>\n<p>将一列数据作为一个整体，进行纵向计算。</p>\n</blockquote>\n<p>所有的null值不参与聚合函数的计算</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">count</td>\n<td style=\"text-align:center\">统计数量</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">max</td>\n<td style=\"text-align:center\">最大值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">min</td>\n<td style=\"text-align:center\">最小值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">avg</td>\n<td style=\"text-align:center\">平均值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">sum</td>\n<td style=\"text-align:center\">求和</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 聚合函数(字段列表) FROM 表名;<br></code></pre></td></tr></table></figure>\n<p><strong>分组查询</strong></p>\n<blockquote>\n<p>在where中不可以使用聚合函数，在having中可以使用聚合函数</p>\n<p>分组之前过滤用where，分组之后过滤条件用having</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 字段列表\tFROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];<br></code></pre></td></tr></table></figure>\n<p>执行顺序：where &gt; 聚合函数 &gt; having</p>\n<p><strong>排序查询</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1，字段2 排序方式2<br></code></pre></td></tr></table></figure>\n<p>排序方式： ASC升序（默认），DESC降序</p>\n<p><strong>分页查询</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;<br></code></pre></td></tr></table></figure>\n<p>显示从起始索引开始的记录数条的查询结果</p>\n<p><strong>DQL执行顺序</strong></p>\n<p>FROM &gt; WHERE &gt; GROUP BY &gt; SELECT &gt; ORDER BY &gt; LIMIT</p>\n<ul>\n<li><h4 id=\"DCL\"><a href=\"#DCL\" class=\"headerlink\" title=\"DCL\"></a>DCL</h4></li>\n</ul>\n<blockquote>\n<p>数据控制语句，用来管理数据库用户，控制数据库访问权限</p>\n</blockquote>\n<p><strong>DCL用户管理</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查询用户<br>USE mysql;<br>SELECT * FROM user;<br><br># 创建用户，主机名换成&quot;%&quot;表示可以在任意主机访问数据库<br>CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;密码&#x27;;<br><br># 修改用户密码<br>ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;<br><br># 删除用户<br>DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></td></tr></table></figure>\n<p><strong>权限控制</strong></p>\n<p>常用权限</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">权限</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ALL, ALL PRIVILEGES</td>\n<td style=\"text-align:center\">所有权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SELECT</td>\n<td style=\"text-align:center\">查询数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">INSERT</td>\n<td style=\"text-align:center\">插入数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UPDATE</td>\n<td style=\"text-align:center\">修改数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DELETE</td>\n<td style=\"text-align:center\">删除数据</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ALTER</td>\n<td style=\"text-align:center\">修改表</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DROP</td>\n<td style=\"text-align:center\">删除数据库/表/视图</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CREATE</td>\n<td style=\"text-align:center\">创建数据库/表</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查询权限<br>SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br># 授予权限<br>GRANT 权限列表 ON 数据库名.表名(*.*所有表) TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br><br># 撤销权限<br>REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"3、函数\"><a href=\"#3、函数\" class=\"headerlink\" title=\"3、函数\"></a>3、函数</h3><ul>\n<li><strong>字符串函数</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CONCAT(S1,S2, … Sn)</td>\n<td style=\"text-align:center\">字符串拼接，将S1-Sn拼接成一个字符串</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LOWER(str)</td>\n<td style=\"text-align:center\">将字符串str全部转为小写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">UPPER(str)</td>\n<td style=\"text-align:center\">将字符串全部转为大写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">LPAD(str, n, pad)</td>\n<td style=\"text-align:center\">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RPAD(str, n,  pad)</td>\n<td style=\"text-align:center\">右填充</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">TRIM(str)</td>\n<td style=\"text-align:center\">去掉字符串头部和尾部的空格</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">SUBSTRING(str, start, len)</td>\n<td style=\"text-align:center\">返回从字符串str从start起的len长度的字符串</td>\n</tr>\n</tbody>\n</table>\n</div>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">SELECT 函数;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><strong>数值函数</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CEIL(x)</td>\n<td style=\"text-align:center\">向上取整</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">FLOOR(x)</td>\n<td style=\"text-align:center\">向下取整</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MOD(x, y)</td>\n<td style=\"text-align:center\">返回x/y的模</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RAND()</td>\n<td style=\"text-align:center\">返回0~1内的随机数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ROUND(x, y)</td>\n<td style=\"text-align:center\">求参数x的四舍五入的值，保留y位小数</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><strong>日期函数</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">CURDATE()</td>\n<td style=\"text-align:center\">返回当前日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CURTIME()</td>\n<td style=\"text-align:center\">返回当前时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">NOW()</td>\n<td style=\"text-align:center\">返回当前日期和时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">YEAR(date)</td>\n<td style=\"text-align:center\">获取指定date的年份</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">MONTH(date)</td>\n<td style=\"text-align:center\">获取指定date的月份</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DAY(date)</td>\n<td style=\"text-align:center\">获取指定date的日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DATE_ADD(date, INTERVAL expr type)</td>\n<td style=\"text-align:center\">返回上一个日期加上时间间隔expr以后的时间值，type(year,month,day)指定年月天</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">DATEDIFF(date1, date2)</td>\n<td style=\"text-align:center\">返回起始时间date1和结束时间date2之间的天数，第一个时间减去第二个时间</td>\n</tr>\n</tbody>\n</table>\n</div>\n<ul>\n<li><strong>流程函数</strong></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">函数</th>\n<th style=\"text-align:center\">功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">IF(value, t. f)</td>\n<td style=\"text-align:center\">如果value为true，返回t，否则返回f</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">IFNULL(value1, value2)</td>\n<td style=\"text-align:center\">如果value1不为空，返回value1，否则返回value2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CASE WHEN [val] THEN [res1] … ELSE [ default ] END</td>\n<td style=\"text-align:center\">如果val1为true，返回res1，…否则返回default默认值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">CASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END</td>\n<td style=\"text-align:center\">如果expr的值等于val1，返回res1，…否则返回default默认值</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"4、约束\"><a href=\"#4、约束\" class=\"headerlink\" title=\"4、约束\"></a>4、约束</h3><p>作用于表中字段上的规则，用于限制存储在表中的数据</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">约束</th>\n<th style=\"text-align:center\">描述</th>\n<th style=\"text-align:center\">关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">非空约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">唯一约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主键约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">默认约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">检查约束</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">外键约束</td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"5、多表查询\"><a href=\"#5、多表查询\" class=\"headerlink\" title=\"5、多表查询\"></a>5、多表查询</h3><ul>\n<li><p><strong>多表关系</strong></p>\n<p>一对多：在多的一方建立外键，指向一的一方的主键</p>\n</li>\n</ul>\n<p>​        多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方的主键</p>\n<p>​        一对一：用于做单表拆分，基础字段放在一张表，详情字段放在另一张表。在任意一方加入外键，关联另一方的主键，并设置外键为唯一（UNIQUE）</p>\n<ul>\n<li><p><strong>多表查询</strong></p>\n<ul>\n<li><p>内连接</p>\n<blockquote>\n<p>相当于查询A、B交集部分数据</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 隐式内连接<br>SELECT 字段列表 FROM 表1，表2 WHERE 条件...;<br><br># 显示内连接<br>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>外连接</p>\n<blockquote>\n<p>左外连接：查询左表所有数据，以及两张表交集部分数据，将左表的数据和右表的部分数据连接起来</p>\n<p>右外连接：查询右表所有数据，以及两张表交集部分数据</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 左外连接，表1所有数据以及和表2交集部分的数据<br>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;<br><br># 右外连接，表2所有数据以及和表1交集部分的数据<br>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>自连接</p>\n<blockquote>\n<p>自连接：当前表与自身的连接查询，自连接必须使用表别名</p>\n</blockquote>\n</li>\n<li><p>联合查询-union，union all</p>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 把多次查询的结果合并起来，形成一个新的查询结果集<br># ALL去掉以后会对结果进行去重<br>SELECT 字段列表 表A<br>UNION [ALL]<br>SELECT 字段列表 表B;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>子查询</strong></p>\n<ul>\n<li><p>标量子查询，子查询返回一个标量</p>\n</li>\n<li><p>列子查询，子查询返回一列</p>\n<p>| 操作符 |                 描述                 |<br>| :——: | :—————————————————: |<br>|   IN   |     在指定的集合范围之内，多选一     |<br>| NOT IN |          不在指定的范围之内          |<br>|  ANY   | 子查询返回列表中，有任意一个满足即可 |<br>|  SOME  |              与ANY等同               |<br>|  ALL   |   子查询返回列表的所有值都必须满足   |</p>\n</li>\n<li><p>行子查询，子查询返回的结果是一行</p>\n<p>此时column1可以使用(column1， column2)聚合成多个参数</p>\n<p>操作符：=、&lt;&gt;、IN、NOT IN</p>\n</li>\n<li><p>表子查询，子查询的返回结果是一个表，可以和行子查询加上列子查询的操作符使用，表可以放到from后面</p>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 对于子查询，可以将问题拆解成多个不同的查询步骤<br>SELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);<br></code></pre></td></tr></table></figure>\n<h3 id=\"6、事务\"><a href=\"#6、事务\" class=\"headerlink\" title=\"6、事务\"></a>6、事务</h3><blockquote>\n<p>一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么<strong>同时成功，要么同时失败</strong></p>\n<p>默认Mysql的事务是自动提交的，当执行一条DML语句，Mysql会立即隐式的提交事务</p>\n</blockquote>\n<ul>\n<li><strong>事务操作</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看/设置事务提交方式<br>SELECT @@autocommit;<br># 事务设置为手动提交<br>SET @@autocommit = 0;<br><br># 提交事务<br>COMMIT;<br><br># 回滚事务<br>ROLLBACK;<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 不修改事务的提交方式操作事务<br># 开启事务<br>START TRANSACTION 或 BEGIN;<br><br># 提交事务<br>COMMIT;<br><br># 回滚事务<br>ROLLBACK;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p><strong>事务四大特性</strong></p>\n<ul>\n<li>原子性(Atomicity)：事务时不可分割的最小操作单元，要么全部成功，要么全部失败</li>\n<li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态</li>\n<li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li>\n<li>持久性(Durability)：事务一旦提交或者回滚，它对数据库中的数据改变就是永久的</li>\n</ul>\n</li>\n<li><p><strong>并发事务问题</strong></p>\n<p>|    问题    |                             描述                             |<br>| :————: | :—————————————————————————————: |<br>|    脏读    |            一个事务读到另一个事务还没有提交的数据            |<br>| 不可重复读 | 一个事务先后读取同一条记录，但两次读取的数据不同，称为不可重复读 |<br>|    幻读    | 一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这一行数据已经存在 |</p>\n</li>\n<li><p><strong>事务隔离级别</strong></p>\n<blockquote>\n<p>读未提交、读已提交、可重复读、串行化</p>\n<p>√表示会出现这个问题，×表示不会出现这个问题</p>\n</blockquote>\n<p>|     隔离级别     | 脏读 | 不可重复读 | 幻读 |<br>| :———————: | :—: | :————: | :—: |<br>| Read uncommitted |  √   |     √      |  √   |<br>|  Read committed  |  ×   |     √      |  √   |<br>| Repeatable Read  |  ×   |     ×      |  √   |<br>|   Serializable   |  ×   |     ×      |  ×   |</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看事务的隔离级别<br>SELECT @@TRANSACTION_ISOLATION;<br><br># 设置事务隔离级别<br>SET [SESSION(只对当前窗口有效)|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;<br></code></pre></td></tr></table></figure>\n<p>事务的隔离界别越高，数据越安全，但是性能越低</p>\n</li>\n</ul>\n<h2 id=\"数据库进阶\"><a href=\"#数据库进阶\" class=\"headerlink\" title=\"数据库进阶\"></a>数据库进阶</h2><h3 id=\"1、存储引擎\"><a href=\"#1、存储引擎\" class=\"headerlink\" title=\"1、存储引擎\"></a>1、存储引擎</h3><ul>\n<li><p>Mysql体系结构 </p>\n<p>连接层：完成一些类似于连接处理、授权认证及相关的安全方案</p>\n<p>服务层：主要完成大多数的核心服务功能</p>\n<p>引擎层：负责mysql中数据的存储和提取，服务器通过API和存储引擎进行通信</p>\n<p>存储层：将数据存储在文件系统之上，并完成与存储引擎的交互</p>\n\n</li>\n<li><p>存储引擎</p>\n<blockquote>\n<p>存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎时基于表的，而不是基于库的。一个数据库的不同的表可以选择不同的存储引擎</p>\n<p>Mysql默认InnoDB</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查询支持的存储引擎<br>show engines;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>InnoDB</p>\n<ul>\n<li>DML操作遵循ACID模型，支持事务</li>\n<li>行级锁，提高并发访问性能</li>\n<li>支持外键，保证事务的完整性和正确性</li>\n</ul>\n<p>文件：每个表对应一个.ibd文件，代表表空间文件，可以通过命令<code>idb2sdi 文件名</code>查看表结构json文件格式</p>\n\n</li>\n<li><p>MyISAM</p>\n<ul>\n<li>不支持事务，不支持外键</li>\n<li>支持表锁、不支持行锁</li>\n<li>访问速度快</li>\n</ul>\n<p>文件.MYD（数据），.MYI（索引），.sdi（表结构）</p>\n</li>\n<li><p>Memory</p>\n<ul>\n<li>表数据存储在内存当中，收到硬件问题或断电影响只能作为临时表或者缓存使用</li>\n<li>内存存放</li>\n<li>hash索引（默认）</li>\n</ul>\n</li>\n</ul>\n\n<ul>\n<li><p>存储引擎选择</p>\n<p>InnoDB：如果对事务的完整性有比较高的要求，在并发情况下要求事务的一致性，数据操作除了插入和查询意外，还包括很多的更新、删除操作，InnoDB引擎比较合适</p>\n<p>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性和并发现要求不是很高。<strong>这个场景被Nosql数据库MongoDB替代了</strong></p>\n<p>MEMORY：将所有数据保存在内存当中，访问速度快，通常用于临时表以及缓存。MEMORY对表的大小有限制，太大的表无法缓存在内存中。<strong>这个场景被Redis替代了</strong></p>\n</li>\n</ul>\n<h3 id=\"2、索引\"><a href=\"#2、索引\" class=\"headerlink\" title=\"2、索引\"></a>2、索引</h3><ul>\n<li><p><strong>索引概述</strong></p>\n<ul>\n<li>索引的结构</li>\n</ul>\n</li>\n<li><h4 id=\"索引分类\"><a href=\"#索引分类\" class=\"headerlink\" title=\"索引分类\"></a><strong>索引分类</strong></h4></li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">分类</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">特点</th>\n<th style=\"text-align:center\">关键字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">主键索引</td>\n<td style=\"text-align:center\">针对于表中主键创建的索引</td>\n<td style=\"text-align:center\">默认自动创建，只能有一个</td>\n<td style=\"text-align:center\">PRIMARY</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">唯一索引</td>\n<td style=\"text-align:center\">避免同一个表中某数据列中的值重复</td>\n<td style=\"text-align:center\">可以有多个</td>\n<td style=\"text-align:center\">UNIQUE</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">常规索引</td>\n<td style=\"text-align:center\">快速定位特定数据</td>\n<td style=\"text-align:center\">可以有多个</td>\n<td style=\"text-align:center\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">全文索引</td>\n<td style=\"text-align:center\">全文索引查找的是文本中通过的关键词</td>\n<td style=\"text-align:center\">可以有多个</td>\n<td style=\"text-align:center\">FULLTEXT</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>按照索引的存储形式分类</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">分类</th>\n<th style=\"text-align:center\">含义</th>\n<th style=\"text-align:center\">特点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">聚集索引</td>\n<td style=\"text-align:center\">将数据存储与索引放到了一块</td>\n<td style=\"text-align:center\">必须有，而且只有一个</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">二级索引</td>\n<td style=\"text-align:center\">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td>\n<td style=\"text-align:center\">可以存在多个</td>\n</tr>\n</tbody>\n</table>\n</div>\n\n<ul>\n<li><h4 id=\"索引语法\"><a href=\"#索引语法\" class=\"headerlink\" title=\"索引语法\"></a><strong>索引语法</strong></h4></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 创建索引<br># 一个索引可以关联多行，如果关联多行称为联合索引<br>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name, )<br><br># 查看索引<br>SHOW INDEX FROM table_name;<br><br># 删除索引<br>DROP INDEX index_name ON table_name;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"SQL性能分析\"><a href=\"#SQL性能分析\" class=\"headerlink\" title=\"SQL性能分析\"></a><strong>SQL性能分析</strong></h4><blockquote>\n<p>使用于select的优化</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># SQL执行频率，查看当前数据库语句的访问频率<br>SHOW [session|global] STATUS<br># Com七个下划线，模糊匹配<br>SHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;<br></code></pre></td></tr></table></figure>\n<p><strong>SQL语句的频率</strong></p>\n\n<p><strong>慢查询日志</strong></p>\n<blockquote>\n<p>慢查询日志记录了所有执行时间超过指定参数(long_query_time，单位：秒，默认10)的所有SQL语句的日志</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看是否开启，日志文件默认在/var/lib/mysql里面<br>SHOW VARIABLES LIKE &#x27;slow_query_log&#x27;;<br><br># 修改/etc/my.cnf中配置开启，配置时间<br>slow_query_log=1   <br>long_query_time=2<br></code></pre></td></tr></table></figure>\n<p><strong>profile详情</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看是否支持prifile<br>SELECT @@have_profiling;<br><br># 设置为开<br>SET profiling=1;<br><br># 查看profile<br>SHOW PROFILES;<br></code></pre></td></tr></table></figure>\n<p>执行完SQL语句以后，通过以下指令查看执行耗时情况</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 查看每一条SQL耗时基本情况<br>SHOW PROFILES;<br><br># 查看指定query_id的SQL语句各个阶段的耗时情况<br>SHOW PROFILE FOR QUERY query_id;<br><br># 查看指定SQL语句的CPU使用情况<br>SHOW PROFILE CPU FOR QUERY query_id;<br></code></pre></td></tr></table></figure>\n<p><strong>explain执行计划</strong></p>\n<blockquote>\n<p>EXPLAIN或者DESC命令获取Mysql如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\">EXPLAIN SELECT SQL语句;<br></code></pre></td></tr></table></figure>\n\n<p>表头的含义：</p>\n\n\n<figure class=\"highlight txt\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs txt\">type<br>const\t以主键或以唯一的列作为索引扫描<br>ref\t\t非唯一的值作为查询索引<br>index\t用了索引，但是会对整个索引进行遍历<br>all\t\t全表扫描<br></code></pre></td></tr></table></figure>\n<ul>\n<li><h4 id=\"索引使用\"><a href=\"#索引使用\" class=\"headerlink\" title=\"索引使用\"></a><strong>索引使用</strong></h4></li>\n</ul>\n<p><strong>联合索引</strong></p>\n<p>使用要遵循<strong>最左前缀法则</strong>：查询<strong>从索引的最左列开始</strong>，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p>\n<p><strong>范围查询</strong>：联合索引中出现范围查询（&gt;,&lt;)，范围查询右侧的列索引失效。但是使用大于等于和小于等于索引并不会失效。</p>\n<p>例子</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># student有联合索引(id,name,age)<br># 1、索引都可以使用<br>select * from student where id = 1 and name = &quot;Lili&quot; and age = 20;<br><br># 2、索引name，age失效<br>select * from student where id = 1 and age = 20;<br><br># 范围查询<br># name和age索引均失效<br>select * from student where id &gt; 1 and name = &quot;Lili&quot; and age = 20;<br></code></pre></td></tr></table></figure>\n<p><strong>索引失效</strong></p>\n<p>索引列操作：不要在索引上进行列操作，否则索引会失效</p>\n<p>字符串类型：不加单引号索引会失效</p>\n<p>模糊查询：<strong>头部进行模糊匹配(%%某某)</strong>，索引会失效，尾部进行模糊匹配（某某%%），索引不会失效。</p>\n<p>or连接的条件：如果or前面的条件列有索引，后面的条件没有索引，所涉及的索引都不会引用到，只有两侧都有索引的时候，才有效</p>\n<p>数据分布影响：如果索引比全表扫描更慢，则不使用索引，查询的数据大于一半，走全表不走索引。</p>\n<p><strong>SQL提示</strong></p>\n<blockquote>\n<p>在sql语句中加入一些认为的提示来达到优化操作的目的</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># use index指定使用哪个索引<br>explain select * from table use index(idxname) ...<br><br># ignore index<br># force index 同上<br></code></pre></td></tr></table></figure>\n<p><strong>覆盖索引</strong></p>\n<p>尽量使用覆盖索引：查询使用了索引，并且需要返回的列，在该索引中已经能够全部找到，减少使用select *</p>\n<p>using index condition：查找使用了索引，但是需要回表查询数据</p>\n<p>using where, using index：查询使用了索引，但是不需要回表</p>\n\n<p>前两条不需要回表，后一条需要回表</p>\n<p><strong>前缀索引</strong></p>\n<blockquote>\n<p>将字符串的前缀提取出来，创建索引，可以节约索引空间</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># n表示取column_name列的前n个数据<br>CREATE INDEX idx_XXX ON table_name(column_name(n));<br><br># 计算前缀长度的选择性，越接近1越好<br>SELECT COUNT(DISTINCT substring(email, 1, 5)) / COUNT(*) FROM table_name;<br></code></pre></td></tr></table></figure>\n<p><strong>单列索引和联合索引选择</strong></p>\n<p>如果涉及到多个查询条件，推荐使用联合索引，联合索引会更少的回表查询</p>\n<h4 id=\"Quetion\"><a href=\"#Quetion\" class=\"headerlink\" title=\"Quetion\"></a>Quetion</h4>\n<p>建立id主键，username，password联合索引</p>\n<ul>\n<li><h4 id=\"索引设计原则\"><a href=\"#索引设计原则\" class=\"headerlink\" title=\"索引设计原则\"></a><strong>索引设计原则</strong></h4></li>\n</ul>\n\n<h3 id=\"3、SQL优化\"><a href=\"#3、SQL优化\" class=\"headerlink\" title=\"3、SQL优化\"></a>3、SQL优化</h3><ul>\n<li><h4 id=\"插入数据insert优化\"><a href=\"#插入数据insert优化\" class=\"headerlink\" title=\"插入数据insert优化\"></a><strong>插入数据</strong>insert优化</h4><p>批量插入而不是单条插入：批量插入只需要建立一次连接即可</p>\n<p>建议手动提交事务：不需要每一次插入时自动开启和关闭事务，而是将所有insert执行结束以后统一关闭</p>\n<p><strong>建议主键顺序插入</strong></p>\n<p>大批量插入数据：使用Mysql数据库提供的load指令进行插入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mysql\"># 如何使用load<br># 1、连接服务器时加上参数--local-infile<br>mysql --local-infile -u root -p<br><br># 2、设置全局参数local_infile为1<br>set global local_infile = 1;<br><br># 3、执行load指令将数据加载表结构中<br>load data local infile &#x27;文件名&#x27; into table &#x27;表名&#x27; fields teminated by &#x27;分割符&#x27; lines terminated by &#x27;行分隔符\\n&#x27;;<br></code></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"主键优化\"><a href=\"#主键优化\" class=\"headerlink\" title=\"主键优化\"></a><strong>主键优化</strong></h4></li>\n</ul>\n<blockquote>\n<p>InnoDB中表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表。</p>\n</blockquote>\n<p>页大小为16kb，每个页至少包含两行数据</p>\n<p>主键乱序插入可能会出现页分裂现象，执行删除操作会出现页合并现象</p>\n<p>主键设计原则：</p>\n<p>​    满足业务需求的情况下，尽量降低主键的长度</p>\n<p>​    插入时尽量按照主键顺序插入，选择自增主键</p>\n<p>​    尽量不要使用无序的自然主键</p>\n<p>​    业务操作，避免对主键的修改</p>\n<ul>\n<li><strong>order by优化</strong></li>\n</ul>\n<p>排序方式</p>\n<p>Using filesort：先找到数据再进行排序</p>\n<p>Using index：通过有序索引直接返回，不需要额外排序</p>\n<p>默认会对索引进行升序排序</p>\n<ul>\n<li><strong>limit优化</strong></li>\n</ul>\n<p>对于数据量大的，优化思路为使用覆盖索引+子查询</p>\n<ul>\n<li><p>count</p>\n<p>count(*)优于count(1)&gt;count(主键)&gt;count(字段)</p>\n</li>\n<li><h4 id=\"update优化\"><a href=\"#update优化\" class=\"headerlink\" title=\"update优化\"></a><strong>update优化</strong></h4></li>\n</ul>\n<p>对需要更新的字段尽可能建立索引，这样如果处于多个事务情况下，只会使用行锁，如果没有建立索引，行锁会升级为表锁，无法进行并行</p>\n<h3 id=\"4、视图-存储过程-触发器\"><a href=\"#4、视图-存储过程-触发器\" class=\"headerlink\" title=\"4、视图/存储过程/触发器\"></a>4、视图/存储过程/触发器</h3><ul>\n<li><h4 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h4></li>\n</ul>\n<blockquote>\n<p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p>\n</blockquote>\n<ul>\n<li><h4 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h4></li>\n<li><h4 id=\"存储函数\"><a href=\"#存储函数\" class=\"headerlink\" title=\"存储函数\"></a>存储函数</h4></li>\n<li><h4 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h4></li>\n</ul>\n<h3 id=\"5、锁\"><a href=\"#5、锁\" class=\"headerlink\" title=\"5、锁\"></a>5、锁</h3><h3 id=\"6、InnoDB核心\"><a href=\"#6、InnoDB核心\" class=\"headerlink\" title=\"6、InnoDB核心\"></a>6、InnoDB核心</h3><h3 id=\"7、MySQL管理\"><a href=\"#7、MySQL管理\" class=\"headerlink\" title=\"7、MySQL管理\"></a>7、MySQL管理</h3><h2 id=\"数据库运维\"><a href=\"#数据库运维\" class=\"headerlink\" title=\"数据库运维\"></a>数据库运维</h2><h3 id=\"1、日志\"><a href=\"#1、日志\" class=\"headerlink\" title=\"1、日志\"></a>1、日志</h3><h3 id=\"2、主从复制\"><a href=\"#2、主从复制\" class=\"headerlink\" title=\"2、主从复制\"></a>2、主从复制</h3><h3 id=\"3、分库分表\"><a href=\"#3、分库分表\" class=\"headerlink\" title=\"3、分库分表\"></a>3、分库分表</h3><h3 id=\"4、读写分离\"><a href=\"#4、读写分离\" class=\"headerlink\" title=\"4、读写分离\"></a>4、读写分离</h3><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\" \"></a> </h3>"},{"title":"the_go_programming_language","date":"2024-02-12T05:29:11.000Z","cover":"2024/02/12/the-go-programming-language/top_img.png","top_img":"2024/02/12/the-go-programming-language/top_img.png","_content":"\n### GO语言基础要点\n\n四种变量声明方式\n\n* 第一种是短变量声明，只能在函数内部使用，不能用于包变量\n* 第二种依赖于字符串的默认初始化零值机制\n* 第三种用得较少，除非用于声明多个变量\n* 第四种当变量类型与初值类型相同时，类型冗余，但是类型不同时，变量类型就必须了\n\n```go\ns := \"\"\nvar s string\nvar s = \"\"\nvar s string = \"\"\n```\n\n","source":"_drafts/the-go-programming-language.md","raw":"---\ntitle: the_go_programming_language\ndate: 2024-02-12 13:29:11\ntags: [golang Go语言圣经]\ncategories: 学习笔记\ncover: top_img.png\ntop_img: top_img.png\n---\n\n### GO语言基础要点\n\n四种变量声明方式\n\n* 第一种是短变量声明，只能在函数内部使用，不能用于包变量\n* 第二种依赖于字符串的默认初始化零值机制\n* 第三种用得较少，除非用于声明多个变量\n* 第四种当变量类型与初值类型相同时，类型冗余，但是类型不同时，变量类型就必须了\n\n```go\ns := \"\"\nvar s string\nvar s = \"\"\nvar s string = \"\"\n```\n\n","slug":"the-go-programming-language","published":0,"updated":"2024-02-18T01:22:49.947Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xo0005g4c2fmfeat34","content":"<h3 id=\"GO语言基础要点\"><a href=\"#GO语言基础要点\" class=\"headerlink\" title=\"GO语言基础要点\"></a>GO语言基础要点</h3><p>四种变量声明方式</p>\n<ul>\n<li>第一种是短变量声明，只能在函数内部使用，不能用于包变量</li>\n<li>第二种依赖于字符串的默认初始化零值机制</li>\n<li>第三种用得较少，除非用于声明多个变量</li>\n<li>第四种当变量类型与初值类型相同时，类型冗余，但是类型不同时，变量类型就必须了</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">s := <span class=\"hljs-string\">&quot;&quot;</span><br><span class=\"hljs-keyword\">var</span> s <span class=\"hljs-type\">string</span><br><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;&quot;</span><br><span class=\"hljs-keyword\">var</span> s <span class=\"hljs-type\">string</span> = <span class=\"hljs-string\">&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n","cover_type":"img","excerpt":"","more":"<h3 id=\"GO语言基础要点\"><a href=\"#GO语言基础要点\" class=\"headerlink\" title=\"GO语言基础要点\"></a>GO语言基础要点</h3><p>四种变量声明方式</p>\n<ul>\n<li>第一种是短变量声明，只能在函数内部使用，不能用于包变量</li>\n<li>第二种依赖于字符串的默认初始化零值机制</li>\n<li>第三种用得较少，除非用于声明多个变量</li>\n<li>第四种当变量类型与初值类型相同时，类型冗余，但是类型不同时，变量类型就必须了</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs go\">s := <span class=\"hljs-string\">&quot;&quot;</span><br><span class=\"hljs-keyword\">var</span> s <span class=\"hljs-type\">string</span><br><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-string\">&quot;&quot;</span><br><span class=\"hljs-keyword\">var</span> s <span class=\"hljs-type\">string</span> = <span class=\"hljs-string\">&quot;&quot;</span><br></code></pre></td></tr></table></figure>\n"},{"title":"C++使用zlib库来压缩文件","date":"2024-01-26T02:34:44.000Z","cover":"/img/default_cover02.jpg","top_img":null,"_content":"\n## C++使用zlib库来压缩文件\n\nzlib压缩库提供内存压缩和解压缩功能，包括对未压缩的完整性检查数据，提供支持的压缩方法为：deflation，默认使用压缩数据格式为zlib格式。\n\nzlib库支持读取和写入gzip(.gz)格式的文件，zlib格式旨在紧凑且快速，可用于内存和通信渠道。gzip格式设计用于文件系统上的单文件压缩，比zlib具有更大的头部以维护目录信息，并且使用与zlib不同且更慢的检查方法。\n\n该库不安装任何信号处理程序。解码器检查压缩数据的一致性，因此即使在输入损坏的情况下，库也不应崩溃。\n\n### 数据流结构\n\n```\ntypedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);\ntypedef void   (*free_func)(voidpf opaque, voidpf address);\n```\n\n* `typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);`这个函数指针通常用于内存分配，允许用户自定义的内存分配函数\n* `typedef void   (*free_func)(voidpf opaque, voidpf address);`这个函数指针通常用于内存释放，允许用户自定义的内存释放函数\n\n### 基本功能\n\n```\nZEXTERN int ZEXPORT deflateInit(z_streamp strm, int level);\n```\n\n* `level`表示压缩级别，要么为`Z_DEFAULT_COMPRESSION`，要么介于0-9之间，1表示最佳速度，9表示最佳压缩，0表示没有压缩，`Z_DEFAULT_COMPRESSION`默认在6级别。\n* `deflateInit` 返回 `Z_OK` 如果成功，则返回 `Z_MEM_ERROR` 如果没有 足够的内存，`Z_STREAM_ERROR` `level` 不是有效的压缩级别，`Z_VERSION_ERROR` *zlib* 库版本 （`zlib_version`） 不兼容 替换为调用方 （`ZLIB_VERSION`） 假定的版本。如果没有错误消息，`则 msg` 设置为 null。`deflateInit` 不 执行任何压缩：这将由 `deflate（）` 完成。\n\n```\nZEXTERN int ZEXPORT deflate(z_streamp strm, int flush);\n```\n\n","source":"_posts/C-使用zlib库来压缩文件.md","raw":"---\ntitle: C++使用zlib库来压缩文件\ndate: 2024-01-26 10:34:44\ntags: [C++, zlib]\ncategories: 技术研究\ncover: /img/default_cover02.jpg\ntop_img:\n---\n\n## C++使用zlib库来压缩文件\n\nzlib压缩库提供内存压缩和解压缩功能，包括对未压缩的完整性检查数据，提供支持的压缩方法为：deflation，默认使用压缩数据格式为zlib格式。\n\nzlib库支持读取和写入gzip(.gz)格式的文件，zlib格式旨在紧凑且快速，可用于内存和通信渠道。gzip格式设计用于文件系统上的单文件压缩，比zlib具有更大的头部以维护目录信息，并且使用与zlib不同且更慢的检查方法。\n\n该库不安装任何信号处理程序。解码器检查压缩数据的一致性，因此即使在输入损坏的情况下，库也不应崩溃。\n\n### 数据流结构\n\n```\ntypedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);\ntypedef void   (*free_func)(voidpf opaque, voidpf address);\n```\n\n* `typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);`这个函数指针通常用于内存分配，允许用户自定义的内存分配函数\n* `typedef void   (*free_func)(voidpf opaque, voidpf address);`这个函数指针通常用于内存释放，允许用户自定义的内存释放函数\n\n### 基本功能\n\n```\nZEXTERN int ZEXPORT deflateInit(z_streamp strm, int level);\n```\n\n* `level`表示压缩级别，要么为`Z_DEFAULT_COMPRESSION`，要么介于0-9之间，1表示最佳速度，9表示最佳压缩，0表示没有压缩，`Z_DEFAULT_COMPRESSION`默认在6级别。\n* `deflateInit` 返回 `Z_OK` 如果成功，则返回 `Z_MEM_ERROR` 如果没有 足够的内存，`Z_STREAM_ERROR` `level` 不是有效的压缩级别，`Z_VERSION_ERROR` *zlib* 库版本 （`zlib_version`） 不兼容 替换为调用方 （`ZLIB_VERSION`） 假定的版本。如果没有错误消息，`则 msg` 设置为 null。`deflateInit` 不 执行任何压缩：这将由 `deflate（）` 完成。\n\n```\nZEXTERN int ZEXPORT deflate(z_streamp strm, int flush);\n```\n\n","slug":"C-使用zlib库来压缩文件","published":1,"updated":"2024-02-20T06:56:26.644Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xp0006g4c25wn1hv4s","content":"<h2 id=\"C-使用zlib库来压缩文件\"><a href=\"#C-使用zlib库来压缩文件\" class=\"headerlink\" title=\"C++使用zlib库来压缩文件\"></a>C++使用zlib库来压缩文件</h2><p>zlib压缩库提供内存压缩和解压缩功能，包括对未压缩的完整性检查数据，提供支持的压缩方法为：deflation，默认使用压缩数据格式为zlib格式。</p>\n<p>zlib库支持读取和写入gzip(.gz)格式的文件，zlib格式旨在紧凑且快速，可用于内存和通信渠道。gzip格式设计用于文件系统上的单文件压缩，比zlib具有更大的头部以维护目录信息，并且使用与zlib不同且更慢的检查方法。</p>\n<p>该库不安装任何信号处理程序。解码器检查压缩数据的一致性，因此即使在输入损坏的情况下，库也不应崩溃。</p>\n<h3 id=\"数据流结构\"><a href=\"#数据流结构\" class=\"headerlink\" title=\"数据流结构\"></a>数据流结构</h3><figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-built_in\">void</span>pf (*alloc_func)(<span class=\"hljs-built_in\">void</span>pf opaque, uInt items, uInt size);<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-built_in\">void</span>   (*free_func)(<span class=\"hljs-built_in\">void</span>pf opaque, <span class=\"hljs-built_in\">void</span>pf address);<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);</code>这个函数指针通常用于内存分配，允许用户自定义的内存分配函数</li>\n<li><code>typedef void   (*free_func)(voidpf opaque, voidpf address);</code>这个函数指针通常用于内存释放，允许用户自定义的内存释放函数</li>\n</ul>\n<h3 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\">ZEXTERN <span class=\"hljs-type\">int</span> ZEXPORT <span class=\"hljs-title\">deflateInit</span><span class=\"hljs-params\">(z_streamp strm, <span class=\"hljs-type\">int</span> level)</span></span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>level</code>表示压缩级别，要么为<code>Z_DEFAULT_COMPRESSION</code>，要么介于0-9之间，1表示最佳速度，9表示最佳压缩，0表示没有压缩，<code>Z_DEFAULT_COMPRESSION</code>默认在6级别。</li>\n<li><code>deflateInit</code> 返回 <code>Z_OK</code> 如果成功，则返回 <code>Z_MEM_ERROR</code> 如果没有 足够的内存，<code>Z_STREAM_ERROR</code> <code>level</code> 不是有效的压缩级别，<code>Z_VERSION_ERROR</code> <em>zlib</em> 库版本 （<code>zlib_version</code>） 不兼容 替换为调用方 （<code>ZLIB_VERSION</code>） 假定的版本。如果没有错误消息，<code>则 msg</code> 设置为 null。<code>deflateInit</code> 不 执行任何压缩：这将由 <code>deflate（）</code> 完成。</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\">ZEXTERN <span class=\"hljs-type\">int</span> ZEXPORT <span class=\"hljs-title\">deflate</span><span class=\"hljs-params\">(z_streamp strm, <span class=\"hljs-type\">int</span> flush)</span></span>;<br></code></pre></td></tr></table></figure>\n","cover_type":"img","excerpt":"","more":"<h2 id=\"C-使用zlib库来压缩文件\"><a href=\"#C-使用zlib库来压缩文件\" class=\"headerlink\" title=\"C++使用zlib库来压缩文件\"></a>C++使用zlib库来压缩文件</h2><p>zlib压缩库提供内存压缩和解压缩功能，包括对未压缩的完整性检查数据，提供支持的压缩方法为：deflation，默认使用压缩数据格式为zlib格式。</p>\n<p>zlib库支持读取和写入gzip(.gz)格式的文件，zlib格式旨在紧凑且快速，可用于内存和通信渠道。gzip格式设计用于文件系统上的单文件压缩，比zlib具有更大的头部以维护目录信息，并且使用与zlib不同且更慢的检查方法。</p>\n<p>该库不安装任何信号处理程序。解码器检查压缩数据的一致性，因此即使在输入损坏的情况下，库也不应崩溃。</p>\n<h3 id=\"数据流结构\"><a href=\"#数据流结构\" class=\"headerlink\" title=\"数据流结构\"></a>数据流结构</h3><figure class=\"highlight angelscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs angelscript\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-built_in\">void</span>pf (*alloc_func)(<span class=\"hljs-built_in\">void</span>pf opaque, uInt items, uInt size);<br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-built_in\">void</span>   (*free_func)(<span class=\"hljs-built_in\">void</span>pf opaque, <span class=\"hljs-built_in\">void</span>pf address);<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>typedef voidpf (*alloc_func)(voidpf opaque, uInt items, uInt size);</code>这个函数指针通常用于内存分配，允许用户自定义的内存分配函数</li>\n<li><code>typedef void   (*free_func)(voidpf opaque, voidpf address);</code>这个函数指针通常用于内存释放，允许用户自定义的内存释放函数</li>\n</ul>\n<h3 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h3><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\">ZEXTERN <span class=\"hljs-type\">int</span> ZEXPORT <span class=\"hljs-title\">deflateInit</span><span class=\"hljs-params\">(z_streamp strm, <span class=\"hljs-type\">int</span> level)</span></span>;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><code>level</code>表示压缩级别，要么为<code>Z_DEFAULT_COMPRESSION</code>，要么介于0-9之间，1表示最佳速度，9表示最佳压缩，0表示没有压缩，<code>Z_DEFAULT_COMPRESSION</code>默认在6级别。</li>\n<li><code>deflateInit</code> 返回 <code>Z_OK</code> 如果成功，则返回 <code>Z_MEM_ERROR</code> 如果没有 足够的内存，<code>Z_STREAM_ERROR</code> <code>level</code> 不是有效的压缩级别，<code>Z_VERSION_ERROR</code> <em>zlib</em> 库版本 （<code>zlib_version</code>） 不兼容 替换为调用方 （<code>ZLIB_VERSION</code>） 假定的版本。如果没有错误消息，<code>则 msg</code> 设置为 null。<code>deflateInit</code> 不 执行任何压缩：这将由 <code>deflate（）</code> 完成。</li>\n</ul>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\"><span class=\"hljs-function\">ZEXTERN <span class=\"hljs-type\">int</span> ZEXPORT <span class=\"hljs-title\">deflate</span><span class=\"hljs-params\">(z_streamp strm, <span class=\"hljs-type\">int</span> flush)</span></span>;<br></code></pre></td></tr></table></figure>\n"},{"title":"GANES101现代计算机图形学入门-01","date":"2023-12-15T06:40:01.000Z","cover":"2023/12/15/GANES101现代计算机图形学入门-01/games101.png","top_img":"2023/12/15/GANES101现代计算机图形学入门-01/games101.png","_content":"\n\n## 计算机图形学01\n\n> 应用场景：电影，动画，可视化，家具，模拟，虚拟现实（VR），GUI（图形用户接口），字体\n\n* 好的画面：足够亮（全局光照）\n\n```\n1、光栅化\tResterization\n2、曲线曲面（几何）\tCurves and Meshes\n3、光线追踪\tRay\tTracing\n4、动画/模拟\tAnimation/Simulation\n```\n\n### 计算机图形学 VS 计算机视觉\n\n![image-20231104113151777](GANES101现代计算机图形学入门-01/image-20231104113151777-17084112899531.png)\n\n* MODEL，计算机画（图形学）\n\n  正向箭头：将三维空间的图形在二维中展示出来，特指图像渲染\n\n  自我箭头：MODEL的自我渲染，与图像无关\n\n* IMAGE，计算机看（计算机视觉）\n\n  反向箭头：从图形中推导和识别出图像的特征\n\n  自我箭头：依赖深度学习对图像进行处理\n\n作业相关\n\n```\n1、作业链接：http://games-cn.org/forums/topic/allhw/\n2、作业使用的系统：smartchair\n3、Use IDE：集成开发环境\n```\n\n\n\n### 线性代数——A Swift and Brutal Introduction to Linear Algebra\n\n> 数学：线性代数，微积分，统计，物理：光学，力学，信号处理，数值分析\n\n#### 向量Vectors\n\n方向、长度、向量的模、单位向量、点乘、余弦值\n\n* 点乘的重要性\n\n  使用向量的点积便于计算一个向量在另一个向量上的投影（光的投影）\n\n  衡量两个向量的接近程度\n\n  分解一个向量（使用投影可以进行加减运算）分解为垂直方向和水平方向\n\n  确定向量的基本方向，大于零同方向，小于零反方向\n\n![image-20231104150955701](GANES101现代计算机图形学入门-01/image-20231104150955701-17084112899532.png)\n\n* 叉乘的重要性（使用右手螺旋定则可以确定叉乘的方向）\n\n  叉乘可以建立一个三位空间的直角坐标系\n\n  任意的三维空间向量都可以分解到三位的单位向量中\n\n![image-20231104164704660](GANES101现代计算机图形学入门-01/image-20231104164704660-17084112899533.png)\n\n​\t\t叉乘的代数表示（矩阵相乘）\n\n![image-20231104164849274](GANES101现代计算机图形学入门-01/image-20231104164849274-17084112899534.png)\n\n**Q&A:判断一个点是否在三角形的内部**\n\n对三角形做逆时针，分别做三条边之间的向量，三个顶点分别于需要判断的点进行叉乘，如AB叉乘AP，如果都大于0，则说明在三角形内部。\n\n结论比较简单，很容易在计算机中使用公式实现出来。\n\n![image-20231104165645532](GANES101现代计算机图形学入门-01/image-20231104165645532-17084112899535.png)\n\n* 矩阵的重要性\n\n  图像转换，旋转，平移，剪切，数乘\n\n  * 矩阵的乘积（第一个矩阵的列数等于第二个矩阵的行数）\n\n    ![image-20231116154858801](GANES101现代计算机图形学入门-01/image-20231116154858801-17084112899536.png)\n\n    **矩阵的乘积没有任何交换律**，但是有结合律\n\n  * 矩阵与向量的乘积（列向量，可以表示为点的坐标）\n\n    可以利用矩阵乘积做一些变化操作（如下：将x，y变化为-x，y）\n\n    ![image-20231116155210293](GANES101现代计算机图形学入门-01/image-20231116155210293-17084112899537.png)\n\n  * 转置矩阵、单位矩阵（对角矩阵）","source":"_posts/GANES101现代计算机图形学入门-01.md","raw":"---\ntitle: GANES101现代计算机图形学入门-01\ndate: 2023-12-15 14:40:01\ntags: [计算机图形学 GAMES101]\ncategories: 学习笔记\ncover: games101.png\ntop_img: games101.png\n---\n\n\n## 计算机图形学01\n\n> 应用场景：电影，动画，可视化，家具，模拟，虚拟现实（VR），GUI（图形用户接口），字体\n\n* 好的画面：足够亮（全局光照）\n\n```\n1、光栅化\tResterization\n2、曲线曲面（几何）\tCurves and Meshes\n3、光线追踪\tRay\tTracing\n4、动画/模拟\tAnimation/Simulation\n```\n\n### 计算机图形学 VS 计算机视觉\n\n![image-20231104113151777](GANES101现代计算机图形学入门-01/image-20231104113151777-17084112899531.png)\n\n* MODEL，计算机画（图形学）\n\n  正向箭头：将三维空间的图形在二维中展示出来，特指图像渲染\n\n  自我箭头：MODEL的自我渲染，与图像无关\n\n* IMAGE，计算机看（计算机视觉）\n\n  反向箭头：从图形中推导和识别出图像的特征\n\n  自我箭头：依赖深度学习对图像进行处理\n\n作业相关\n\n```\n1、作业链接：http://games-cn.org/forums/topic/allhw/\n2、作业使用的系统：smartchair\n3、Use IDE：集成开发环境\n```\n\n\n\n### 线性代数——A Swift and Brutal Introduction to Linear Algebra\n\n> 数学：线性代数，微积分，统计，物理：光学，力学，信号处理，数值分析\n\n#### 向量Vectors\n\n方向、长度、向量的模、单位向量、点乘、余弦值\n\n* 点乘的重要性\n\n  使用向量的点积便于计算一个向量在另一个向量上的投影（光的投影）\n\n  衡量两个向量的接近程度\n\n  分解一个向量（使用投影可以进行加减运算）分解为垂直方向和水平方向\n\n  确定向量的基本方向，大于零同方向，小于零反方向\n\n![image-20231104150955701](GANES101现代计算机图形学入门-01/image-20231104150955701-17084112899532.png)\n\n* 叉乘的重要性（使用右手螺旋定则可以确定叉乘的方向）\n\n  叉乘可以建立一个三位空间的直角坐标系\n\n  任意的三维空间向量都可以分解到三位的单位向量中\n\n![image-20231104164704660](GANES101现代计算机图形学入门-01/image-20231104164704660-17084112899533.png)\n\n​\t\t叉乘的代数表示（矩阵相乘）\n\n![image-20231104164849274](GANES101现代计算机图形学入门-01/image-20231104164849274-17084112899534.png)\n\n**Q&A:判断一个点是否在三角形的内部**\n\n对三角形做逆时针，分别做三条边之间的向量，三个顶点分别于需要判断的点进行叉乘，如AB叉乘AP，如果都大于0，则说明在三角形内部。\n\n结论比较简单，很容易在计算机中使用公式实现出来。\n\n![image-20231104165645532](GANES101现代计算机图形学入门-01/image-20231104165645532-17084112899535.png)\n\n* 矩阵的重要性\n\n  图像转换，旋转，平移，剪切，数乘\n\n  * 矩阵的乘积（第一个矩阵的列数等于第二个矩阵的行数）\n\n    ![image-20231116154858801](GANES101现代计算机图形学入门-01/image-20231116154858801-17084112899536.png)\n\n    **矩阵的乘积没有任何交换律**，但是有结合律\n\n  * 矩阵与向量的乘积（列向量，可以表示为点的坐标）\n\n    可以利用矩阵乘积做一些变化操作（如下：将x，y变化为-x，y）\n\n    ![image-20231116155210293](GANES101现代计算机图形学入门-01/image-20231116155210293-17084112899537.png)\n\n  * 转置矩阵、单位矩阵（对角矩阵）","slug":"GANES101现代计算机图形学入门-01","published":1,"updated":"2024-02-20T07:07:49.269Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xp0007g4c28icxgmta","content":"<h2 id=\"计算机图形学01\"><a href=\"#计算机图形学01\" class=\"headerlink\" title=\"计算机图形学01\"></a>计算机图形学01</h2><blockquote>\n<p>应用场景：电影，动画，可视化，家具，模拟，虚拟现实（VR），GUI（图形用户接口），字体</p>\n</blockquote>\n<ul>\n<li>好的画面：足够亮（全局光照）</li>\n</ul>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-number\">1</span>、光栅化\tResterization<br><span class=\"hljs-number\">2</span>、曲线曲面（几何）\tCurves <span class=\"hljs-keyword\">and</span> Meshes<br><span class=\"hljs-number\">3</span>、光线追踪\tRay\tTracing<br><span class=\"hljs-number\">4</span>、动画/模拟\tAnimation/Simulation<br></code></pre></td></tr></table></figure>\n<h3 id=\"计算机图形学-VS-计算机视觉\"><a href=\"#计算机图形学-VS-计算机视觉\" class=\"headerlink\" title=\"计算机图形学 VS 计算机视觉\"></a>计算机图形学 VS 计算机视觉</h3><img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104113151777-17084112899531.png\" class=\"\" title=\"image-20231104113151777\">\n<ul>\n<li><p>MODEL，计算机画（图形学）</p>\n<p>正向箭头：将三维空间的图形在二维中展示出来，特指图像渲染</p>\n<p>自我箭头：MODEL的自我渲染，与图像无关</p>\n</li>\n<li><p>IMAGE，计算机看（计算机视觉）</p>\n<p>反向箭头：从图形中推导和识别出图像的特征</p>\n<p>自我箭头：依赖深度学习对图像进行处理</p>\n</li>\n</ul>\n<p>作业相关</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-number\">1</span>、作业链接：http:<span class=\"hljs-regexp\">//g</span>ames-cn.org<span class=\"hljs-regexp\">/forums/</span>topic<span class=\"hljs-regexp\">/allhw/</span><br><span class=\"hljs-number\">2</span>、作业使用的系统：smartchair<br><span class=\"hljs-number\">3</span>、Use IDE：集成开发环境<br></code></pre></td></tr></table></figure>\n<h3 id=\"线性代数——A-Swift-and-Brutal-Introduction-to-Linear-Algebra\"><a href=\"#线性代数——A-Swift-and-Brutal-Introduction-to-Linear-Algebra\" class=\"headerlink\" title=\"线性代数——A Swift and Brutal Introduction to Linear Algebra\"></a>线性代数——A Swift and Brutal Introduction to Linear Algebra</h3><blockquote>\n<p>数学：线性代数，微积分，统计，物理：光学，力学，信号处理，数值分析</p>\n</blockquote>\n<h4 id=\"向量Vectors\"><a href=\"#向量Vectors\" class=\"headerlink\" title=\"向量Vectors\"></a>向量Vectors</h4><p>方向、长度、向量的模、单位向量、点乘、余弦值</p>\n<ul>\n<li><p>点乘的重要性</p>\n<p>使用向量的点积便于计算一个向量在另一个向量上的投影（光的投影）</p>\n<p>衡量两个向量的接近程度</p>\n<p>分解一个向量（使用投影可以进行加减运算）分解为垂直方向和水平方向</p>\n<p>确定向量的基本方向，大于零同方向，小于零反方向</p>\n</li>\n</ul>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104150955701-17084112899532.png\" class=\"\" title=\"image-20231104150955701\">\n<ul>\n<li><p>叉乘的重要性（使用右手螺旋定则可以确定叉乘的方向）</p>\n<p>叉乘可以建立一个三位空间的直角坐标系</p>\n<p>任意的三维空间向量都可以分解到三位的单位向量中</p>\n</li>\n</ul>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104164704660-17084112899533.png\" class=\"\" title=\"image-20231104164704660\">\n<p>​        叉乘的代数表示（矩阵相乘）</p>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104164849274-17084112899534.png\" class=\"\" title=\"image-20231104164849274\">\n<p><strong>Q&amp;A:判断一个点是否在三角形的内部</strong></p>\n<p>对三角形做逆时针，分别做三条边之间的向量，三个顶点分别于需要判断的点进行叉乘，如AB叉乘AP，如果都大于0，则说明在三角形内部。</p>\n<p>结论比较简单，很容易在计算机中使用公式实现出来。</p>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104165645532-17084112899535.png\" class=\"\" title=\"image-20231104165645532\">\n<ul>\n<li><p>矩阵的重要性</p>\n<p>图像转换，旋转，平移，剪切，数乘</p>\n<ul>\n<li><p>矩阵的乘积（第一个矩阵的列数等于第二个矩阵的行数）</p>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231116154858801-17084112899536.png\" class=\"\" title=\"image-20231116154858801\">\n<p><strong>矩阵的乘积没有任何交换律</strong>，但是有结合律</p>\n</li>\n<li><p>矩阵与向量的乘积（列向量，可以表示为点的坐标）</p>\n<p>可以利用矩阵乘积做一些变化操作（如下：将x，y变化为-x，y）</p>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231116155210293-17084112899537.png\" class=\"\" title=\"image-20231116155210293\">\n</li>\n<li><p>转置矩阵、单位矩阵（对角矩阵）</p>\n</li>\n</ul>\n</li>\n</ul>\n","cover_type":"img","excerpt":"","more":"<h2 id=\"计算机图形学01\"><a href=\"#计算机图形学01\" class=\"headerlink\" title=\"计算机图形学01\"></a>计算机图形学01</h2><blockquote>\n<p>应用场景：电影，动画，可视化，家具，模拟，虚拟现实（VR），GUI（图形用户接口），字体</p>\n</blockquote>\n<ul>\n<li>好的画面：足够亮（全局光照）</li>\n</ul>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs armasm\"><span class=\"hljs-number\">1</span>、光栅化\tResterization<br><span class=\"hljs-number\">2</span>、曲线曲面（几何）\tCurves <span class=\"hljs-keyword\">and</span> Meshes<br><span class=\"hljs-number\">3</span>、光线追踪\tRay\tTracing<br><span class=\"hljs-number\">4</span>、动画/模拟\tAnimation/Simulation<br></code></pre></td></tr></table></figure>\n<h3 id=\"计算机图形学-VS-计算机视觉\"><a href=\"#计算机图形学-VS-计算机视觉\" class=\"headerlink\" title=\"计算机图形学 VS 计算机视觉\"></a>计算机图形学 VS 计算机视觉</h3><img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104113151777-17084112899531.png\" class=\"\" title=\"image-20231104113151777\">\n<ul>\n<li><p>MODEL，计算机画（图形学）</p>\n<p>正向箭头：将三维空间的图形在二维中展示出来，特指图像渲染</p>\n<p>自我箭头：MODEL的自我渲染，与图像无关</p>\n</li>\n<li><p>IMAGE，计算机看（计算机视觉）</p>\n<p>反向箭头：从图形中推导和识别出图像的特征</p>\n<p>自我箭头：依赖深度学习对图像进行处理</p>\n</li>\n</ul>\n<p>作业相关</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-number\">1</span>、作业链接：http:<span class=\"hljs-regexp\">//g</span>ames-cn.org<span class=\"hljs-regexp\">/forums/</span>topic<span class=\"hljs-regexp\">/allhw/</span><br><span class=\"hljs-number\">2</span>、作业使用的系统：smartchair<br><span class=\"hljs-number\">3</span>、Use IDE：集成开发环境<br></code></pre></td></tr></table></figure>\n<h3 id=\"线性代数——A-Swift-and-Brutal-Introduction-to-Linear-Algebra\"><a href=\"#线性代数——A-Swift-and-Brutal-Introduction-to-Linear-Algebra\" class=\"headerlink\" title=\"线性代数——A Swift and Brutal Introduction to Linear Algebra\"></a>线性代数——A Swift and Brutal Introduction to Linear Algebra</h3><blockquote>\n<p>数学：线性代数，微积分，统计，物理：光学，力学，信号处理，数值分析</p>\n</blockquote>\n<h4 id=\"向量Vectors\"><a href=\"#向量Vectors\" class=\"headerlink\" title=\"向量Vectors\"></a>向量Vectors</h4><p>方向、长度、向量的模、单位向量、点乘、余弦值</p>\n<ul>\n<li><p>点乘的重要性</p>\n<p>使用向量的点积便于计算一个向量在另一个向量上的投影（光的投影）</p>\n<p>衡量两个向量的接近程度</p>\n<p>分解一个向量（使用投影可以进行加减运算）分解为垂直方向和水平方向</p>\n<p>确定向量的基本方向，大于零同方向，小于零反方向</p>\n</li>\n</ul>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104150955701-17084112899532.png\" class=\"\" title=\"image-20231104150955701\">\n<ul>\n<li><p>叉乘的重要性（使用右手螺旋定则可以确定叉乘的方向）</p>\n<p>叉乘可以建立一个三位空间的直角坐标系</p>\n<p>任意的三维空间向量都可以分解到三位的单位向量中</p>\n</li>\n</ul>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104164704660-17084112899533.png\" class=\"\" title=\"image-20231104164704660\">\n<p>​        叉乘的代数表示（矩阵相乘）</p>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104164849274-17084112899534.png\" class=\"\" title=\"image-20231104164849274\">\n<p><strong>Q&amp;A:判断一个点是否在三角形的内部</strong></p>\n<p>对三角形做逆时针，分别做三条边之间的向量，三个顶点分别于需要判断的点进行叉乘，如AB叉乘AP，如果都大于0，则说明在三角形内部。</p>\n<p>结论比较简单，很容易在计算机中使用公式实现出来。</p>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231104165645532-17084112899535.png\" class=\"\" title=\"image-20231104165645532\">\n<ul>\n<li><p>矩阵的重要性</p>\n<p>图像转换，旋转，平移，剪切，数乘</p>\n<ul>\n<li><p>矩阵的乘积（第一个矩阵的列数等于第二个矩阵的行数）</p>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231116154858801-17084112899536.png\" class=\"\" title=\"image-20231116154858801\">\n<p><strong>矩阵的乘积没有任何交换律</strong>，但是有结合律</p>\n</li>\n<li><p>矩阵与向量的乘积（列向量，可以表示为点的坐标）</p>\n<p>可以利用矩阵乘积做一些变化操作（如下：将x，y变化为-x，y）</p>\n<img src=\"/2023/12/15/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-01/image-20231116155210293-17084112899537.png\" class=\"\" title=\"image-20231116155210293\">\n</li>\n<li><p>转置矩阵、单位矩阵（对角矩阵）</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"GANES101现代计算机图形学入门-02","date":"2023-12-16T06:40:01.000Z","cover":"2023/12/16/GANES101现代计算机图形学入门-02/games101_top.png","top_img":"2023/12/16/GANES101现代计算机图形学入门-02/games101_top.png","_content":"\n\n## 计算机图形学02\n\n> Transform（变换），图形的变换\n\n```\n为什么学习变换\n2维变换：旋转、缩放、切变\n齐次坐标 Homogeneous coordinates\n组合变换\n3维变换\n```\n\n### 二维变换\n\n将矩阵和变换联系起来\n\n* 1、缩放\n\n  将坐标在向量左边乘一个对角矩阵\n\n  ![image-20231116161524873](GANES101现代计算机图形学入门-02/image-20231116161524873-17084118809551.png)\n\n* 2、反射对称\n\n  ![image-20231116161727694](GANES101现代计算机图形学入门-02/image-20231116161727694-17084118809562.png)\n\n* 3、切变（Shear Matrix）\n\n  水平方向坐标发生改变，竖直方向不变，水平的移动大小，按照Y的当前坐标成正比\n\n  ![image-20231116161842894](GANES101现代计算机图形学入门-02/image-20231116161842894-17084118809563.png)\n\n* 4、旋转\n\n  ![image-20231116164956551](GANES101现代计算机图形学入门-02/image-20231116164956551-17084118809564.png)\n\n  ![IMG_0318(C:/Users/zdon/Desktop/实习/job_files/self_study/计算机图形学/计算机图形学学习笔记/GANES101现代计算机图形学入门-02/IMG_0318(20231116-164749).PNG)](GANES101现代计算机图形学入门-02/IMG_0318(20231116-164749).PNG)\n\n通过矩阵乘积可以将一个输入图形的坐标转化为想要的输出矩阵的坐标，这样的变换都称为**线性变换**\n\n### 齐次坐标（homogeneous coordinates）\n\n> 平移操作无法使用线性变化即矩阵的乘法来获得，所以引入齐次坐标，增加一个维度\n>\n> 齐次坐标的矩阵操作，可以叫做仿射变换\n\n增加维度以后，通过与新增加列的运算就可以达到平移的变换\n\n![image-20231116165833300](GANES101现代计算机图形学入门-02/image-20231116165833300-17084118809565.png)\n\n* Q：Why？将二维的点，增加一个1，将二维的向量，增加一个0\n\n  1、通过增加的维度可以标识当前的坐标表示点还是表示向量。可以保证向量具有平移不变性\n\n  2、最后一个维度的运算正好表示运算结果的性质\n\n  ![image-20231116170520355](GANES101现代计算机图形学入门-02/image-20231116170520355-17084118809566.png)\n\n  3、点+点，得到的结果为两个点的终点，因为第三维为2，与两点之和相除便是中点\n\n**齐次坐标下的变换操作矩阵**\n\n![image-20231116171041924](GANES101现代计算机图形学入门-02/image-20231116171041924-17084118809567.png)\n\n* 逆变换\n\n  乘以变化矩阵的逆矩阵，可以变换成原来的图片\n\n### 变换组合\n\n1、复杂变换可以通过简单的变化来得到\n\n2、变换的顺序不同，得到的结果不同\n\n3、变换的组合，等价于原始矩阵依次乘上按照一定顺序的齐次矩阵\n\n* 将一个变化还原，或者以任意一个点为中心进行变化，可以先移动到原点，再进行操作\n\n![image-20231116200444279](GANES101现代计算机图形学入门-02/image-20231116200444279-17084118809568.png)\n\n### 三维变换\n\n* 三维点和三维向量\n\n  ![image-20231116201112834](GANES101现代计算机图形学入门-02/image-20231116201112834-17084118809569.png)\n\n* 三维变换齐次矩阵\n\n  ![image-20231116201139440](GANES101现代计算机图形学入门-02/image-20231116201139440-170841188095610.png)\n\n* 旋转\n\n  绕哪个轴旋转哪个轴保持不变\n\n  对于一般性的旋转，可以使用简单旋转的组合来完成\n\n  ![image-20231118142130480](GANES101现代计算机图形学入门-02/image-20231118142130480-170841188095611.png)\n\n* 使用旋转公式\n\n  旋转角度定义为a\n\n  旋转轴定义为n\n\n  其中**I**表示为单位矩阵\n\n  表示为，沿着旋转轴n旋转a的角度得到的旋转矩阵\n\n  ![image-20231118142833380](GANES101现代计算机图形学入门-02/image-20231118142833380-170841188095612.png)\n\n### 观测变换（Viewing transformation）\n\n> 视图变换、投影变换（正交投影，透视投影）\n\n ","source":"_posts/GANES101现代计算机图形学入门-02.md","raw":"---\ntitle: GANES101现代计算机图形学入门-02\ndate: 2023-12-16 14:40:01\ntags: [计算机图形学 GAMES101]\ncategories: 学习笔记\ncover: games101_top.png\ntop_img: games101_top.png\n---\n\n\n## 计算机图形学02\n\n> Transform（变换），图形的变换\n\n```\n为什么学习变换\n2维变换：旋转、缩放、切变\n齐次坐标 Homogeneous coordinates\n组合变换\n3维变换\n```\n\n### 二维变换\n\n将矩阵和变换联系起来\n\n* 1、缩放\n\n  将坐标在向量左边乘一个对角矩阵\n\n  ![image-20231116161524873](GANES101现代计算机图形学入门-02/image-20231116161524873-17084118809551.png)\n\n* 2、反射对称\n\n  ![image-20231116161727694](GANES101现代计算机图形学入门-02/image-20231116161727694-17084118809562.png)\n\n* 3、切变（Shear Matrix）\n\n  水平方向坐标发生改变，竖直方向不变，水平的移动大小，按照Y的当前坐标成正比\n\n  ![image-20231116161842894](GANES101现代计算机图形学入门-02/image-20231116161842894-17084118809563.png)\n\n* 4、旋转\n\n  ![image-20231116164956551](GANES101现代计算机图形学入门-02/image-20231116164956551-17084118809564.png)\n\n  ![IMG_0318(C:/Users/zdon/Desktop/实习/job_files/self_study/计算机图形学/计算机图形学学习笔记/GANES101现代计算机图形学入门-02/IMG_0318(20231116-164749).PNG)](GANES101现代计算机图形学入门-02/IMG_0318(20231116-164749).PNG)\n\n通过矩阵乘积可以将一个输入图形的坐标转化为想要的输出矩阵的坐标，这样的变换都称为**线性变换**\n\n### 齐次坐标（homogeneous coordinates）\n\n> 平移操作无法使用线性变化即矩阵的乘法来获得，所以引入齐次坐标，增加一个维度\n>\n> 齐次坐标的矩阵操作，可以叫做仿射变换\n\n增加维度以后，通过与新增加列的运算就可以达到平移的变换\n\n![image-20231116165833300](GANES101现代计算机图形学入门-02/image-20231116165833300-17084118809565.png)\n\n* Q：Why？将二维的点，增加一个1，将二维的向量，增加一个0\n\n  1、通过增加的维度可以标识当前的坐标表示点还是表示向量。可以保证向量具有平移不变性\n\n  2、最后一个维度的运算正好表示运算结果的性质\n\n  ![image-20231116170520355](GANES101现代计算机图形学入门-02/image-20231116170520355-17084118809566.png)\n\n  3、点+点，得到的结果为两个点的终点，因为第三维为2，与两点之和相除便是中点\n\n**齐次坐标下的变换操作矩阵**\n\n![image-20231116171041924](GANES101现代计算机图形学入门-02/image-20231116171041924-17084118809567.png)\n\n* 逆变换\n\n  乘以变化矩阵的逆矩阵，可以变换成原来的图片\n\n### 变换组合\n\n1、复杂变换可以通过简单的变化来得到\n\n2、变换的顺序不同，得到的结果不同\n\n3、变换的组合，等价于原始矩阵依次乘上按照一定顺序的齐次矩阵\n\n* 将一个变化还原，或者以任意一个点为中心进行变化，可以先移动到原点，再进行操作\n\n![image-20231116200444279](GANES101现代计算机图形学入门-02/image-20231116200444279-17084118809568.png)\n\n### 三维变换\n\n* 三维点和三维向量\n\n  ![image-20231116201112834](GANES101现代计算机图形学入门-02/image-20231116201112834-17084118809569.png)\n\n* 三维变换齐次矩阵\n\n  ![image-20231116201139440](GANES101现代计算机图形学入门-02/image-20231116201139440-170841188095610.png)\n\n* 旋转\n\n  绕哪个轴旋转哪个轴保持不变\n\n  对于一般性的旋转，可以使用简单旋转的组合来完成\n\n  ![image-20231118142130480](GANES101现代计算机图形学入门-02/image-20231118142130480-170841188095611.png)\n\n* 使用旋转公式\n\n  旋转角度定义为a\n\n  旋转轴定义为n\n\n  其中**I**表示为单位矩阵\n\n  表示为，沿着旋转轴n旋转a的角度得到的旋转矩阵\n\n  ![image-20231118142833380](GANES101现代计算机图形学入门-02/image-20231118142833380-170841188095612.png)\n\n### 观测变换（Viewing transformation）\n\n> 视图变换、投影变换（正交投影，透视投影）\n\n ","slug":"GANES101现代计算机图形学入门-02","published":1,"updated":"2024-02-20T07:08:01.738Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xr000ag4c2dayt0vir","content":"<h2 id=\"计算机图形学02\"><a href=\"#计算机图形学02\" class=\"headerlink\" title=\"计算机图形学02\"></a>计算机图形学02</h2><blockquote>\n<p>Transform（变换），图形的变换</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">为什么学习变换<br>2维变换：旋转、缩放、切变<br>齐次坐标 Homogeneous coordinates<br>组合变换<br>3维变换<br></code></pre></td></tr></table></figure>\n<h3 id=\"二维变换\"><a href=\"#二维变换\" class=\"headerlink\" title=\"二维变换\"></a>二维变换</h3><p>将矩阵和变换联系起来</p>\n<ul>\n<li><p>1、缩放</p>\n<p>将坐标在向量左边乘一个对角矩阵</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161524873-17084118809551.png\" class=\"\" title=\"image-20231116161524873\">\n</li>\n<li><p>2、反射对称</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161727694-17084118809562.png\" class=\"\" title=\"image-20231116161727694\">\n</li>\n<li><p>3、切变（Shear Matrix）</p>\n<p>水平方向坐标发生改变，竖直方向不变，水平的移动大小，按照Y的当前坐标成正比</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161842894-17084118809563.png\" class=\"\" title=\"image-20231116161842894\">\n</li>\n<li><p>4、旋转</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116164956551-17084118809564.png\" class=\"\" title=\"image-20231116164956551\">\n<p>.PNG)</p>\n</li>\n</ul>\n<p>通过矩阵乘积可以将一个输入图形的坐标转化为想要的输出矩阵的坐标，这样的变换都称为<strong>线性变换</strong></p>\n<h3 id=\"齐次坐标（homogeneous-coordinates）\"><a href=\"#齐次坐标（homogeneous-coordinates）\" class=\"headerlink\" title=\"齐次坐标（homogeneous coordinates）\"></a>齐次坐标（homogeneous coordinates）</h3><blockquote>\n<p>平移操作无法使用线性变化即矩阵的乘法来获得，所以引入齐次坐标，增加一个维度</p>\n<p>齐次坐标的矩阵操作，可以叫做仿射变换</p>\n</blockquote>\n<p>增加维度以后，通过与新增加列的运算就可以达到平移的变换</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116165833300-17084118809565.png\" class=\"\" title=\"image-20231116165833300\">\n<ul>\n<li><p>Q：Why？将二维的点，增加一个1，将二维的向量，增加一个0</p>\n<p>1、通过增加的维度可以标识当前的坐标表示点还是表示向量。可以保证向量具有平移不变性</p>\n<p>2、最后一个维度的运算正好表示运算结果的性质</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116170520355-17084118809566.png\" class=\"\" title=\"image-20231116170520355\">\n<p>3、点+点，得到的结果为两个点的终点，因为第三维为2，与两点之和相除便是中点</p>\n</li>\n</ul>\n<p><strong>齐次坐标下的变换操作矩阵</strong></p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116171041924-17084118809567.png\" class=\"\" title=\"image-20231116171041924\">\n<ul>\n<li><p>逆变换</p>\n<p>乘以变化矩阵的逆矩阵，可以变换成原来的图片</p>\n</li>\n</ul>\n<h3 id=\"变换组合\"><a href=\"#变换组合\" class=\"headerlink\" title=\"变换组合\"></a>变换组合</h3><p>1、复杂变换可以通过简单的变化来得到</p>\n<p>2、变换的顺序不同，得到的结果不同</p>\n<p>3、变换的组合，等价于原始矩阵依次乘上按照一定顺序的齐次矩阵</p>\n<ul>\n<li>将一个变化还原，或者以任意一个点为中心进行变化，可以先移动到原点，再进行操作</li>\n</ul>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116200444279-17084118809568.png\" class=\"\" title=\"image-20231116200444279\">\n<h3 id=\"三维变换\"><a href=\"#三维变换\" class=\"headerlink\" title=\"三维变换\"></a>三维变换</h3><ul>\n<li><p>三维点和三维向量</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116201112834-17084118809569.png\" class=\"\" title=\"image-20231116201112834\">\n</li>\n<li><p>三维变换齐次矩阵</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116201139440-170841188095610.png\" class=\"\" title=\"image-20231116201139440\">\n</li>\n<li><p>旋转</p>\n<p>绕哪个轴旋转哪个轴保持不变</p>\n<p>对于一般性的旋转，可以使用简单旋转的组合来完成</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231118142130480-170841188095611.png\" class=\"\" title=\"image-20231118142130480\">\n</li>\n<li><p>使用旋转公式</p>\n<p>旋转角度定义为a</p>\n<p>旋转轴定义为n</p>\n<p>其中<strong>I</strong>表示为单位矩阵</p>\n<p>表示为，沿着旋转轴n旋转a的角度得到的旋转矩阵</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231118142833380-170841188095612.png\" class=\"\" title=\"image-20231118142833380\">\n</li>\n</ul>\n<h3 id=\"观测变换（Viewing-transformation）\"><a href=\"#观测变换（Viewing-transformation）\" class=\"headerlink\" title=\"观测变换（Viewing transformation）\"></a>观测变换（Viewing transformation）</h3><blockquote>\n<p>视图变换、投影变换（正交投影，透视投影）</p>\n</blockquote>\n","cover_type":"img","excerpt":"","more":"<h2 id=\"计算机图形学02\"><a href=\"#计算机图形学02\" class=\"headerlink\" title=\"计算机图形学02\"></a>计算机图形学02</h2><blockquote>\n<p>Transform（变换），图形的变换</p>\n</blockquote>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">为什么学习变换<br>2维变换：旋转、缩放、切变<br>齐次坐标 Homogeneous coordinates<br>组合变换<br>3维变换<br></code></pre></td></tr></table></figure>\n<h3 id=\"二维变换\"><a href=\"#二维变换\" class=\"headerlink\" title=\"二维变换\"></a>二维变换</h3><p>将矩阵和变换联系起来</p>\n<ul>\n<li><p>1、缩放</p>\n<p>将坐标在向量左边乘一个对角矩阵</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161524873-17084118809551.png\" class=\"\" title=\"image-20231116161524873\">\n</li>\n<li><p>2、反射对称</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161727694-17084118809562.png\" class=\"\" title=\"image-20231116161727694\">\n</li>\n<li><p>3、切变（Shear Matrix）</p>\n<p>水平方向坐标发生改变，竖直方向不变，水平的移动大小，按照Y的当前坐标成正比</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116161842894-17084118809563.png\" class=\"\" title=\"image-20231116161842894\">\n</li>\n<li><p>4、旋转</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116164956551-17084118809564.png\" class=\"\" title=\"image-20231116164956551\">\n<p>.PNG)</p>\n</li>\n</ul>\n<p>通过矩阵乘积可以将一个输入图形的坐标转化为想要的输出矩阵的坐标，这样的变换都称为<strong>线性变换</strong></p>\n<h3 id=\"齐次坐标（homogeneous-coordinates）\"><a href=\"#齐次坐标（homogeneous-coordinates）\" class=\"headerlink\" title=\"齐次坐标（homogeneous coordinates）\"></a>齐次坐标（homogeneous coordinates）</h3><blockquote>\n<p>平移操作无法使用线性变化即矩阵的乘法来获得，所以引入齐次坐标，增加一个维度</p>\n<p>齐次坐标的矩阵操作，可以叫做仿射变换</p>\n</blockquote>\n<p>增加维度以后，通过与新增加列的运算就可以达到平移的变换</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116165833300-17084118809565.png\" class=\"\" title=\"image-20231116165833300\">\n<ul>\n<li><p>Q：Why？将二维的点，增加一个1，将二维的向量，增加一个0</p>\n<p>1、通过增加的维度可以标识当前的坐标表示点还是表示向量。可以保证向量具有平移不变性</p>\n<p>2、最后一个维度的运算正好表示运算结果的性质</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116170520355-17084118809566.png\" class=\"\" title=\"image-20231116170520355\">\n<p>3、点+点，得到的结果为两个点的终点，因为第三维为2，与两点之和相除便是中点</p>\n</li>\n</ul>\n<p><strong>齐次坐标下的变换操作矩阵</strong></p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116171041924-17084118809567.png\" class=\"\" title=\"image-20231116171041924\">\n<ul>\n<li><p>逆变换</p>\n<p>乘以变化矩阵的逆矩阵，可以变换成原来的图片</p>\n</li>\n</ul>\n<h3 id=\"变换组合\"><a href=\"#变换组合\" class=\"headerlink\" title=\"变换组合\"></a>变换组合</h3><p>1、复杂变换可以通过简单的变化来得到</p>\n<p>2、变换的顺序不同，得到的结果不同</p>\n<p>3、变换的组合，等价于原始矩阵依次乘上按照一定顺序的齐次矩阵</p>\n<ul>\n<li>将一个变化还原，或者以任意一个点为中心进行变化，可以先移动到原点，再进行操作</li>\n</ul>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116200444279-17084118809568.png\" class=\"\" title=\"image-20231116200444279\">\n<h3 id=\"三维变换\"><a href=\"#三维变换\" class=\"headerlink\" title=\"三维变换\"></a>三维变换</h3><ul>\n<li><p>三维点和三维向量</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116201112834-17084118809569.png\" class=\"\" title=\"image-20231116201112834\">\n</li>\n<li><p>三维变换齐次矩阵</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231116201139440-170841188095610.png\" class=\"\" title=\"image-20231116201139440\">\n</li>\n<li><p>旋转</p>\n<p>绕哪个轴旋转哪个轴保持不变</p>\n<p>对于一般性的旋转，可以使用简单旋转的组合来完成</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231118142130480-170841188095611.png\" class=\"\" title=\"image-20231118142130480\">\n</li>\n<li><p>使用旋转公式</p>\n<p>旋转角度定义为a</p>\n<p>旋转轴定义为n</p>\n<p>其中<strong>I</strong>表示为单位矩阵</p>\n<p>表示为，沿着旋转轴n旋转a的角度得到的旋转矩阵</p>\n<img src=\"/2023/12/16/GANES101%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-02/image-20231118142833380-170841188095612.png\" class=\"\" title=\"image-20231118142833380\">\n</li>\n</ul>\n<h3 id=\"观测变换（Viewing-transformation）\"><a href=\"#观测变换（Viewing-transformation）\" class=\"headerlink\" title=\"观测变换（Viewing transformation）\"></a>观测变换（Viewing transformation）</h3><blockquote>\n<p>视图变换、投影变换（正交投影，透视投影）</p>\n</blockquote>\n"},{"title":"Git常见用法","date":"2024-01-04T04:07:20.000Z","cover":"/img/default_cover01.jpg","top_img":"2024/01/04/git/image-20231204110955462.png","_content":"\n#### 怎样撤销一个已经push到远端的版本\n\n```\n每次push之前线pull一下\n\n1、查看当前提交的信息，找到需要撤回到的版本号复制，一串十六进制的数\ngit log\n\n2、使用git reset\ngit reset --soft 复制的版本号\n\n3、强制回退当前版本号\n// 确认一下当前版本\ngit log\n// 谨慎使用，强制使用本地仓库代码修改远程仓库\ngit push orgin master --force\n```\n\n#### 新建分支并同步到远端的分支\n\n```\n# 在本地新建一个名字为branch_name的分支，并与远端的origin/branch_name同步\ngit checkout -b branch_name origin/branch_name\n```\n\n#### 解决git clone超时的问题\n\n从github上clone代码仓库报错`Failed to connect to github.com port 443 after 21038 ms: Couldn't connect to server`且尝试去ping一下github官网会丢包\n\n![image-20231204110955462](git/image-20231204110955462.png)\n\n解决方案\n\n修改系统的hosts，跳过域名解析的过程，直接用ip地址访问\n\n```\n192.30.255.112 github.com git\n185.31.16.184 github.global.ssl.fastly.net\n```\n\n![image-20231204111125551](git/image-20231204111125551.png)\n\n修改hosts需要给文件更高的权限\n\n![image-20231204111350240](git/image-20231204111350240.png)\n\n#### github中git push出现超时的问题\n\n![image-20231204112945547](git/image-20231204112945547.png)\n\n解决方案\n\n1、打开本机的代理服务器\n\n![image-20231204113100512](git/image-20231204113100512.png)\n\n2、取消git config里面的http和https代理\n\n![image-20231204113208566](git/image-20231204113208566.png)\n\n3、设置http代理服务器\n\n![image-20231204113304822](git/image-20231204113304822.png)\n\n#### linux中输出一个文件夹下面的所有文件名\n\n- **`/path/to/directory`**: 替换为目标目录的路径。\n- **`-maxdepth 1`**: 限制`find`的搜索深度为1，即仅在指定的目录中搜索，而不会搜索其子目录。\n- **`-type f`**: 限制搜索结果为普通文件（不包括目录和其他类型的文件）。\n- **`-exec basename {} \\;`**: 对每一个找到的文件执行`basename`命令，即输出文件的基本名称。`{}`是`find`命令的占位符，表示每个找到的文件的路径。`\\;`表示命令结束。\n\n```\nfind /path/to/directory -maxdepth 1 -type f -exec basename {} \\;\n```\n\n#### git查看远端仓库地址\n\n```\ngit remote -v\n\n# 更改远程仓库\ngit remote set-url origin 仓库地址\n```\n\n#### 查看代码贡献量\n\n> 按照各个作者的修改代码总数排序\n\n```\ngit log --pretty=\"%aN\" | sort | uniq -c | while read count author; do echo -n \"$author \"; git log --author=\"$author\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2 } END { total = add + subs; printf \"%d\\n\", total }'; done | sort -rnk2\n```\n\n","source":"_posts/git.md","raw":"---\ntitle: Git常见用法\ndate: 2024-01-04 12:07:20\ntags: git\ncategories: 技术研究\ncover: /img/default_cover01.jpg\ntop_img: image-20231204110955462.png\n---\n\n#### 怎样撤销一个已经push到远端的版本\n\n```\n每次push之前线pull一下\n\n1、查看当前提交的信息，找到需要撤回到的版本号复制，一串十六进制的数\ngit log\n\n2、使用git reset\ngit reset --soft 复制的版本号\n\n3、强制回退当前版本号\n// 确认一下当前版本\ngit log\n// 谨慎使用，强制使用本地仓库代码修改远程仓库\ngit push orgin master --force\n```\n\n#### 新建分支并同步到远端的分支\n\n```\n# 在本地新建一个名字为branch_name的分支，并与远端的origin/branch_name同步\ngit checkout -b branch_name origin/branch_name\n```\n\n#### 解决git clone超时的问题\n\n从github上clone代码仓库报错`Failed to connect to github.com port 443 after 21038 ms: Couldn't connect to server`且尝试去ping一下github官网会丢包\n\n![image-20231204110955462](git/image-20231204110955462.png)\n\n解决方案\n\n修改系统的hosts，跳过域名解析的过程，直接用ip地址访问\n\n```\n192.30.255.112 github.com git\n185.31.16.184 github.global.ssl.fastly.net\n```\n\n![image-20231204111125551](git/image-20231204111125551.png)\n\n修改hosts需要给文件更高的权限\n\n![image-20231204111350240](git/image-20231204111350240.png)\n\n#### github中git push出现超时的问题\n\n![image-20231204112945547](git/image-20231204112945547.png)\n\n解决方案\n\n1、打开本机的代理服务器\n\n![image-20231204113100512](git/image-20231204113100512.png)\n\n2、取消git config里面的http和https代理\n\n![image-20231204113208566](git/image-20231204113208566.png)\n\n3、设置http代理服务器\n\n![image-20231204113304822](git/image-20231204113304822.png)\n\n#### linux中输出一个文件夹下面的所有文件名\n\n- **`/path/to/directory`**: 替换为目标目录的路径。\n- **`-maxdepth 1`**: 限制`find`的搜索深度为1，即仅在指定的目录中搜索，而不会搜索其子目录。\n- **`-type f`**: 限制搜索结果为普通文件（不包括目录和其他类型的文件）。\n- **`-exec basename {} \\;`**: 对每一个找到的文件执行`basename`命令，即输出文件的基本名称。`{}`是`find`命令的占位符，表示每个找到的文件的路径。`\\;`表示命令结束。\n\n```\nfind /path/to/directory -maxdepth 1 -type f -exec basename {} \\;\n```\n\n#### git查看远端仓库地址\n\n```\ngit remote -v\n\n# 更改远程仓库\ngit remote set-url origin 仓库地址\n```\n\n#### 查看代码贡献量\n\n> 按照各个作者的修改代码总数排序\n\n```\ngit log --pretty=\"%aN\" | sort | uniq -c | while read count author; do echo -n \"$author \"; git log --author=\"$author\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2 } END { total = add + subs; printf \"%d\\n\", total }'; done | sort -rnk2\n```\n\n","slug":"git","published":1,"updated":"2024-02-20T07:13:50.025Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xs000bg4c2h41edgfk","content":"<h4 id=\"怎样撤销一个已经push到远端的版本\"><a href=\"#怎样撤销一个已经push到远端的版本\" class=\"headerlink\" title=\"怎样撤销一个已经push到远端的版本\"></a>怎样撤销一个已经push到远端的版本</h4><figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">每次<span class=\"hljs-built_in\">push</span>之前线pull一下<br><br><span class=\"hljs-number\">1</span>、查看当前提交的信息，找到需要撤回到的版本号复制，一串十六进制的数<br>git <span class=\"hljs-built_in\">log</span><br><br><span class=\"hljs-number\">2</span>、使用git reset<br>git reset --soft 复制的版本号<br><br><span class=\"hljs-number\">3</span>、强制回退当前版本号<br><span class=\"hljs-comment\">// 确认一下当前版本</span><br>git <span class=\"hljs-built_in\">log</span><br><span class=\"hljs-comment\">// 谨慎使用，强制使用本地仓库代码修改远程仓库</span><br>git <span class=\"hljs-built_in\">push</span> orgin master --force<br></code></pre></td></tr></table></figure>\n<h4 id=\"新建分支并同步到远端的分支\"><a href=\"#新建分支并同步到远端的分支\" class=\"headerlink\" title=\"新建分支并同步到远端的分支\"></a>新建分支并同步到远端的分支</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-comment\"># 在本地新建一个名字为branch_name的分支，并与远端的origin/branch_name同步</span><br>git checkout -<span class=\"hljs-keyword\">b </span><span class=\"hljs-keyword\">branch_name </span><span class=\"hljs-keyword\">origin/branch_name</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"解决git-clone超时的问题\"><a href=\"#解决git-clone超时的问题\" class=\"headerlink\" title=\"解决git clone超时的问题\"></a>解决git clone超时的问题</h4><p>从github上clone代码仓库报错<code>Failed to connect to github.com port 443 after 21038 ms: Couldn&#39;t connect to server</code>且尝试去ping一下github官网会丢包</p>\n<img src=\"/2024/01/04/git/image-20231204110955462.png\" class=\"\" title=\"image-20231204110955462\">\n<p>解决方案</p>\n<p>修改系统的hosts，跳过域名解析的过程，直接用ip地址访问</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs accesslog\"><span class=\"hljs-number\">192.30.255.112</span> github.com git<br><span class=\"hljs-number\">185.31.16.184</span> github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure>\n<img src=\"/2024/01/04/git/image-20231204111125551.png\" class=\"\" title=\"image-20231204111125551\">\n<p>修改hosts需要给文件更高的权限</p>\n<img src=\"/2024/01/04/git/image-20231204111350240.png\" class=\"\" title=\"image-20231204111350240\">\n<h4 id=\"github中git-push出现超时的问题\"><a href=\"#github中git-push出现超时的问题\" class=\"headerlink\" title=\"github中git push出现超时的问题\"></a>github中git push出现超时的问题</h4><img src=\"/2024/01/04/git/image-20231204112945547.png\" class=\"\" title=\"image-20231204112945547\">\n<p>解决方案</p>\n<p>1、打开本机的代理服务器</p>\n<img src=\"/2024/01/04/git/image-20231204113100512.png\" class=\"\" title=\"image-20231204113100512\">\n<p>2、取消git config里面的http和https代理</p>\n<img src=\"/2024/01/04/git/image-20231204113208566.png\" class=\"\" title=\"image-20231204113208566\">\n<p>3、设置http代理服务器</p>\n<img src=\"/2024/01/04/git/image-20231204113304822.png\" class=\"\" title=\"image-20231204113304822\">\n<h4 id=\"linux中输出一个文件夹下面的所有文件名\"><a href=\"#linux中输出一个文件夹下面的所有文件名\" class=\"headerlink\" title=\"linux中输出一个文件夹下面的所有文件名\"></a>linux中输出一个文件夹下面的所有文件名</h4><ul>\n<li><strong><code>/path/to/directory</code></strong>: 替换为目标目录的路径。</li>\n<li><strong><code>-maxdepth 1</code></strong>: 限制<code>find</code>的搜索深度为1，即仅在指定的目录中搜索，而不会搜索其子目录。</li>\n<li><strong><code>-type f</code></strong>: 限制搜索结果为普通文件（不包括目录和其他类型的文件）。</li>\n<li><strong><code>-exec basename &#123;&#125; \\;</code></strong>: 对每一个找到的文件执行<code>basename</code>命令，即输出文件的基本名称。<code>&#123;&#125;</code>是<code>find</code>命令的占位符，表示每个找到的文件的路径。<code>\\;</code>表示命令结束。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">find /path/to/directory -maxdepth 1 -<span class=\"hljs-built_in\">type</span> f -<span class=\"hljs-built_in\">exec</span> <span class=\"hljs-built_in\">basename</span> &#123;&#125; \\;<br></code></pre></td></tr></table></figure>\n<h4 id=\"git查看远端仓库地址\"><a href=\"#git查看远端仓库地址\" class=\"headerlink\" title=\"git查看远端仓库地址\"></a>git查看远端仓库地址</h4><figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dsconfig\"><span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> -<span class=\"hljs-string\">v</span><br><br><span class=\"hljs-comment\"># 更改远程仓库</span><br><span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">set-url</span> <span class=\"hljs-string\">origin</span> 仓库地址<br></code></pre></td></tr></table></figure>\n<h4 id=\"查看代码贡献量\"><a href=\"#查看代码贡献量\" class=\"headerlink\" title=\"查看代码贡献量\"></a>查看代码贡献量</h4><blockquote>\n<p>按照各个作者的修改代码总数排序</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> --pretty=<span class=\"hljs-string\">&quot;%aN&quot;</span> | <span class=\"hljs-built_in\">sort</span> | <span class=\"hljs-built_in\">uniq</span> -c | <span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> count author; <span class=\"hljs-keyword\">do</span> <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$author</span> &quot;</span>; git <span class=\"hljs-built_in\">log</span> --author=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$author</span>&quot;</span> --pretty=tformat: --numstat | awk <span class=\"hljs-string\">&#x27;&#123; add += $1; subs += $2 &#125; END &#123; total = add + subs; printf &quot;%d\\n&quot;, total &#125;&#x27;</span>; <span class=\"hljs-keyword\">done</span> | <span class=\"hljs-built_in\">sort</span> -rnk2<br></code></pre></td></tr></table></figure>\n","cover_type":"img","excerpt":"","more":"<h4 id=\"怎样撤销一个已经push到远端的版本\"><a href=\"#怎样撤销一个已经push到远端的版本\" class=\"headerlink\" title=\"怎样撤销一个已经push到远端的版本\"></a>怎样撤销一个已经push到远端的版本</h4><figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\">每次<span class=\"hljs-built_in\">push</span>之前线pull一下<br><br><span class=\"hljs-number\">1</span>、查看当前提交的信息，找到需要撤回到的版本号复制，一串十六进制的数<br>git <span class=\"hljs-built_in\">log</span><br><br><span class=\"hljs-number\">2</span>、使用git reset<br>git reset --soft 复制的版本号<br><br><span class=\"hljs-number\">3</span>、强制回退当前版本号<br><span class=\"hljs-comment\">// 确认一下当前版本</span><br>git <span class=\"hljs-built_in\">log</span><br><span class=\"hljs-comment\">// 谨慎使用，强制使用本地仓库代码修改远程仓库</span><br>git <span class=\"hljs-built_in\">push</span> orgin master --force<br></code></pre></td></tr></table></figure>\n<h4 id=\"新建分支并同步到远端的分支\"><a href=\"#新建分支并同步到远端的分支\" class=\"headerlink\" title=\"新建分支并同步到远端的分支\"></a>新建分支并同步到远端的分支</h4><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs mipsasm\"><span class=\"hljs-comment\"># 在本地新建一个名字为branch_name的分支，并与远端的origin/branch_name同步</span><br>git checkout -<span class=\"hljs-keyword\">b </span><span class=\"hljs-keyword\">branch_name </span><span class=\"hljs-keyword\">origin/branch_name</span><br></code></pre></td></tr></table></figure>\n<h4 id=\"解决git-clone超时的问题\"><a href=\"#解决git-clone超时的问题\" class=\"headerlink\" title=\"解决git clone超时的问题\"></a>解决git clone超时的问题</h4><p>从github上clone代码仓库报错<code>Failed to connect to github.com port 443 after 21038 ms: Couldn&#39;t connect to server</code>且尝试去ping一下github官网会丢包</p>\n<img src=\"/2024/01/04/git/image-20231204110955462.png\" class=\"\" title=\"image-20231204110955462\">\n<p>解决方案</p>\n<p>修改系统的hosts，跳过域名解析的过程，直接用ip地址访问</p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs accesslog\"><span class=\"hljs-number\">192.30.255.112</span> github.com git<br><span class=\"hljs-number\">185.31.16.184</span> github.global.ssl.fastly.net<br></code></pre></td></tr></table></figure>\n<img src=\"/2024/01/04/git/image-20231204111125551.png\" class=\"\" title=\"image-20231204111125551\">\n<p>修改hosts需要给文件更高的权限</p>\n<img src=\"/2024/01/04/git/image-20231204111350240.png\" class=\"\" title=\"image-20231204111350240\">\n<h4 id=\"github中git-push出现超时的问题\"><a href=\"#github中git-push出现超时的问题\" class=\"headerlink\" title=\"github中git push出现超时的问题\"></a>github中git push出现超时的问题</h4><img src=\"/2024/01/04/git/image-20231204112945547.png\" class=\"\" title=\"image-20231204112945547\">\n<p>解决方案</p>\n<p>1、打开本机的代理服务器</p>\n<img src=\"/2024/01/04/git/image-20231204113100512.png\" class=\"\" title=\"image-20231204113100512\">\n<p>2、取消git config里面的http和https代理</p>\n<img src=\"/2024/01/04/git/image-20231204113208566.png\" class=\"\" title=\"image-20231204113208566\">\n<p>3、设置http代理服务器</p>\n<img src=\"/2024/01/04/git/image-20231204113304822.png\" class=\"\" title=\"image-20231204113304822\">\n<h4 id=\"linux中输出一个文件夹下面的所有文件名\"><a href=\"#linux中输出一个文件夹下面的所有文件名\" class=\"headerlink\" title=\"linux中输出一个文件夹下面的所有文件名\"></a>linux中输出一个文件夹下面的所有文件名</h4><ul>\n<li><strong><code>/path/to/directory</code></strong>: 替换为目标目录的路径。</li>\n<li><strong><code>-maxdepth 1</code></strong>: 限制<code>find</code>的搜索深度为1，即仅在指定的目录中搜索，而不会搜索其子目录。</li>\n<li><strong><code>-type f</code></strong>: 限制搜索结果为普通文件（不包括目录和其他类型的文件）。</li>\n<li><strong><code>-exec basename &#123;&#125; \\;</code></strong>: 对每一个找到的文件执行<code>basename</code>命令，即输出文件的基本名称。<code>&#123;&#125;</code>是<code>find</code>命令的占位符，表示每个找到的文件的路径。<code>\\;</code>表示命令结束。</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">find /path/to/directory -maxdepth 1 -<span class=\"hljs-built_in\">type</span> f -<span class=\"hljs-built_in\">exec</span> <span class=\"hljs-built_in\">basename</span> &#123;&#125; \\;<br></code></pre></td></tr></table></figure>\n<h4 id=\"git查看远端仓库地址\"><a href=\"#git查看远端仓库地址\" class=\"headerlink\" title=\"git查看远端仓库地址\"></a>git查看远端仓库地址</h4><figure class=\"highlight dsconfig\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dsconfig\"><span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> -<span class=\"hljs-string\">v</span><br><br><span class=\"hljs-comment\"># 更改远程仓库</span><br><span class=\"hljs-string\">git</span> <span class=\"hljs-string\">remote</span> <span class=\"hljs-built_in\">set-url</span> <span class=\"hljs-string\">origin</span> 仓库地址<br></code></pre></td></tr></table></figure>\n<h4 id=\"查看代码贡献量\"><a href=\"#查看代码贡献量\" class=\"headerlink\" title=\"查看代码贡献量\"></a>查看代码贡献量</h4><blockquote>\n<p>按照各个作者的修改代码总数排序</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">git <span class=\"hljs-built_in\">log</span> --pretty=<span class=\"hljs-string\">&quot;%aN&quot;</span> | <span class=\"hljs-built_in\">sort</span> | <span class=\"hljs-built_in\">uniq</span> -c | <span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">read</span> count author; <span class=\"hljs-keyword\">do</span> <span class=\"hljs-built_in\">echo</span> -n <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$author</span> &quot;</span>; git <span class=\"hljs-built_in\">log</span> --author=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$author</span>&quot;</span> --pretty=tformat: --numstat | awk <span class=\"hljs-string\">&#x27;&#123; add += $1; subs += $2 &#125; END &#123; total = add + subs; printf &quot;%d\\n&quot;, total &#125;&#x27;</span>; <span class=\"hljs-keyword\">done</span> | <span class=\"hljs-built_in\">sort</span> -rnk2<br></code></pre></td></tr></table></figure>\n"},{"title":"算法题-数组和字符串","date":"2024-02-09T10:07:22.000Z","cover":"/img/top.jpg","top_img":null,"_content":"### [80.删除有序数组中的重复项 Ⅱ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&envId=top-interview-150)\n\n给你一个有序数组 `nums` ，请你**原地**删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 **原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。\n\n**示例 1：**\n\n```\n输入：nums = [1,1,1,2,2,3]\n输出：5, nums = [1,1,2,2,3]\n解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,1,1,1,1,2,3,3]\n输出：7, nums = [0,0,1,1,2,3,3]\n解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。\n```\n\n\n\n**解析**\n\n使用快fast慢slow指针来遍历数组，慢指针记录数组的长度，快指针记录当前所在的元素是是否需要保留，如果需要保留则将当前位置nums[slow]存放快指针所在的元素，如果不需要保留则需要将fast++\n\n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n\n        int n = nums.size();\n        if(n <= 2){\n            return n;\n        }\n        \n        // 因为前两个元素都是必然回保留的，所以slow和fast都从2开始\n        int slow = 2;\n        int fast = 2;\n        // 使用fast来遍历\n        while(fast < n){\n            // 如果快指针所在的元素不等于当前位置-2所在的元素\n            // 说明，快指针所在的位置的元素的前面至多只有slow - 1位置的元素和其相等，即至多只有一个，所以当前fast所在的位置的元素是需要保留的\n            // 如果相等的话，说明slow-1和slow-2和fast都相等，所以fast是不需要保留的，fast++\n            if(nums[slow - 2] != nums[fast]){\n                nums[slow] = nums[fast];\n                // 更新slow位置\n                ++slow;\n            }\n            ++fast;\n        }\n        return slow;\n    }\n};\n```\n\n\n\n### [122.买股票的最佳时机 Ⅱ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150)\n\n给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n\n返回 *你能获得的 **最大** 利润* 。\n\n**示例 1：**\n\n```\n输入：prices = [7,1,5,3,6,4]\n输出：7\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n     总利润为 4 + 3 = 7 。\n```\n\n**示例 2：**\n\n```\n输入：prices = [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n     总利润为 4 。\n```\n\n**示例 3：**\n\n```\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n```\n\n \n\n**提示：**\n\n- `1 <= prices.length <= 3 * 104`\n- `0 <= prices[i] <= 104`","source":"_posts/leetcode-0209.md","raw":"---\ntitle: 算法题-数组和字符串\ndate: 2024-02-09 18:07:22\ntags: [leetcode 算法 数组 字符串]\ncategories: 算法实践\ncover: /img/top.jpg\ntop_img:\n---\n### [80.删除有序数组中的重复项 Ⅱ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&envId=top-interview-150)\n\n给你一个有序数组 `nums` ，请你**原地**删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。\n\n不要使用额外的数组空间，你必须在 **原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。\n\n**示例 1：**\n\n```\n输入：nums = [1,1,1,2,2,3]\n输出：5, nums = [1,1,2,2,3]\n解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,0,1,1,1,1,2,3,3]\n输出：7, nums = [0,0,1,1,2,3,3]\n解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。\n```\n\n\n\n**解析**\n\n使用快fast慢slow指针来遍历数组，慢指针记录数组的长度，快指针记录当前所在的元素是是否需要保留，如果需要保留则将当前位置nums[slow]存放快指针所在的元素，如果不需要保留则需要将fast++\n\n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n\n        int n = nums.size();\n        if(n <= 2){\n            return n;\n        }\n        \n        // 因为前两个元素都是必然回保留的，所以slow和fast都从2开始\n        int slow = 2;\n        int fast = 2;\n        // 使用fast来遍历\n        while(fast < n){\n            // 如果快指针所在的元素不等于当前位置-2所在的元素\n            // 说明，快指针所在的位置的元素的前面至多只有slow - 1位置的元素和其相等，即至多只有一个，所以当前fast所在的位置的元素是需要保留的\n            // 如果相等的话，说明slow-1和slow-2和fast都相等，所以fast是不需要保留的，fast++\n            if(nums[slow - 2] != nums[fast]){\n                nums[slow] = nums[fast];\n                // 更新slow位置\n                ++slow;\n            }\n            ++fast;\n        }\n        return slow;\n    }\n};\n```\n\n\n\n### [122.买股票的最佳时机 Ⅱ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&envId=top-interview-150)\n\n给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n\n返回 *你能获得的 **最大** 利润* 。\n\n**示例 1：**\n\n```\n输入：prices = [7,1,5,3,6,4]\n输出：7\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。\n     总利润为 4 + 3 = 7 。\n```\n\n**示例 2：**\n\n```\n输入：prices = [1,2,3,4,5]\n输出：4\n解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。\n     总利润为 4 。\n```\n\n**示例 3：**\n\n```\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n```\n\n \n\n**提示：**\n\n- `1 <= prices.length <= 3 * 104`\n- `0 <= prices[i] <= 104`","slug":"leetcode-0209","published":1,"updated":"2024-02-20T06:58:14.396Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xs000cg4c26mlshfag","content":"<h3 id=\"80-删除有序数组中的重复项-Ⅱ\"><a href=\"#80-删除有序数组中的重复项-Ⅱ\" class=\"headerlink\" title=\"80.删除有序数组中的重复项 Ⅱ\"></a><a href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&amp;envId=top-interview-150\">80.删除有序数组中的重复项 Ⅱ</a></h3><p>给你一个有序数组 <code>nums</code> ，请你<strong>原地</strong>删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs accesslog\">输入：nums = <span class=\"hljs-string\">[1,1,1,2,2,3]</span><br>输出：<span class=\"hljs-number\">5</span>, nums = <span class=\"hljs-string\">[1,1,2,2,3]</span><br>解释：函数应返回新长度 length = <span class=\"hljs-number\">5</span>, 并且原数组的前五个元素被修改为 <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>。 不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">输入：nums = [<span class=\"hljs-number\">0,0,1,1</span>,<span class=\"hljs-number\">1,1,2,3</span>,<span class=\"hljs-number\">3</span>]<br>输出：<span class=\"hljs-number\">7</span>, nums = [<span class=\"hljs-number\">0,0,1,1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">3</span>]<br>解释：函数应返回新长度 length = <span class=\"hljs-number\">7</span>, 并且原数组的前七个元素被修改为 <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>\n<p><strong>解析</strong></p>\n<p>使用快fast慢slow指针来遍历数组，慢指针记录数组的长度，快指针记录当前所在的元素是是否需要保留，如果需要保留则将当前位置nums[slow]存放快指针所在的元素，如果不需要保留则需要将fast++</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">if</span>(n &lt;= <span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> n;<br>        &#125;<br>        <br>        <span class=\"hljs-comment\">// 因为前两个元素都是必然回保留的，所以slow和fast都从2开始</span><br>        <span class=\"hljs-type\">int</span> slow = <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-type\">int</span> fast = <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-comment\">// 使用fast来遍历</span><br>        <span class=\"hljs-keyword\">while</span>(fast &lt; n)&#123;<br>            <span class=\"hljs-comment\">// 如果快指针所在的元素不等于当前位置-2所在的元素</span><br>            <span class=\"hljs-comment\">// 说明，快指针所在的位置的元素的前面至多只有slow - 1位置的元素和其相等，即至多只有一个，所以当前fast所在的位置的元素是需要保留的</span><br>            <span class=\"hljs-comment\">// 如果相等的话，说明slow-1和slow-2和fast都相等，所以fast是不需要保留的，fast++</span><br>            <span class=\"hljs-keyword\">if</span>(nums[slow - <span class=\"hljs-number\">2</span>] != nums[fast])&#123;<br>                nums[slow] = nums[fast];<br>                <span class=\"hljs-comment\">// 更新slow位置</span><br>                ++slow;<br>            &#125;<br>            ++fast;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"122-买股票的最佳时机-Ⅱ\"><a href=\"#122-买股票的最佳时机-Ⅱ\" class=\"headerlink\" title=\"122.买股票的最佳时机 Ⅱ\"></a><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150\">122.买股票的最佳时机 Ⅱ</a></h3><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>\n<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>\n<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class=\"hljs-number\"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class=\"hljs-number\"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class=\"hljs-number\"> 5 </span>-<span class=\"hljs-number\"> 1 </span>=<span class=\"hljs-number\"> 4 </span>。<br>     随后，在第<span class=\"hljs-number\"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class=\"hljs-number\"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class=\"hljs-number\"> 6 </span>-<span class=\"hljs-number\"> 3 </span>=<span class=\"hljs-number\"> 3 </span>。<br>     总利润为<span class=\"hljs-number\"> 4 </span>+<span class=\"hljs-number\"> 3 </span>=<span class=\"hljs-number\"> 7 </span>。<br></code></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class=\"hljs-number\"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class=\"hljs-number\"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class=\"hljs-number\"> 5 </span>-<span class=\"hljs-number\"> 1 </span>=<span class=\"hljs-number\"> 4 </span>。<br>     总利润为<span class=\"hljs-number\"> 4 </span>。<br></code></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs accesslog\">输入：prices = <span class=\"hljs-string\">[7,6,4,3,1]</span><br>输出：<span class=\"hljs-number\">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class=\"hljs-number\">0</span> 。<br></code></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= prices[i] &lt;= 104</code></li>\n</ul>\n","cover_type":"img","excerpt":"","more":"<h3 id=\"80-删除有序数组中的重复项-Ⅱ\"><a href=\"#80-删除有序数组中的重复项-Ⅱ\" class=\"headerlink\" title=\"80.删除有序数组中的重复项 Ⅱ\"></a><a href=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/?envType=study-plan-v2&amp;envId=top-interview-150\">80.删除有序数组中的重复项 Ⅱ</a></h3><p>给你一个有序数组 <code>nums</code> ，请你<strong>原地</strong>删除重复出现的元素，使得出现次数超过两次的元素<strong>只出现两次</strong> ，返回删除后数组的新长度。</p>\n<p>不要使用额外的数组空间，你必须在 <strong>原地修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs accesslog\">输入：nums = <span class=\"hljs-string\">[1,1,1,2,2,3]</span><br>输出：<span class=\"hljs-number\">5</span>, nums = <span class=\"hljs-string\">[1,1,2,2,3]</span><br>解释：函数应返回新长度 length = <span class=\"hljs-number\">5</span>, 并且原数组的前五个元素被修改为 <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>。 不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">输入：nums = [<span class=\"hljs-number\">0,0,1,1</span>,<span class=\"hljs-number\">1,1,2,3</span>,<span class=\"hljs-number\">3</span>]<br>输出：<span class=\"hljs-number\">7</span>, nums = [<span class=\"hljs-number\">0,0,1,1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">3</span>]<br>解释：函数应返回新长度 length = <span class=\"hljs-number\">7</span>, 并且原数组的前七个元素被修改为 <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure>\n<p><strong>解析</strong></p>\n<p>使用快fast慢slow指针来遍历数组，慢指针记录数组的长度，快指针记录当前所在的元素是是否需要保留，如果需要保留则将当前位置nums[slow]存放快指针所在的元素，如果不需要保留则需要将fast++</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Solution</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">removeDuplicates</span><span class=\"hljs-params\">(vector&lt;<span class=\"hljs-type\">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class=\"hljs-type\">int</span> n = nums.<span class=\"hljs-built_in\">size</span>();<br>        <span class=\"hljs-keyword\">if</span>(n &lt;= <span class=\"hljs-number\">2</span>)&#123;<br>            <span class=\"hljs-keyword\">return</span> n;<br>        &#125;<br>        <br>        <span class=\"hljs-comment\">// 因为前两个元素都是必然回保留的，所以slow和fast都从2开始</span><br>        <span class=\"hljs-type\">int</span> slow = <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-type\">int</span> fast = <span class=\"hljs-number\">2</span>;<br>        <span class=\"hljs-comment\">// 使用fast来遍历</span><br>        <span class=\"hljs-keyword\">while</span>(fast &lt; n)&#123;<br>            <span class=\"hljs-comment\">// 如果快指针所在的元素不等于当前位置-2所在的元素</span><br>            <span class=\"hljs-comment\">// 说明，快指针所在的位置的元素的前面至多只有slow - 1位置的元素和其相等，即至多只有一个，所以当前fast所在的位置的元素是需要保留的</span><br>            <span class=\"hljs-comment\">// 如果相等的话，说明slow-1和slow-2和fast都相等，所以fast是不需要保留的，fast++</span><br>            <span class=\"hljs-keyword\">if</span>(nums[slow - <span class=\"hljs-number\">2</span>] != nums[fast])&#123;<br>                nums[slow] = nums[fast];<br>                <span class=\"hljs-comment\">// 更新slow位置</span><br>                ++slow;<br>            &#125;<br>            ++fast;<br>        &#125;<br>        <span class=\"hljs-keyword\">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h3 id=\"122-买股票的最佳时机-Ⅱ\"><a href=\"#122-买股票的最佳时机-Ⅱ\" class=\"headerlink\" title=\"122.买股票的最佳时机 Ⅱ\"></a><a href=\"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150\">122.买股票的最佳时机 Ⅱ</a></h3><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>\n<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>\n<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">输入：prices = [7,1,5,3,6,4]<br>输出：7<br>解释：在第<span class=\"hljs-number\"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class=\"hljs-number\"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class=\"hljs-number\"> 5 </span>-<span class=\"hljs-number\"> 1 </span>=<span class=\"hljs-number\"> 4 </span>。<br>     随后，在第<span class=\"hljs-number\"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class=\"hljs-number\"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 =<span class=\"hljs-number\"> 6 </span>-<span class=\"hljs-number\"> 3 </span>=<span class=\"hljs-number\"> 3 </span>。<br>     总利润为<span class=\"hljs-number\"> 4 </span>+<span class=\"hljs-number\"> 3 </span>=<span class=\"hljs-number\"> 7 </span>。<br></code></pre></td></tr></table></figure>\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight tap\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs tap\">输入：prices = [1,2,3,4,5]<br>输出：4<br>解释：在第<span class=\"hljs-number\"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class=\"hljs-number\"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 =<span class=\"hljs-number\"> 5 </span>-<span class=\"hljs-number\"> 1 </span>=<span class=\"hljs-number\"> 4 </span>。<br>     总利润为<span class=\"hljs-number\"> 4 </span>。<br></code></pre></td></tr></table></figure>\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs accesslog\">输入：prices = <span class=\"hljs-string\">[7,6,4,3,1]</span><br>输出：<span class=\"hljs-number\">0</span><br>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 <span class=\"hljs-number\">0</span> 。<br></code></pre></td></tr></table></figure>\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= prices.length &lt;= 3 * 104</code></li>\n<li><code>0 &lt;= prices[i] &lt;= 104</code></li>\n</ul>\n"},{"title":"大话设计模式","date":"2024-02-20T07:09:00.000Z","cover":"/img/default_cover04.jpg","top_img":null,"_content":"## 一、简单工厂模式\n\n> 注意：命名规范、多个分支使用switch、考虑异常情况\n\n面向对象的编程，对代码做到：可维护、可复用、灵活性好\n\n* 业务的封装\n\n  前后端分离，将业务逻辑和界面逻辑分开，让他们之间的耦合度下降，可以依赖面向对象的三大特性来实现\n\n* 工厂模式\n\n  通过工厂类，传入不同的字符串来返回不同继承类的构造函数，需要实例哪一个子类，可以通过传入参数来进行选择\n\n  可以使用switch，或者使用map映射等方式\n\n* UML类图\n\n  * 依赖关系\n  * 聚合关系\n  * 合成关系\n  * 继承关系\n  * 关联关系\n  * 接口关系\n  * 泛化关系\n\n![image-20231008153018253](大话设计模式/image-20231008153018253.png)\n\n## 二、策略模式\n\n> 策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的用户。\n\n只有算法需要替换，而其它不需要替换\n\n使用策略类，定义所有支持算法的公共接口\n\n* 策略模式是一种定义一系列算法的方法，所有这些算法完成的是相同的工作，但是实现不同，可以以相同的方式调用所有的方法，减少了各种算法类与使用算法类之间的耦合\n* 策略模式的优点可以简化单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试\n\n```\n策略模式的三个要点\n1、基类，策略接口，用于子类继承该基类，并重写基类中的策略方法\n2、具体的策略类，不同的策略类使用不同的方法来实现基类的虚方法\n3、上下文，context，在上下文中，通过一个公共的方法，来调用不同子类实现的虚方法（使用传入不同子类对象来实现）\n\n用户只需要使用context来使用不同对象传入即可以完成不同的策略选择\n```\n\n## 三、单一职责原则\n\n> 对于一个类而言，应该仅有一个引起它变化的原因。\n>\n> 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。\n\n## 四、开放-封闭原则\n\n**软件实体（类、模块、函数等）应该可以扩展但不可修改，即对拓展开放，对修改封闭**\n\n##  五、依赖倒置原则\n\n1、高层模块不应该依赖底层模块，两个都应该依赖抽象\n\n2、抽象不应该依赖细节，细节应该依赖抽象\n\n* 里氏代换原则\n\n  一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。\n\n  即：子类型必须能够替换掉它们的父类型\n\n```\n和策略模式有一定的相似之处，例子\n\nDevice类\nclass Device:\n    def turn_on(self):\n        pass\n\n    def turn_off(self):\n        pass\n\n子类\nclass Light(Device):\n    def turn_on(self):\n        print(\"Light is turned on\")\n\n    def turn_off(self):\n        print(\"Light is turned off\")\n\nclass Fan(Device):\n    def turn_on(self):\n        print(\"Fan is turned on\")\n\n    def turn_off(self):\n        print(\"Fan is turned off\")\n\nclass Speaker(Device):\n    def turn_on(self):\n        print(\"Speaker is turned on\")\n\n    def turn_off(self):\n        print(\"Speaker is turned off\")\n\n高层模块\nclass DeviceController:\n    def __init__(self, device):\n        self.device = device\n\n    def operate(self):\n        self.device.turn_on()\n\n    def stop(self):\n        self.device.turn_off()\n\nmain\nif __name__ == \"__main__\":\n    light = Light()\n    fan = Fan()\n    speaker = Speaker()\n\n    controller1 = DeviceController(light)\n    controller2 = DeviceController(fan)\n    controller3 = DeviceController(speaker)\n\n    controller1.operate()\n    controller2.operate()\n    controller3.operate()\n\n    controller1.stop()\n    controller2.stop()\n    controller3.stop()\n高层模块 DeviceController 不直接依赖于具体的设备类（如 Light、Fan 和 Speaker），而是依赖于抽象的 Device 接口。这就是依赖倒置原则的应用，它使得高层模块更加灵活，可以轻松地切换和扩展不同类型的设备，而不需要修改高层模块的代码。这有助于创建松耦合的、易于维护和扩展的代码\n```\n\n\n\n## 六、装饰模式\n\n**动态地给一个对象添加一些额外的职责**，就增加功能来说，装饰模式比生成子类更为灵活\n\n在子类中定义一个父类对象，该对象使用需要装饰的对象作为初始化，并在子类中对该对象进行操作，即可达到，对对象的额外装饰结果，但是这一个对象和之前的对象不一定是同一个对象。\n\n* 基本结构\n\n```\n1、父类：父类定义一个抽象的方法\n2、子类：子类继承父类抽象方法并添加一些最基本的属性\n3、装饰器类：装饰器类继承父类，并定义一个父类的保护类型数据\n4、不同的装饰器类：不同的装饰器类继承于装饰器类，重写各自装饰器需要添加的职责\n\n通常第“2”步中定义基本属性的子类，会作为第一层装饰包装子类，后续会作为参数传入到装饰器类中\n```\n\n装饰模式可以把类中的装饰功能从类中搬移去除，这样就可以简化原有的类。同事有效地把类的核心职责和装饰功能区分开，去除相关类中的重复的装饰逻辑，重复的装饰逻辑可以使用一个子类作为最基类型。\n\n```\nexp：\n游戏中，不同人物角色使用不同技能进行装饰。最开始都是有一个人物的基类（低级的时候）。公共技能可以作为重复逻辑继承在一个类中，使用装饰模式，可以学习一些不同的技能。\n```\n\n## 七、代理模式\n\n代理模式，为其它对象提供一种代理以控制对这个对象的访问\n\n在客户与另一客户交互的过程中，中间会有一层代理，代理可以拥有两个客户的接口，作为中间实体来进行来促使两客户进行交互，在代理中如果需要交互，则需要定义一个客户的类，来调用该客户的方法。\n\n* 代理模式应用场景\n\n  远程代理：为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实\n\n  虚拟代理：根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，浏览器中加载图片就是使用虚拟代理\n\n  安全代理：用来控制真实对象访问时的权限\n\n  智能指引：当掉哟个真实对象时，代理处理另外一些事\n\n## 八、工厂方法模式\n\n封装实例来创建过程，可以让创建实例的过程封装到工厂类中，避免耦合\n\n\n\n\n## 九、原型模式\n\n用原型（Prototype）实例指定创建对象的种类，并且通过复制这些原型创建新的对象\n\n* 用法\n\n  在类里面定义一个函数，函数可以返回一个原型对象\n\n* 在类中定义修改原型中属性的set方法\n\n* 在使用的过程中，只需要调用set方法修改不同的地方\n\n深拷贝与浅拷贝，若在原型类中使用对象引用，在修改的时候记得使用深拷贝\n\n\n\n## 十、模板方法模式\n\n定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤\n\n\n\n## 十一、迪米特法则\n\n> 最小知识原则\n\n如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。","source":"_posts/大话设计模式.md","raw":"---\ntitle: 大话设计模式\ndate: 2024-02-20 15:09:00\ntags: [设计模式 UML]\ncategories: 学习笔记\ncover:\ntop_img:\n---\n## 一、简单工厂模式\n\n> 注意：命名规范、多个分支使用switch、考虑异常情况\n\n面向对象的编程，对代码做到：可维护、可复用、灵活性好\n\n* 业务的封装\n\n  前后端分离，将业务逻辑和界面逻辑分开，让他们之间的耦合度下降，可以依赖面向对象的三大特性来实现\n\n* 工厂模式\n\n  通过工厂类，传入不同的字符串来返回不同继承类的构造函数，需要实例哪一个子类，可以通过传入参数来进行选择\n\n  可以使用switch，或者使用map映射等方式\n\n* UML类图\n\n  * 依赖关系\n  * 聚合关系\n  * 合成关系\n  * 继承关系\n  * 关联关系\n  * 接口关系\n  * 泛化关系\n\n![image-20231008153018253](大话设计模式/image-20231008153018253.png)\n\n## 二、策略模式\n\n> 策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的用户。\n\n只有算法需要替换，而其它不需要替换\n\n使用策略类，定义所有支持算法的公共接口\n\n* 策略模式是一种定义一系列算法的方法，所有这些算法完成的是相同的工作，但是实现不同，可以以相同的方式调用所有的方法，减少了各种算法类与使用算法类之间的耦合\n* 策略模式的优点可以简化单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试\n\n```\n策略模式的三个要点\n1、基类，策略接口，用于子类继承该基类，并重写基类中的策略方法\n2、具体的策略类，不同的策略类使用不同的方法来实现基类的虚方法\n3、上下文，context，在上下文中，通过一个公共的方法，来调用不同子类实现的虚方法（使用传入不同子类对象来实现）\n\n用户只需要使用context来使用不同对象传入即可以完成不同的策略选择\n```\n\n## 三、单一职责原则\n\n> 对于一个类而言，应该仅有一个引起它变化的原因。\n>\n> 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。\n\n## 四、开放-封闭原则\n\n**软件实体（类、模块、函数等）应该可以扩展但不可修改，即对拓展开放，对修改封闭**\n\n##  五、依赖倒置原则\n\n1、高层模块不应该依赖底层模块，两个都应该依赖抽象\n\n2、抽象不应该依赖细节，细节应该依赖抽象\n\n* 里氏代换原则\n\n  一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。\n\n  即：子类型必须能够替换掉它们的父类型\n\n```\n和策略模式有一定的相似之处，例子\n\nDevice类\nclass Device:\n    def turn_on(self):\n        pass\n\n    def turn_off(self):\n        pass\n\n子类\nclass Light(Device):\n    def turn_on(self):\n        print(\"Light is turned on\")\n\n    def turn_off(self):\n        print(\"Light is turned off\")\n\nclass Fan(Device):\n    def turn_on(self):\n        print(\"Fan is turned on\")\n\n    def turn_off(self):\n        print(\"Fan is turned off\")\n\nclass Speaker(Device):\n    def turn_on(self):\n        print(\"Speaker is turned on\")\n\n    def turn_off(self):\n        print(\"Speaker is turned off\")\n\n高层模块\nclass DeviceController:\n    def __init__(self, device):\n        self.device = device\n\n    def operate(self):\n        self.device.turn_on()\n\n    def stop(self):\n        self.device.turn_off()\n\nmain\nif __name__ == \"__main__\":\n    light = Light()\n    fan = Fan()\n    speaker = Speaker()\n\n    controller1 = DeviceController(light)\n    controller2 = DeviceController(fan)\n    controller3 = DeviceController(speaker)\n\n    controller1.operate()\n    controller2.operate()\n    controller3.operate()\n\n    controller1.stop()\n    controller2.stop()\n    controller3.stop()\n高层模块 DeviceController 不直接依赖于具体的设备类（如 Light、Fan 和 Speaker），而是依赖于抽象的 Device 接口。这就是依赖倒置原则的应用，它使得高层模块更加灵活，可以轻松地切换和扩展不同类型的设备，而不需要修改高层模块的代码。这有助于创建松耦合的、易于维护和扩展的代码\n```\n\n\n\n## 六、装饰模式\n\n**动态地给一个对象添加一些额外的职责**，就增加功能来说，装饰模式比生成子类更为灵活\n\n在子类中定义一个父类对象，该对象使用需要装饰的对象作为初始化，并在子类中对该对象进行操作，即可达到，对对象的额外装饰结果，但是这一个对象和之前的对象不一定是同一个对象。\n\n* 基本结构\n\n```\n1、父类：父类定义一个抽象的方法\n2、子类：子类继承父类抽象方法并添加一些最基本的属性\n3、装饰器类：装饰器类继承父类，并定义一个父类的保护类型数据\n4、不同的装饰器类：不同的装饰器类继承于装饰器类，重写各自装饰器需要添加的职责\n\n通常第“2”步中定义基本属性的子类，会作为第一层装饰包装子类，后续会作为参数传入到装饰器类中\n```\n\n装饰模式可以把类中的装饰功能从类中搬移去除，这样就可以简化原有的类。同事有效地把类的核心职责和装饰功能区分开，去除相关类中的重复的装饰逻辑，重复的装饰逻辑可以使用一个子类作为最基类型。\n\n```\nexp：\n游戏中，不同人物角色使用不同技能进行装饰。最开始都是有一个人物的基类（低级的时候）。公共技能可以作为重复逻辑继承在一个类中，使用装饰模式，可以学习一些不同的技能。\n```\n\n## 七、代理模式\n\n代理模式，为其它对象提供一种代理以控制对这个对象的访问\n\n在客户与另一客户交互的过程中，中间会有一层代理，代理可以拥有两个客户的接口，作为中间实体来进行来促使两客户进行交互，在代理中如果需要交互，则需要定义一个客户的类，来调用该客户的方法。\n\n* 代理模式应用场景\n\n  远程代理：为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实\n\n  虚拟代理：根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，浏览器中加载图片就是使用虚拟代理\n\n  安全代理：用来控制真实对象访问时的权限\n\n  智能指引：当掉哟个真实对象时，代理处理另外一些事\n\n## 八、工厂方法模式\n\n封装实例来创建过程，可以让创建实例的过程封装到工厂类中，避免耦合\n\n\n\n\n## 九、原型模式\n\n用原型（Prototype）实例指定创建对象的种类，并且通过复制这些原型创建新的对象\n\n* 用法\n\n  在类里面定义一个函数，函数可以返回一个原型对象\n\n* 在类中定义修改原型中属性的set方法\n\n* 在使用的过程中，只需要调用set方法修改不同的地方\n\n深拷贝与浅拷贝，若在原型类中使用对象引用，在修改的时候记得使用深拷贝\n\n\n\n## 十、模板方法模式\n\n定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤\n\n\n\n## 十一、迪米特法则\n\n> 最小知识原则\n\n如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。","slug":"大话设计模式","published":1,"updated":"2024-02-20T07:14:08.993Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xt000fg4c25wi48691","content":"<h2 id=\"一、简单工厂模式\"><a href=\"#一、简单工厂模式\" class=\"headerlink\" title=\"一、简单工厂模式\"></a>一、简单工厂模式</h2><blockquote>\n<p>注意：命名规范、多个分支使用switch、考虑异常情况</p>\n</blockquote>\n<p>面向对象的编程，对代码做到：可维护、可复用、灵活性好</p>\n<ul>\n<li><p>业务的封装</p>\n<p>前后端分离，将业务逻辑和界面逻辑分开，让他们之间的耦合度下降，可以依赖面向对象的三大特性来实现</p>\n</li>\n<li><p>工厂模式</p>\n<p>通过工厂类，传入不同的字符串来返回不同继承类的构造函数，需要实例哪一个子类，可以通过传入参数来进行选择</p>\n<p>可以使用switch，或者使用map映射等方式</p>\n</li>\n<li><p>UML类图</p>\n<ul>\n<li>依赖关系</li>\n<li>聚合关系</li>\n<li>合成关系</li>\n<li>继承关系</li>\n<li>关联关系</li>\n<li>接口关系</li>\n<li>泛化关系</li>\n</ul>\n</li>\n</ul>\n<img src=\"/2024/02/20/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231008153018253.png\" class=\"\" title=\"image-20231008153018253\">\n<h2 id=\"二、策略模式\"><a href=\"#二、策略模式\" class=\"headerlink\" title=\"二、策略模式\"></a>二、策略模式</h2><blockquote>\n<p>策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的用户。</p>\n</blockquote>\n<p>只有算法需要替换，而其它不需要替换</p>\n<p>使用策略类，定义所有支持算法的公共接口</p>\n<ul>\n<li>策略模式是一种定义一系列算法的方法，所有这些算法完成的是相同的工作，但是实现不同，可以以相同的方式调用所有的方法，减少了各种算法类与使用算法类之间的耦合</li>\n<li>策略模式的优点可以简化单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试</li>\n</ul>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">策略模式的三个要点<br><span class=\"hljs-number\">1</span>、基类，策略接口，用于子类继承该基类，并重写基类中的策略方法<br><span class=\"hljs-number\">2</span>、具体的策略类，不同的策略类使用不同的方法来实现基类的虚方法<br><span class=\"hljs-number\">3</span>、上下文，<span class=\"hljs-built_in\">context</span>，在上下文中，通过一个公共的方法，来调用不同子类实现的虚方法（使用传入不同子类对象来实现）<br><br>用户只需要使用<span class=\"hljs-built_in\">context</span>来使用不同对象传入即可以完成不同的策略选择<br></code></pre></td></tr></table></figure>\n<h2 id=\"三、单一职责原则\"><a href=\"#三、单一职责原则\" class=\"headerlink\" title=\"三、单一职责原则\"></a>三、单一职责原则</h2><blockquote>\n<p>对于一个类而言，应该仅有一个引起它变化的原因。</p>\n<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。</p>\n</blockquote>\n<h2 id=\"四、开放-封闭原则\"><a href=\"#四、开放-封闭原则\" class=\"headerlink\" title=\"四、开放-封闭原则\"></a>四、开放-封闭原则</h2><p><strong>软件实体（类、模块、函数等）应该可以扩展但不可修改，即对拓展开放，对修改封闭</strong></p>\n<h2 id=\"五、依赖倒置原则\"><a href=\"#五、依赖倒置原则\" class=\"headerlink\" title=\"五、依赖倒置原则\"></a>五、依赖倒置原则</h2><p>1、高层模块不应该依赖底层模块，两个都应该依赖抽象</p>\n<p>2、抽象不应该依赖细节，细节应该依赖抽象</p>\n<ul>\n<li><p>里氏代换原则</p>\n<p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。</p>\n<p>即：子类型必须能够替换掉它们的父类型</p>\n</li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">和策略模式有一定的相似之处，例子<br><br><span class=\"hljs-title class_\">Device</span>类<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Device</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_on</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        pass<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_off</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        pass<br><br>子类<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Light</span>(<span class=\"hljs-title class_\">Device</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_on</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Light is turned on&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_off</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Light is turned off&quot;</span>)<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fan</span>(<span class=\"hljs-title class_\">Device</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_on</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Fan is turned on&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_off</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Fan is turned off&quot;</span>)<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Speaker</span>(<span class=\"hljs-title class_\">Device</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_on</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Speaker is turned on&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_off</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Speaker is turned off&quot;</span>)<br><br>高层模块<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceController</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, device</span>):<br>        <span class=\"hljs-variable language_\">self</span>.device = device<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">operate</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        <span class=\"hljs-variable language_\">self</span>.device.turn_on()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">stop</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        <span class=\"hljs-variable language_\">self</span>.device.turn_off()<br><br>main<br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    light = <span class=\"hljs-title class_\">Light</span>()<br>    fan = <span class=\"hljs-title class_\">Fan</span>()<br>    speaker = <span class=\"hljs-title class_\">Speaker</span>()<br><br>    controller1 = <span class=\"hljs-title class_\">DeviceController</span>(light)<br>    controller2 = <span class=\"hljs-title class_\">DeviceController</span>(fan)<br>    controller3 = <span class=\"hljs-title class_\">DeviceController</span>(speaker)<br><br>    controller1.operate()<br>    controller2.operate()<br>    controller3.operate()<br><br>    controller1.stop()<br>    controller2.stop()<br>    controller3.stop()<br>高层模块 <span class=\"hljs-title class_\">DeviceController</span> 不直接依赖于具体的设备类（如 <span class=\"hljs-title class_\">Light</span>、<span class=\"hljs-title class_\">Fan</span> 和 <span class=\"hljs-title class_\">Speaker</span>），而是依赖于抽象的 <span class=\"hljs-title class_\">Device</span> 接口。这就是依赖倒置原则的应用，它使得高层模块更加灵活，可以轻松地切换和扩展不同类型的设备，而不需要修改高层模块的代码。这有助于创建松耦合的、易于维护和扩展的代码<br></code></pre></td></tr></table></figure>\n<h2 id=\"六、装饰模式\"><a href=\"#六、装饰模式\" class=\"headerlink\" title=\"六、装饰模式\"></a>六、装饰模式</h2><p><strong>动态地给一个对象添加一些额外的职责</strong>，就增加功能来说，装饰模式比生成子类更为灵活</p>\n<p>在子类中定义一个父类对象，该对象使用需要装饰的对象作为初始化，并在子类中对该对象进行操作，即可达到，对对象的额外装饰结果，但是这一个对象和之前的对象不一定是同一个对象。</p>\n<ul>\n<li>基本结构</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">1、父类：父类定义一个抽象的方法<br>2、子类：子类继承父类抽象方法并添加一些最基本的属性<br>3、装饰器类：装饰器类继承父类，并定义一个父类的保护类型数据<br>4、不同的装饰器类：不同的装饰器类继承于装饰器类，重写各自装饰器需要添加的职责<br><br>通常第“2”步中定义基本属性的子类，会作为第一层装饰包装子类，后续会作为参数传入到装饰器类中<br></code></pre></td></tr></table></figure>\n<p>装饰模式可以把类中的装饰功能从类中搬移去除，这样就可以简化原有的类。同事有效地把类的核心职责和装饰功能区分开，去除相关类中的重复的装饰逻辑，重复的装饰逻辑可以使用一个子类作为最基类型。</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-built_in\">exp</span>：<br>游戏中，不同人物角色使用不同技能进行装饰。最开始都是有一个人物的基类（低级的时候）。公共技能可以作为重复逻辑继承在一个类中，使用装饰模式，可以学习一些不同的技能。<br></code></pre></td></tr></table></figure>\n<h2 id=\"七、代理模式\"><a href=\"#七、代理模式\" class=\"headerlink\" title=\"七、代理模式\"></a>七、代理模式</h2><p>代理模式，为其它对象提供一种代理以控制对这个对象的访问</p>\n<p>在客户与另一客户交互的过程中，中间会有一层代理，代理可以拥有两个客户的接口，作为中间实体来进行来促使两客户进行交互，在代理中如果需要交互，则需要定义一个客户的类，来调用该客户的方法。</p>\n<ul>\n<li><p>代理模式应用场景</p>\n<p>远程代理：为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实</p>\n<p>虚拟代理：根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，浏览器中加载图片就是使用虚拟代理</p>\n<p>安全代理：用来控制真实对象访问时的权限</p>\n<p>智能指引：当掉哟个真实对象时，代理处理另外一些事</p>\n</li>\n</ul>\n<h2 id=\"八、工厂方法模式\"><a href=\"#八、工厂方法模式\" class=\"headerlink\" title=\"八、工厂方法模式\"></a>八、工厂方法模式</h2><p>封装实例来创建过程，可以让创建实例的过程封装到工厂类中，避免耦合</p>\n<h2 id=\"九、原型模式\"><a href=\"#九、原型模式\" class=\"headerlink\" title=\"九、原型模式\"></a>九、原型模式</h2><p>用原型（Prototype）实例指定创建对象的种类，并且通过复制这些原型创建新的对象</p>\n<ul>\n<li><p>用法</p>\n<p>在类里面定义一个函数，函数可以返回一个原型对象</p>\n</li>\n<li><p>在类中定义修改原型中属性的set方法</p>\n</li>\n<li><p>在使用的过程中，只需要调用set方法修改不同的地方</p>\n</li>\n</ul>\n<p>深拷贝与浅拷贝，若在原型类中使用对象引用，在修改的时候记得使用深拷贝</p>\n<h2 id=\"十、模板方法模式\"><a href=\"#十、模板方法模式\" class=\"headerlink\" title=\"十、模板方法模式\"></a>十、模板方法模式</h2><p>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>\n<h2 id=\"十一、迪米特法则\"><a href=\"#十一、迪米特法则\" class=\"headerlink\" title=\"十一、迪米特法则\"></a>十一、迪米特法则</h2><blockquote>\n<p>最小知识原则</p>\n</blockquote>\n<p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>\n","cover_type":"img","excerpt":"","more":"<h2 id=\"一、简单工厂模式\"><a href=\"#一、简单工厂模式\" class=\"headerlink\" title=\"一、简单工厂模式\"></a>一、简单工厂模式</h2><blockquote>\n<p>注意：命名规范、多个分支使用switch、考虑异常情况</p>\n</blockquote>\n<p>面向对象的编程，对代码做到：可维护、可复用、灵活性好</p>\n<ul>\n<li><p>业务的封装</p>\n<p>前后端分离，将业务逻辑和界面逻辑分开，让他们之间的耦合度下降，可以依赖面向对象的三大特性来实现</p>\n</li>\n<li><p>工厂模式</p>\n<p>通过工厂类，传入不同的字符串来返回不同继承类的构造函数，需要实例哪一个子类，可以通过传入参数来进行选择</p>\n<p>可以使用switch，或者使用map映射等方式</p>\n</li>\n<li><p>UML类图</p>\n<ul>\n<li>依赖关系</li>\n<li>聚合关系</li>\n<li>合成关系</li>\n<li>继承关系</li>\n<li>关联关系</li>\n<li>接口关系</li>\n<li>泛化关系</li>\n</ul>\n</li>\n</ul>\n<img src=\"/2024/02/20/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20231008153018253.png\" class=\"\" title=\"image-20231008153018253\">\n<h2 id=\"二、策略模式\"><a href=\"#二、策略模式\" class=\"headerlink\" title=\"二、策略模式\"></a>二、策略模式</h2><blockquote>\n<p>策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的用户。</p>\n</blockquote>\n<p>只有算法需要替换，而其它不需要替换</p>\n<p>使用策略类，定义所有支持算法的公共接口</p>\n<ul>\n<li>策略模式是一种定义一系列算法的方法，所有这些算法完成的是相同的工作，但是实现不同，可以以相同的方式调用所有的方法，减少了各种算法类与使用算法类之间的耦合</li>\n<li>策略模式的优点可以简化单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试</li>\n</ul>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs maxima\">策略模式的三个要点<br><span class=\"hljs-number\">1</span>、基类，策略接口，用于子类继承该基类，并重写基类中的策略方法<br><span class=\"hljs-number\">2</span>、具体的策略类，不同的策略类使用不同的方法来实现基类的虚方法<br><span class=\"hljs-number\">3</span>、上下文，<span class=\"hljs-built_in\">context</span>，在上下文中，通过一个公共的方法，来调用不同子类实现的虚方法（使用传入不同子类对象来实现）<br><br>用户只需要使用<span class=\"hljs-built_in\">context</span>来使用不同对象传入即可以完成不同的策略选择<br></code></pre></td></tr></table></figure>\n<h2 id=\"三、单一职责原则\"><a href=\"#三、单一职责原则\" class=\"headerlink\" title=\"三、单一职责原则\"></a>三、单一职责原则</h2><blockquote>\n<p>对于一个类而言，应该仅有一个引起它变化的原因。</p>\n<p>如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。</p>\n</blockquote>\n<h2 id=\"四、开放-封闭原则\"><a href=\"#四、开放-封闭原则\" class=\"headerlink\" title=\"四、开放-封闭原则\"></a>四、开放-封闭原则</h2><p><strong>软件实体（类、模块、函数等）应该可以扩展但不可修改，即对拓展开放，对修改封闭</strong></p>\n<h2 id=\"五、依赖倒置原则\"><a href=\"#五、依赖倒置原则\" class=\"headerlink\" title=\"五、依赖倒置原则\"></a>五、依赖倒置原则</h2><p>1、高层模块不应该依赖底层模块，两个都应该依赖抽象</p>\n<p>2、抽象不应该依赖细节，细节应该依赖抽象</p>\n<ul>\n<li><p>里氏代换原则</p>\n<p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。</p>\n<p>即：子类型必须能够替换掉它们的父类型</p>\n</li>\n</ul>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ruby\">和策略模式有一定的相似之处，例子<br><br><span class=\"hljs-title class_\">Device</span>类<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Device</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_on</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        pass<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_off</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        pass<br><br>子类<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Light</span>(<span class=\"hljs-title class_\">Device</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_on</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Light is turned on&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_off</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Light is turned off&quot;</span>)<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Fan</span>(<span class=\"hljs-title class_\">Device</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_on</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Fan is turned on&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_off</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Fan is turned off&quot;</span>)<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Speaker</span>(<span class=\"hljs-title class_\">Device</span>):<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_on</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Speaker is turned on&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">turn_off</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        print(<span class=\"hljs-string\">&quot;Speaker is turned off&quot;</span>)<br><br>高层模块<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DeviceController</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span>, device</span>):<br>        <span class=\"hljs-variable language_\">self</span>.device = device<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">operate</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        <span class=\"hljs-variable language_\">self</span>.device.turn_on()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">stop</span>(<span class=\"hljs-params\"><span class=\"hljs-variable language_\">self</span></span>):<br>        <span class=\"hljs-variable language_\">self</span>.device.turn_off()<br><br>main<br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    light = <span class=\"hljs-title class_\">Light</span>()<br>    fan = <span class=\"hljs-title class_\">Fan</span>()<br>    speaker = <span class=\"hljs-title class_\">Speaker</span>()<br><br>    controller1 = <span class=\"hljs-title class_\">DeviceController</span>(light)<br>    controller2 = <span class=\"hljs-title class_\">DeviceController</span>(fan)<br>    controller3 = <span class=\"hljs-title class_\">DeviceController</span>(speaker)<br><br>    controller1.operate()<br>    controller2.operate()<br>    controller3.operate()<br><br>    controller1.stop()<br>    controller2.stop()<br>    controller3.stop()<br>高层模块 <span class=\"hljs-title class_\">DeviceController</span> 不直接依赖于具体的设备类（如 <span class=\"hljs-title class_\">Light</span>、<span class=\"hljs-title class_\">Fan</span> 和 <span class=\"hljs-title class_\">Speaker</span>），而是依赖于抽象的 <span class=\"hljs-title class_\">Device</span> 接口。这就是依赖倒置原则的应用，它使得高层模块更加灵活，可以轻松地切换和扩展不同类型的设备，而不需要修改高层模块的代码。这有助于创建松耦合的、易于维护和扩展的代码<br></code></pre></td></tr></table></figure>\n<h2 id=\"六、装饰模式\"><a href=\"#六、装饰模式\" class=\"headerlink\" title=\"六、装饰模式\"></a>六、装饰模式</h2><p><strong>动态地给一个对象添加一些额外的职责</strong>，就增加功能来说，装饰模式比生成子类更为灵活</p>\n<p>在子类中定义一个父类对象，该对象使用需要装饰的对象作为初始化，并在子类中对该对象进行操作，即可达到，对对象的额外装饰结果，但是这一个对象和之前的对象不一定是同一个对象。</p>\n<ul>\n<li>基本结构</li>\n</ul>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">1、父类：父类定义一个抽象的方法<br>2、子类：子类继承父类抽象方法并添加一些最基本的属性<br>3、装饰器类：装饰器类继承父类，并定义一个父类的保护类型数据<br>4、不同的装饰器类：不同的装饰器类继承于装饰器类，重写各自装饰器需要添加的职责<br><br>通常第“2”步中定义基本属性的子类，会作为第一层装饰包装子类，后续会作为参数传入到装饰器类中<br></code></pre></td></tr></table></figure>\n<p>装饰模式可以把类中的装饰功能从类中搬移去除，这样就可以简化原有的类。同事有效地把类的核心职责和装饰功能区分开，去除相关类中的重复的装饰逻辑，重复的装饰逻辑可以使用一个子类作为最基类型。</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs 1c\"><span class=\"hljs-built_in\">exp</span>：<br>游戏中，不同人物角色使用不同技能进行装饰。最开始都是有一个人物的基类（低级的时候）。公共技能可以作为重复逻辑继承在一个类中，使用装饰模式，可以学习一些不同的技能。<br></code></pre></td></tr></table></figure>\n<h2 id=\"七、代理模式\"><a href=\"#七、代理模式\" class=\"headerlink\" title=\"七、代理模式\"></a>七、代理模式</h2><p>代理模式，为其它对象提供一种代理以控制对这个对象的访问</p>\n<p>在客户与另一客户交互的过程中，中间会有一层代理，代理可以拥有两个客户的接口，作为中间实体来进行来促使两客户进行交互，在代理中如果需要交互，则需要定义一个客户的类，来调用该客户的方法。</p>\n<ul>\n<li><p>代理模式应用场景</p>\n<p>远程代理：为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实</p>\n<p>虚拟代理：根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，浏览器中加载图片就是使用虚拟代理</p>\n<p>安全代理：用来控制真实对象访问时的权限</p>\n<p>智能指引：当掉哟个真实对象时，代理处理另外一些事</p>\n</li>\n</ul>\n<h2 id=\"八、工厂方法模式\"><a href=\"#八、工厂方法模式\" class=\"headerlink\" title=\"八、工厂方法模式\"></a>八、工厂方法模式</h2><p>封装实例来创建过程，可以让创建实例的过程封装到工厂类中，避免耦合</p>\n<h2 id=\"九、原型模式\"><a href=\"#九、原型模式\" class=\"headerlink\" title=\"九、原型模式\"></a>九、原型模式</h2><p>用原型（Prototype）实例指定创建对象的种类，并且通过复制这些原型创建新的对象</p>\n<ul>\n<li><p>用法</p>\n<p>在类里面定义一个函数，函数可以返回一个原型对象</p>\n</li>\n<li><p>在类中定义修改原型中属性的set方法</p>\n</li>\n<li><p>在使用的过程中，只需要调用set方法修改不同的地方</p>\n</li>\n</ul>\n<p>深拷贝与浅拷贝，若在原型类中使用对象引用，在修改的时候记得使用深拷贝</p>\n<h2 id=\"十、模板方法模式\"><a href=\"#十、模板方法模式\" class=\"headerlink\" title=\"十、模板方法模式\"></a>十、模板方法模式</h2><p>定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>\n<h2 id=\"十一、迪米特法则\"><a href=\"#十一、迪米特法则\" class=\"headerlink\" title=\"十一、迪米特法则\"></a>十一、迪米特法则</h2><blockquote>\n<p>最小知识原则</p>\n</blockquote>\n<p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>\n"},{"title":"平方根倒数算法","date":"2024-01-24T11:53:09.000Z","cover":"/img/default_cover04.jpg","top_img":"2024/01/24/平方根倒数算法/WTF.png","mathjax":true,"_content":"\n### 平方根倒数算法\n\n$$\n1/\\sqrt{x}\n$$\n\n#### 求一个数的平方根倒数\n\n对于计算机来说求一个数的平方根一般有两种方式，二分法和牛顿迭代法\n\n* 二分法\n\n  EXP表示精度，从0-num不断开始计算mid的平方，直到left>right，此时返回right的值即为所求的平方根，其中注意边界条件：\n\n  当mid * mid = num时，此时left需要加上EXP，往后的循环中mid * mid 都会大于num，所以right还会不停减小，直到right < left，返回right，这时right已经在精度范围内\n\n```c++\ndouble Sqrt(double num) {\n    double left = 0, right = num;\n \n    while (left <= right) {\n        double mid = left + (right - left) / 2;\n \n        if (mid * mid <= num)\n            left = mid + EXP;\n        else\n            right = mid - EXP;\n    }   \n \n    return right;\n}\n```\n\n* 牛顿迭代法\n\n  牛顿迭代法是将原来的求开方问题转化为数学函数问题，即假设`x * x = n`，求n的开方转化为`x * x - n = 0`的解，即`y = x * x - n`与x轴的交点\n\n  代码中last表示上一次的切线与x轴的交点的x坐标，初始值为num，ret表示x = last时的切线与x轴的交点，不断迭代，直到ret - last小于精度，即达到精度返回ret。\n\n```c++\ndouble Sqrt(double num) {\n    if (0 == num)\n        return num;\n \n    double last = num, ret = num;\n \n    for (;;) {\n        last = 0.5 * (ret + num / ret);\n        if (fabs(ret - last) < EXP)\n            break;\n        ret = last;\n    }   \n \n    return ret;\n}\n```\n\n计算完平方根过后，再计算其倒数，也是一个对计算机来说并不是很友好的运算\n\n#### 快速平方根倒数计算推导\n\n快速平方根算法是利用了计算机存储浮点数的特性并和牛顿迭代法来共同完成的，也是一个近似计算。对于牛顿迭代法，其精髓是如果能够找到一个接近于解的初始值，是有可能通过一次迭代或者较少次数的迭代达到比较高的近似解，而快速平方根算法旨在于找到一个较为近似的初始值。具体的运算如下。\n\n**笔记中有一处笔误0xD5F400000应改成0x5F400000**\n\n![运算过程](平方根倒数算法/运算过程.png)\n\n快速平方根算法代码\n\n* 初始值由0x5F400000改为了0x5f3759df，对于X/2代码中使用了位运算加速求解\n\n```C++\nfloat Q_rsqrt(float number)\n{\n    long i;\n    float x2, y;\n    const float threehalfs = 1.5F;\n    x2 = number * 0.5F;\n    y = number;\n    i = * ( long* ) &y;\t\t\t\t\t\t\t// evil floating point bit hack\n    i = 0x5f3759df - (i >> 1);\t\t\t\t\t// what the fuck? \n    y = * ( float * ) &i;\n    y = y * (threehalfs - ( x2 * y * y ) );\t\t// 1st iteration\n//  y = y * (threehalfs - ( x2 * y * y ) );\t\t// 2st iteration, can be removed\n    \n    return y;\n}\n```","source":"_posts/平方根倒数算法.md","raw":"---\ntitle: 平方根倒数算法\ndate: 2024-01-24 19:53:09\ntags: [数学, 算法]\ncategories: 技术研究\ncover: /img/default_cover04.jpg\ntop_img: WTF.png\nmathjax: true\n---\n\n### 平方根倒数算法\n\n$$\n1/\\sqrt{x}\n$$\n\n#### 求一个数的平方根倒数\n\n对于计算机来说求一个数的平方根一般有两种方式，二分法和牛顿迭代法\n\n* 二分法\n\n  EXP表示精度，从0-num不断开始计算mid的平方，直到left>right，此时返回right的值即为所求的平方根，其中注意边界条件：\n\n  当mid * mid = num时，此时left需要加上EXP，往后的循环中mid * mid 都会大于num，所以right还会不停减小，直到right < left，返回right，这时right已经在精度范围内\n\n```c++\ndouble Sqrt(double num) {\n    double left = 0, right = num;\n \n    while (left <= right) {\n        double mid = left + (right - left) / 2;\n \n        if (mid * mid <= num)\n            left = mid + EXP;\n        else\n            right = mid - EXP;\n    }   \n \n    return right;\n}\n```\n\n* 牛顿迭代法\n\n  牛顿迭代法是将原来的求开方问题转化为数学函数问题，即假设`x * x = n`，求n的开方转化为`x * x - n = 0`的解，即`y = x * x - n`与x轴的交点\n\n  代码中last表示上一次的切线与x轴的交点的x坐标，初始值为num，ret表示x = last时的切线与x轴的交点，不断迭代，直到ret - last小于精度，即达到精度返回ret。\n\n```c++\ndouble Sqrt(double num) {\n    if (0 == num)\n        return num;\n \n    double last = num, ret = num;\n \n    for (;;) {\n        last = 0.5 * (ret + num / ret);\n        if (fabs(ret - last) < EXP)\n            break;\n        ret = last;\n    }   \n \n    return ret;\n}\n```\n\n计算完平方根过后，再计算其倒数，也是一个对计算机来说并不是很友好的运算\n\n#### 快速平方根倒数计算推导\n\n快速平方根算法是利用了计算机存储浮点数的特性并和牛顿迭代法来共同完成的，也是一个近似计算。对于牛顿迭代法，其精髓是如果能够找到一个接近于解的初始值，是有可能通过一次迭代或者较少次数的迭代达到比较高的近似解，而快速平方根算法旨在于找到一个较为近似的初始值。具体的运算如下。\n\n**笔记中有一处笔误0xD5F400000应改成0x5F400000**\n\n![运算过程](平方根倒数算法/运算过程.png)\n\n快速平方根算法代码\n\n* 初始值由0x5F400000改为了0x5f3759df，对于X/2代码中使用了位运算加速求解\n\n```C++\nfloat Q_rsqrt(float number)\n{\n    long i;\n    float x2, y;\n    const float threehalfs = 1.5F;\n    x2 = number * 0.5F;\n    y = number;\n    i = * ( long* ) &y;\t\t\t\t\t\t\t// evil floating point bit hack\n    i = 0x5f3759df - (i >> 1);\t\t\t\t\t// what the fuck? \n    y = * ( float * ) &i;\n    y = y * (threehalfs - ( x2 * y * y ) );\t\t// 1st iteration\n//  y = y * (threehalfs - ( x2 * y * y ) );\t\t// 2st iteration, can be removed\n    \n    return y;\n}\n```","slug":"平方根倒数算法","published":1,"updated":"2024-02-20T06:57:50.347Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xu000gg4c27rvbc6j3","content":"<h3 id=\"平方根倒数算法\"><a href=\"#平方根倒数算法\" class=\"headerlink\" title=\"平方根倒数算法\"></a>平方根倒数算法</h3><script type=\"math/tex; mode=display\">\n1/\\sqrt{x}</script><h4 id=\"求一个数的平方根倒数\"><a href=\"#求一个数的平方根倒数\" class=\"headerlink\" title=\"求一个数的平方根倒数\"></a>求一个数的平方根倒数</h4><p>对于计算机来说求一个数的平方根一般有两种方式，二分法和牛顿迭代法</p>\n<ul>\n<li><p>二分法</p>\n<p>EXP表示精度，从0-num不断开始计算mid的平方，直到left&gt;right，此时返回right的值即为所求的平方根，其中注意边界条件：</p>\n<p>当mid <em> mid = num时，此时left需要加上EXP，往后的循环中mid </em> mid 都会大于num，所以right还会不停减小，直到right &lt; left，返回right，这时right已经在精度范围内</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">Sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> num)</span> </span>&#123;<br>    <span class=\"hljs-type\">double</span> left = <span class=\"hljs-number\">0</span>, right = num;<br> <br>    <span class=\"hljs-keyword\">while</span> (left &lt;= right) &#123;<br>        <span class=\"hljs-type\">double</span> mid = left + (right - left) / <span class=\"hljs-number\">2</span>;<br> <br>        <span class=\"hljs-keyword\">if</span> (mid * mid &lt;= num)<br>            left = mid + EXP;<br>        <span class=\"hljs-keyword\">else</span><br>            right = mid - EXP;<br>    &#125;   <br> <br>    <span class=\"hljs-keyword\">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>牛顿迭代法</p>\n<p>牛顿迭代法是将原来的求开方问题转化为数学函数问题，即假设<code>x * x = n</code>，求n的开方转化为<code>x * x - n = 0</code>的解，即<code>y = x * x - n</code>与x轴的交点</p>\n<p>代码中last表示上一次的切线与x轴的交点的x坐标，初始值为num，ret表示x = last时的切线与x轴的交点，不断迭代，直到ret - last小于精度，即达到精度返回ret。</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">Sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> num)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span> == num)<br>        <span class=\"hljs-keyword\">return</span> num;<br> <br>    <span class=\"hljs-type\">double</span> last = num, ret = num;<br> <br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        last = <span class=\"hljs-number\">0.5</span> * (ret + num / ret);<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">fabs</span>(ret - last) &lt; EXP)<br>            <span class=\"hljs-keyword\">break</span>;<br>        ret = last;<br>    &#125;   <br> <br>    <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>计算完平方根过后，再计算其倒数，也是一个对计算机来说并不是很友好的运算</p>\n<h4 id=\"快速平方根倒数计算推导\"><a href=\"#快速平方根倒数计算推导\" class=\"headerlink\" title=\"快速平方根倒数计算推导\"></a>快速平方根倒数计算推导</h4><p>快速平方根算法是利用了计算机存储浮点数的特性并和牛顿迭代法来共同完成的，也是一个近似计算。对于牛顿迭代法，其精髓是如果能够找到一个接近于解的初始值，是有可能通过一次迭代或者较少次数的迭代达到比较高的近似解，而快速平方根算法旨在于找到一个较为近似的初始值。具体的运算如下。</p>\n<p><strong>笔记中有一处笔误0xD5F400000应改成0x5F400000</strong></p>\n<img src=\"/2024/01/24/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E7%AE%97%E6%B3%95/%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B.png\" class=\"\" title=\"运算过程\">\n<p>快速平方根算法代码</p>\n<ul>\n<li>初始值由0x5F400000改为了0x5f3759df，对于X/2代码中使用了位运算加速求解</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">Q_rsqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> number)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">long</span> i;<br>    <span class=\"hljs-type\">float</span> x2, y;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">float</span> threehalfs = <span class=\"hljs-number\">1.5F</span>;<br>    x2 = number * <span class=\"hljs-number\">0.5F</span>;<br>    y = number;<br>    i = * ( <span class=\"hljs-type\">long</span>* ) &amp;y;\t\t\t\t\t\t\t<span class=\"hljs-comment\">// evil floating point bit hack</span><br>    i = <span class=\"hljs-number\">0x5f3759df</span> - (i &gt;&gt; <span class=\"hljs-number\">1</span>);\t\t\t\t\t<span class=\"hljs-comment\">// what the fuck? </span><br>    y = * ( <span class=\"hljs-type\">float</span> * ) &amp;i;<br>    y = y * (threehalfs - ( x2 * y * y ) );\t\t<span class=\"hljs-comment\">// 1st iteration</span><br><span class=\"hljs-comment\">//  y = y * (threehalfs - ( x2 * y * y ) );\t\t// 2st iteration, can be removed</span><br>    <br>    <span class=\"hljs-keyword\">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>","cover_type":"img","excerpt":"","more":"<h3 id=\"平方根倒数算法\"><a href=\"#平方根倒数算法\" class=\"headerlink\" title=\"平方根倒数算法\"></a>平方根倒数算法</h3><script type=\"math/tex; mode=display\">\n1/\\sqrt{x}</script><h4 id=\"求一个数的平方根倒数\"><a href=\"#求一个数的平方根倒数\" class=\"headerlink\" title=\"求一个数的平方根倒数\"></a>求一个数的平方根倒数</h4><p>对于计算机来说求一个数的平方根一般有两种方式，二分法和牛顿迭代法</p>\n<ul>\n<li><p>二分法</p>\n<p>EXP表示精度，从0-num不断开始计算mid的平方，直到left&gt;right，此时返回right的值即为所求的平方根，其中注意边界条件：</p>\n<p>当mid <em> mid = num时，此时left需要加上EXP，往后的循环中mid </em> mid 都会大于num，所以right还会不停减小，直到right &lt; left，返回right，这时right已经在精度范围内</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">Sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> num)</span> </span>&#123;<br>    <span class=\"hljs-type\">double</span> left = <span class=\"hljs-number\">0</span>, right = num;<br> <br>    <span class=\"hljs-keyword\">while</span> (left &lt;= right) &#123;<br>        <span class=\"hljs-type\">double</span> mid = left + (right - left) / <span class=\"hljs-number\">2</span>;<br> <br>        <span class=\"hljs-keyword\">if</span> (mid * mid &lt;= num)<br>            left = mid + EXP;<br>        <span class=\"hljs-keyword\">else</span><br>            right = mid - EXP;<br>    &#125;   <br> <br>    <span class=\"hljs-keyword\">return</span> right;<br>&#125;<br></code></pre></td></tr></table></figure>\n<ul>\n<li><p>牛顿迭代法</p>\n<p>牛顿迭代法是将原来的求开方问题转化为数学函数问题，即假设<code>x * x = n</code>，求n的开方转化为<code>x * x - n = 0</code>的解，即<code>y = x * x - n</code>与x轴的交点</p>\n<p>代码中last表示上一次的切线与x轴的交点的x坐标，初始值为num，ret表示x = last时的切线与x轴的交点，不断迭代，直到ret - last小于精度，即达到精度返回ret。</p>\n</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">Sqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> num)</span> </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span> == num)<br>        <span class=\"hljs-keyword\">return</span> num;<br> <br>    <span class=\"hljs-type\">double</span> last = num, ret = num;<br> <br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        last = <span class=\"hljs-number\">0.5</span> * (ret + num / ret);<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">fabs</span>(ret - last) &lt; EXP)<br>            <span class=\"hljs-keyword\">break</span>;<br>        ret = last;<br>    &#125;   <br> <br>    <span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>计算完平方根过后，再计算其倒数，也是一个对计算机来说并不是很友好的运算</p>\n<h4 id=\"快速平方根倒数计算推导\"><a href=\"#快速平方根倒数计算推导\" class=\"headerlink\" title=\"快速平方根倒数计算推导\"></a>快速平方根倒数计算推导</h4><p>快速平方根算法是利用了计算机存储浮点数的特性并和牛顿迭代法来共同完成的，也是一个近似计算。对于牛顿迭代法，其精髓是如果能够找到一个接近于解的初始值，是有可能通过一次迭代或者较少次数的迭代达到比较高的近似解，而快速平方根算法旨在于找到一个较为近似的初始值。具体的运算如下。</p>\n<p><strong>笔记中有一处笔误0xD5F400000应改成0x5F400000</strong></p>\n<img src=\"/2024/01/24/%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E7%AE%97%E6%B3%95/%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B.png\" class=\"\" title=\"运算过程\">\n<p>快速平方根算法代码</p>\n<ul>\n<li>初始值由0x5F400000改为了0x5f3759df，对于X/2代码中使用了位运算加速求解</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">Q_rsqrt</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> number)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">long</span> i;<br>    <span class=\"hljs-type\">float</span> x2, y;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">float</span> threehalfs = <span class=\"hljs-number\">1.5F</span>;<br>    x2 = number * <span class=\"hljs-number\">0.5F</span>;<br>    y = number;<br>    i = * ( <span class=\"hljs-type\">long</span>* ) &amp;y;\t\t\t\t\t\t\t<span class=\"hljs-comment\">// evil floating point bit hack</span><br>    i = <span class=\"hljs-number\">0x5f3759df</span> - (i &gt;&gt; <span class=\"hljs-number\">1</span>);\t\t\t\t\t<span class=\"hljs-comment\">// what the fuck? </span><br>    y = * ( <span class=\"hljs-type\">float</span> * ) &amp;i;<br>    y = y * (threehalfs - ( x2 * y * y ) );\t\t<span class=\"hljs-comment\">// 1st iteration</span><br><span class=\"hljs-comment\">//  y = y * (threehalfs - ( x2 * y * y ) );\t\t// 2st iteration, can be removed</span><br>    <br>    <span class=\"hljs-keyword\">return</span> y;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"进程间的通信方式","date":"2024-01-30T03:27:05.000Z","cover":"/img/default_cover.jpg","top_img":null,"_content":"\n## 进程间的通信方式\n\n每个进程的用户地址空间是独立的，一般情况之下，不同的进程是**无法**通过进程间各自的地址空间来进行互相访问，但是不同的进程所拥有的内核空间是共享的，因此如果不同进程之间需要进行通信必须要通过内核。\n\n### 管道通信\n\n管道通信分为匿名管道和命名管道，通过名字可以区分，匿名管道是无法获取和控制的管道，命名管道是通过用户可以自己建立的管道。\n\n管道智能进行半双工的通信，即数据传输是单向的，如果想要实现互相通信，就需要创建两个管道。\n\n#### 匿名管道\n\n* 在linux中的`|`竖线就是一个管道，将管道符前的操作的输出作为管道符后的操作的输入\n\n一个匿名管道的创建会使用到下面的系统调用\n\n```C++\nint pipe(int fd[2]);\n```\n\n表示创建了一个匿名管道并返回了两个文件描述符，一个是管道读取端的描述符`fd[0]`，另一个是管道写入端的描述符`fd[1]`，**匿名管道是特殊的文件，只存在于内存当中，不存在于文件系统中**\n\n管道实际上就是内核中的一串缓存，进程通过文件描述符来对这一串缓存进行读写操作\n\n![image-20240130223824673](进程间的通信方式/image-20240130223824673.png)\n\n**如果说需要实现多个进程之间的通信**，可以使用`fork`操作来创建子进程，创建子进程时，子进程会同时复制父进程的文件描述符，两个进程便可以通过各自的文件描述符来进行跨进程之间的通信。\n\n![image-20240130224638178](进程间的通信方式/image-20240130224638178.png)\n\n通过对文件描述符的开放和关闭，可以控制父进程和子进程之间的读写操作。\n\n* 如：父进程关闭读取的 fd[0]，只保留写入的 fd[1]；子进程关闭写入的 fd[1]，只保留读取的 fd[0]；\n* 便可以实现从父进程向子进程的数据写入\n\n实现多个进程之间匿名管道的通信另一种方式就是fork两个子进程，关闭父进程的文件描述符，开启子进程的`fd`，实现子进程之间的通信。\n\n可以看出来，匿名管道的通信范围仅限于父子关系的进程。因为管道没有实体，没有管道文件，只能通过复制父进程的fd来使用文件描述符。\n\n#### 命名管道\n\n* 在linux中可以通过`mkfifo`命令来创建并指定管道名字\n\n```\nmkfifo myPipe\n```\n\n因为命名管道，提前创建了一个类型为管道的设备文件，在进程中只要使用到这个设备，便可以互相通信。\n\n**管道的通信方式，效率较低，不适合进程间的频繁交换数据**\n\n### 消息队列\n\n> 在管道通信的缺点下，消息队列可以解决进程间频繁交换数据的问题。\n\n消息队列是保护在内核中的消息列表，如果进程之间需要进行通信，只需要将消息放在对应的消息队列中便可以正常返回，无需阻塞等待，等到另一个进程需要的时候去消息队列中去读取便可以。\n\n如果消息队列没有释放或者没有关闭操作系统，消息队列会一直存在，而匿名管道则是随着进程的生命周期的结束而销毁。\n\n* 优点\n\n  * 解决频繁交换数据的问题\n\n    两个进程之间就像发邮件一样可以你来我往进行沟通\n\n  * 进程发送消息后无需阻塞等待消息的接收\n\n* 缺点\n\n  * 不适合比较大的数据传输\n\n    消息队列中的消息体是由结构化的数据结构来组织的，有最大长度的限制。\n\n  * 消息队列的通信过程中，存在用户态与内核态之间的数据拷贝开销\n\n### 共享内存\n\n共享内存用到的是现代操作系统中的内存管理的**虚拟内存技术**，每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。\n\n**共享内存的机制：拿出一块虚拟地址空间，映射到相同的物理内存中。**不同的进程可以使用各自的虚拟地址访问到这一片相同的物理内存。\n\n![image-20240130232827259](进程间的通信方式/image-20240130232827259.png)\n\n* 优点\n  * 解决了消息队列中不适合大的数据的通信\n  * 不同进程之间无需进行频繁的用户态和内核态的转换，因为进程都是在自己的用户地址空间中来进行操作\n\n* 缺点\n\n  * 对共享内存的读写问题\n\n    因为共享内存存储的信息一旦发生改变对于不同的进程都是可见的，所以会涉及到读写一致性的问题\n\n  * 共享内存也变为了临界资源，存在进程进程之间的竞争\n\n    需要保护机制，使得共享资源在任意时刻只能被一个进程访问。\n\n### 信号量\n\n> 信号量可以提供对临界资源的保护\n\n信号量是一个整型的计数器，可以用于实现进程间的互斥以及同步，不是用于缓存进程间通信的数据。\n\n信号量的大小表示为资源的数量，对信号量的操作方式有两种原子操作\n\n* 一个是 **P 操作**，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。\n* 一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；\n\n通过PV操作可以控制进程对资源的互斥访问以及控制进程的同步顺序，**涉及到操作系统的知识**\n\n### 信号\n\n> 在进程工作异常情况下，需要通过信号来通知进程\n\n信号是进程间通信机制中的唯一的异步通信方式，因为可以在任何时候发送信号到某一进程，一旦有信号产生，用户就可以进行对信号处理。\n\n* 信号的处理方式\n  * 执行默认操作： 例如linux中的SIGTERM 信号，就是终止进程的意思\n  * 捕捉信号：可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数\n  * 忽略信号：当不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。\n\n* `SIGKILL` 和 `SEGSTOP`无法被捕捉和忽略。\n\n### Socket\n\nSocket通信实现的是在不同主机之间的通信，分为两种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式\n\n> 基于 TCP 协议的通信方式需要客户和服务器之间建立TCP连接，进行三次握手。\n\n![image-20240130234627976](进程间的通信方式/image-20240130234627976.png)\n\n- 服务端和客户端初始化 `socket`，得到文件描述符；\n- 服务端调用 `bind`，将绑定在 IP 地址和端口;\n- 服务端调用 `listen`，进行监听；\n- 服务端调用 `accept`，等待客户端连接；\n- 客户端调用 `connect`，向服务器端的地址和端口发起连接请求；\n- 服务端 `accept` 返回用于传输的 `socket` 的文件描述符；\n- 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；\n- 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据的时候，就会读取到了 `EOF`，待处理完数据后，服务端调用 `close`，表示连接关闭。\n\n这里需要注意的是，服务端调用 `accept` 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。\n\n所以，监听的 socket 和真正用来传送数据的 socket，是「**两个**」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。\n\n成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。\n\n> 基于UDP的Socket通信\n\n![image-20240130234754230](进程间的通信方式/image-20240130234754230.png)\n\nUDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。\n\n对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。\n\n另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。\n","source":"_posts/进程间的通信方式.md","raw":"---\ntitle: 进程间的通信方式\ndate: 2024-01-30 11:27:05\ntags: [操作系统, 进程通信]\ncategories: 技术研究\ncover: /img/default_cover.jpg\ntop_img:\n---\n\n## 进程间的通信方式\n\n每个进程的用户地址空间是独立的，一般情况之下，不同的进程是**无法**通过进程间各自的地址空间来进行互相访问，但是不同的进程所拥有的内核空间是共享的，因此如果不同进程之间需要进行通信必须要通过内核。\n\n### 管道通信\n\n管道通信分为匿名管道和命名管道，通过名字可以区分，匿名管道是无法获取和控制的管道，命名管道是通过用户可以自己建立的管道。\n\n管道智能进行半双工的通信，即数据传输是单向的，如果想要实现互相通信，就需要创建两个管道。\n\n#### 匿名管道\n\n* 在linux中的`|`竖线就是一个管道，将管道符前的操作的输出作为管道符后的操作的输入\n\n一个匿名管道的创建会使用到下面的系统调用\n\n```C++\nint pipe(int fd[2]);\n```\n\n表示创建了一个匿名管道并返回了两个文件描述符，一个是管道读取端的描述符`fd[0]`，另一个是管道写入端的描述符`fd[1]`，**匿名管道是特殊的文件，只存在于内存当中，不存在于文件系统中**\n\n管道实际上就是内核中的一串缓存，进程通过文件描述符来对这一串缓存进行读写操作\n\n![image-20240130223824673](进程间的通信方式/image-20240130223824673.png)\n\n**如果说需要实现多个进程之间的通信**，可以使用`fork`操作来创建子进程，创建子进程时，子进程会同时复制父进程的文件描述符，两个进程便可以通过各自的文件描述符来进行跨进程之间的通信。\n\n![image-20240130224638178](进程间的通信方式/image-20240130224638178.png)\n\n通过对文件描述符的开放和关闭，可以控制父进程和子进程之间的读写操作。\n\n* 如：父进程关闭读取的 fd[0]，只保留写入的 fd[1]；子进程关闭写入的 fd[1]，只保留读取的 fd[0]；\n* 便可以实现从父进程向子进程的数据写入\n\n实现多个进程之间匿名管道的通信另一种方式就是fork两个子进程，关闭父进程的文件描述符，开启子进程的`fd`，实现子进程之间的通信。\n\n可以看出来，匿名管道的通信范围仅限于父子关系的进程。因为管道没有实体，没有管道文件，只能通过复制父进程的fd来使用文件描述符。\n\n#### 命名管道\n\n* 在linux中可以通过`mkfifo`命令来创建并指定管道名字\n\n```\nmkfifo myPipe\n```\n\n因为命名管道，提前创建了一个类型为管道的设备文件，在进程中只要使用到这个设备，便可以互相通信。\n\n**管道的通信方式，效率较低，不适合进程间的频繁交换数据**\n\n### 消息队列\n\n> 在管道通信的缺点下，消息队列可以解决进程间频繁交换数据的问题。\n\n消息队列是保护在内核中的消息列表，如果进程之间需要进行通信，只需要将消息放在对应的消息队列中便可以正常返回，无需阻塞等待，等到另一个进程需要的时候去消息队列中去读取便可以。\n\n如果消息队列没有释放或者没有关闭操作系统，消息队列会一直存在，而匿名管道则是随着进程的生命周期的结束而销毁。\n\n* 优点\n\n  * 解决频繁交换数据的问题\n\n    两个进程之间就像发邮件一样可以你来我往进行沟通\n\n  * 进程发送消息后无需阻塞等待消息的接收\n\n* 缺点\n\n  * 不适合比较大的数据传输\n\n    消息队列中的消息体是由结构化的数据结构来组织的，有最大长度的限制。\n\n  * 消息队列的通信过程中，存在用户态与内核态之间的数据拷贝开销\n\n### 共享内存\n\n共享内存用到的是现代操作系统中的内存管理的**虚拟内存技术**，每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。\n\n**共享内存的机制：拿出一块虚拟地址空间，映射到相同的物理内存中。**不同的进程可以使用各自的虚拟地址访问到这一片相同的物理内存。\n\n![image-20240130232827259](进程间的通信方式/image-20240130232827259.png)\n\n* 优点\n  * 解决了消息队列中不适合大的数据的通信\n  * 不同进程之间无需进行频繁的用户态和内核态的转换，因为进程都是在自己的用户地址空间中来进行操作\n\n* 缺点\n\n  * 对共享内存的读写问题\n\n    因为共享内存存储的信息一旦发生改变对于不同的进程都是可见的，所以会涉及到读写一致性的问题\n\n  * 共享内存也变为了临界资源，存在进程进程之间的竞争\n\n    需要保护机制，使得共享资源在任意时刻只能被一个进程访问。\n\n### 信号量\n\n> 信号量可以提供对临界资源的保护\n\n信号量是一个整型的计数器，可以用于实现进程间的互斥以及同步，不是用于缓存进程间通信的数据。\n\n信号量的大小表示为资源的数量，对信号量的操作方式有两种原子操作\n\n* 一个是 **P 操作**，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。\n* 一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；\n\n通过PV操作可以控制进程对资源的互斥访问以及控制进程的同步顺序，**涉及到操作系统的知识**\n\n### 信号\n\n> 在进程工作异常情况下，需要通过信号来通知进程\n\n信号是进程间通信机制中的唯一的异步通信方式，因为可以在任何时候发送信号到某一进程，一旦有信号产生，用户就可以进行对信号处理。\n\n* 信号的处理方式\n  * 执行默认操作： 例如linux中的SIGTERM 信号，就是终止进程的意思\n  * 捕捉信号：可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数\n  * 忽略信号：当不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。\n\n* `SIGKILL` 和 `SEGSTOP`无法被捕捉和忽略。\n\n### Socket\n\nSocket通信实现的是在不同主机之间的通信，分为两种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式\n\n> 基于 TCP 协议的通信方式需要客户和服务器之间建立TCP连接，进行三次握手。\n\n![image-20240130234627976](进程间的通信方式/image-20240130234627976.png)\n\n- 服务端和客户端初始化 `socket`，得到文件描述符；\n- 服务端调用 `bind`，将绑定在 IP 地址和端口;\n- 服务端调用 `listen`，进行监听；\n- 服务端调用 `accept`，等待客户端连接；\n- 客户端调用 `connect`，向服务器端的地址和端口发起连接请求；\n- 服务端 `accept` 返回用于传输的 `socket` 的文件描述符；\n- 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；\n- 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据的时候，就会读取到了 `EOF`，待处理完数据后，服务端调用 `close`，表示连接关闭。\n\n这里需要注意的是，服务端调用 `accept` 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。\n\n所以，监听的 socket 和真正用来传送数据的 socket，是「**两个**」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。\n\n成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。\n\n> 基于UDP的Socket通信\n\n![image-20240130234754230](进程间的通信方式/image-20240130234754230.png)\n\nUDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。\n\n对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。\n\n另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。\n","slug":"进程间的通信方式","published":1,"updated":"2024-02-20T06:55:58.677Z","comments":1,"layout":"post","photos":[],"_id":"clsu1a9xv000kg4c2cgj0a1ee","content":"<h2 id=\"进程间的通信方式\"><a href=\"#进程间的通信方式\" class=\"headerlink\" title=\"进程间的通信方式\"></a>进程间的通信方式</h2><p>每个进程的用户地址空间是独立的，一般情况之下，不同的进程是<strong>无法</strong>通过进程间各自的地址空间来进行互相访问，但是不同的进程所拥有的内核空间是共享的，因此如果不同进程之间需要进行通信必须要通过内核。</p>\n<h3 id=\"管道通信\"><a href=\"#管道通信\" class=\"headerlink\" title=\"管道通信\"></a>管道通信</h3><p>管道通信分为匿名管道和命名管道，通过名字可以区分，匿名管道是无法获取和控制的管道，命名管道是通过用户可以自己建立的管道。</p>\n<p>管道智能进行半双工的通信，即数据传输是单向的，如果想要实现互相通信，就需要创建两个管道。</p>\n<h4 id=\"匿名管道\"><a href=\"#匿名管道\" class=\"headerlink\" title=\"匿名管道\"></a>匿名管道</h4><ul>\n<li>在linux中的<code>|</code>竖线就是一个管道，将管道符前的操作的输出作为管道符后的操作的输入</li>\n</ul>\n<p>一个匿名管道的创建会使用到下面的系统调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pipe</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> fd[<span class=\"hljs-number\">2</span>])</span></span>;<br></code></pre></td></tr></table></figure>\n<p>表示创建了一个匿名管道并返回了两个文件描述符，一个是管道读取端的描述符<code>fd[0]</code>，另一个是管道写入端的描述符<code>fd[1]</code>，<strong>匿名管道是特殊的文件，只存在于内存当中，不存在于文件系统中</strong></p>\n<p>管道实际上就是内核中的一串缓存，进程通过文件描述符来对这一串缓存进行读写操作</p>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130223824673.png\" class=\"\" title=\"image-20240130223824673\">\n<p><strong>如果说需要实现多个进程之间的通信</strong>，可以使用<code>fork</code>操作来创建子进程，创建子进程时，子进程会同时复制父进程的文件描述符，两个进程便可以通过各自的文件描述符来进行跨进程之间的通信。</p>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130224638178.png\" class=\"\" title=\"image-20240130224638178\">\n<p>通过对文件描述符的开放和关闭，可以控制父进程和子进程之间的读写操作。</p>\n<ul>\n<li>如：父进程关闭读取的 fd[0]，只保留写入的 fd[1]；子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>\n<li>便可以实现从父进程向子进程的数据写入</li>\n</ul>\n<p>实现多个进程之间匿名管道的通信另一种方式就是fork两个子进程，关闭父进程的文件描述符，开启子进程的<code>fd</code>，实现子进程之间的通信。</p>\n<p>可以看出来，匿名管道的通信范围仅限于父子关系的进程。因为管道没有实体，没有管道文件，只能通过复制父进程的fd来使用文件描述符。</p>\n<h4 id=\"命名管道\"><a href=\"#命名管道\" class=\"headerlink\" title=\"命名管道\"></a>命名管道</h4><ul>\n<li>在linux中可以通过<code>mkfifo</code>命令来创建并指定管道名字</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkfifo</span> myPipe<br></code></pre></td></tr></table></figure>\n<p>因为命名管道，提前创建了一个类型为管道的设备文件，在进程中只要使用到这个设备，便可以互相通信。</p>\n<p><strong>管道的通信方式，效率较低，不适合进程间的频繁交换数据</strong></p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><blockquote>\n<p>在管道通信的缺点下，消息队列可以解决进程间频繁交换数据的问题。</p>\n</blockquote>\n<p>消息队列是保护在内核中的消息列表，如果进程之间需要进行通信，只需要将消息放在对应的消息队列中便可以正常返回，无需阻塞等待，等到另一个进程需要的时候去消息队列中去读取便可以。</p>\n<p>如果消息队列没有释放或者没有关闭操作系统，消息队列会一直存在，而匿名管道则是随着进程的生命周期的结束而销毁。</p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li><p>解决频繁交换数据的问题</p>\n<p>两个进程之间就像发邮件一样可以你来我往进行沟通</p>\n</li>\n<li><p>进程发送消息后无需阻塞等待消息的接收</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>不适合比较大的数据传输</p>\n<p>消息队列中的消息体是由结构化的数据结构来组织的，有最大长度的限制。</p>\n</li>\n<li><p>消息队列的通信过程中，存在用户态与内核态之间的数据拷贝开销</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>共享内存用到的是现代操作系统中的内存管理的<strong>虚拟内存技术</strong>，每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。</p>\n<p><strong>共享内存的机制：拿出一块虚拟地址空间，映射到相同的物理内存中。</strong>不同的进程可以使用各自的虚拟地址访问到这一片相同的物理内存。</p>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130232827259.png\" class=\"\" title=\"image-20240130232827259\">\n<ul>\n<li><p>优点</p>\n<ul>\n<li>解决了消息队列中不适合大的数据的通信</li>\n<li>不同进程之间无需进行频繁的用户态和内核态的转换，因为进程都是在自己的用户地址空间中来进行操作</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>对共享内存的读写问题</p>\n<p>因为共享内存存储的信息一旦发生改变对于不同的进程都是可见的，所以会涉及到读写一致性的问题</p>\n</li>\n<li><p>共享内存也变为了临界资源，存在进程进程之间的竞争</p>\n<p>需要保护机制，使得共享资源在任意时刻只能被一个进程访问。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><blockquote>\n<p>信号量可以提供对临界资源的保护</p>\n</blockquote>\n<p>信号量是一个整型的计数器，可以用于实现进程间的互斥以及同步，不是用于缓存进程间通信的数据。</p>\n<p>信号量的大小表示为资源的数量，对信号量的操作方式有两种原子操作</p>\n<ul>\n<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li>\n<li>一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>\n</ul>\n<p>通过PV操作可以控制进程对资源的互斥访问以及控制进程的同步顺序，<strong>涉及到操作系统的知识</strong></p>\n<h3 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h3><blockquote>\n<p>在进程工作异常情况下，需要通过信号来通知进程</p>\n</blockquote>\n<p>信号是进程间通信机制中的唯一的异步通信方式，因为可以在任何时候发送信号到某一进程，一旦有信号产生，用户就可以进行对信号处理。</p>\n<ul>\n<li><p>信号的处理方式</p>\n<ul>\n<li>执行默认操作： 例如linux中的SIGTERM 信号，就是终止进程的意思</li>\n<li>捕捉信号：可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数</li>\n<li>忽略信号：当不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。</li>\n</ul>\n</li>\n<li><p><code>SIGKILL</code> 和 <code>SEGSTOP</code>无法被捕捉和忽略。</p>\n</li>\n</ul>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>Socket通信实现的是在不同主机之间的通信，分为两种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式</p>\n<blockquote>\n<p>基于 TCP 协议的通信方式需要客户和服务器之间建立TCP连接，进行三次握手。</p>\n</blockquote>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234627976.png\" class=\"\" title=\"image-20240130234627976\">\n<ul>\n<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>\n<li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li>\n<li>服务端调用 <code>listen</code>，进行监听；</li>\n<li>服务端调用 <code>accept</code>，等待客户端连接；</li>\n<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>\n<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>\n<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>\n<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>\n</ul>\n<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>\n<p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>\n<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>\n<blockquote>\n<p>基于UDP的Socket通信</p>\n</blockquote>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234754230.png\" class=\"\" title=\"image-20240130234754230\">\n<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>\n<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>\n<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>\n","cover_type":"img","excerpt":"","more":"<h2 id=\"进程间的通信方式\"><a href=\"#进程间的通信方式\" class=\"headerlink\" title=\"进程间的通信方式\"></a>进程间的通信方式</h2><p>每个进程的用户地址空间是独立的，一般情况之下，不同的进程是<strong>无法</strong>通过进程间各自的地址空间来进行互相访问，但是不同的进程所拥有的内核空间是共享的，因此如果不同进程之间需要进行通信必须要通过内核。</p>\n<h3 id=\"管道通信\"><a href=\"#管道通信\" class=\"headerlink\" title=\"管道通信\"></a>管道通信</h3><p>管道通信分为匿名管道和命名管道，通过名字可以区分，匿名管道是无法获取和控制的管道，命名管道是通过用户可以自己建立的管道。</p>\n<p>管道智能进行半双工的通信，即数据传输是单向的，如果想要实现互相通信，就需要创建两个管道。</p>\n<h4 id=\"匿名管道\"><a href=\"#匿名管道\" class=\"headerlink\" title=\"匿名管道\"></a>匿名管道</h4><ul>\n<li>在linux中的<code>|</code>竖线就是一个管道，将管道符前的操作的输出作为管道符后的操作的输入</li>\n</ul>\n<p>一个匿名管道的创建会使用到下面的系统调用</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pipe</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> fd[<span class=\"hljs-number\">2</span>])</span></span>;<br></code></pre></td></tr></table></figure>\n<p>表示创建了一个匿名管道并返回了两个文件描述符，一个是管道读取端的描述符<code>fd[0]</code>，另一个是管道写入端的描述符<code>fd[1]</code>，<strong>匿名管道是特殊的文件，只存在于内存当中，不存在于文件系统中</strong></p>\n<p>管道实际上就是内核中的一串缓存，进程通过文件描述符来对这一串缓存进行读写操作</p>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130223824673.png\" class=\"\" title=\"image-20240130223824673\">\n<p><strong>如果说需要实现多个进程之间的通信</strong>，可以使用<code>fork</code>操作来创建子进程，创建子进程时，子进程会同时复制父进程的文件描述符，两个进程便可以通过各自的文件描述符来进行跨进程之间的通信。</p>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130224638178.png\" class=\"\" title=\"image-20240130224638178\">\n<p>通过对文件描述符的开放和关闭，可以控制父进程和子进程之间的读写操作。</p>\n<ul>\n<li>如：父进程关闭读取的 fd[0]，只保留写入的 fd[1]；子进程关闭写入的 fd[1]，只保留读取的 fd[0]；</li>\n<li>便可以实现从父进程向子进程的数据写入</li>\n</ul>\n<p>实现多个进程之间匿名管道的通信另一种方式就是fork两个子进程，关闭父进程的文件描述符，开启子进程的<code>fd</code>，实现子进程之间的通信。</p>\n<p>可以看出来，匿名管道的通信范围仅限于父子关系的进程。因为管道没有实体，没有管道文件，只能通过复制父进程的fd来使用文件描述符。</p>\n<h4 id=\"命名管道\"><a href=\"#命名管道\" class=\"headerlink\" title=\"命名管道\"></a>命名管道</h4><ul>\n<li>在linux中可以通过<code>mkfifo</code>命令来创建并指定管道名字</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-built_in\">mkfifo</span> myPipe<br></code></pre></td></tr></table></figure>\n<p>因为命名管道，提前创建了一个类型为管道的设备文件，在进程中只要使用到这个设备，便可以互相通信。</p>\n<p><strong>管道的通信方式，效率较低，不适合进程间的频繁交换数据</strong></p>\n<h3 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h3><blockquote>\n<p>在管道通信的缺点下，消息队列可以解决进程间频繁交换数据的问题。</p>\n</blockquote>\n<p>消息队列是保护在内核中的消息列表，如果进程之间需要进行通信，只需要将消息放在对应的消息队列中便可以正常返回，无需阻塞等待，等到另一个进程需要的时候去消息队列中去读取便可以。</p>\n<p>如果消息队列没有释放或者没有关闭操作系统，消息队列会一直存在，而匿名管道则是随着进程的生命周期的结束而销毁。</p>\n<ul>\n<li><p>优点</p>\n<ul>\n<li><p>解决频繁交换数据的问题</p>\n<p>两个进程之间就像发邮件一样可以你来我往进行沟通</p>\n</li>\n<li><p>进程发送消息后无需阻塞等待消息的接收</p>\n</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>不适合比较大的数据传输</p>\n<p>消息队列中的消息体是由结构化的数据结构来组织的，有最大长度的限制。</p>\n</li>\n<li><p>消息队列的通信过程中，存在用户态与内核态之间的数据拷贝开销</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"共享内存\"><a href=\"#共享内存\" class=\"headerlink\" title=\"共享内存\"></a>共享内存</h3><p>共享内存用到的是现代操作系统中的内存管理的<strong>虚拟内存技术</strong>，每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。</p>\n<p><strong>共享内存的机制：拿出一块虚拟地址空间，映射到相同的物理内存中。</strong>不同的进程可以使用各自的虚拟地址访问到这一片相同的物理内存。</p>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130232827259.png\" class=\"\" title=\"image-20240130232827259\">\n<ul>\n<li><p>优点</p>\n<ul>\n<li>解决了消息队列中不适合大的数据的通信</li>\n<li>不同进程之间无需进行频繁的用户态和内核态的转换，因为进程都是在自己的用户地址空间中来进行操作</li>\n</ul>\n</li>\n<li><p>缺点</p>\n<ul>\n<li><p>对共享内存的读写问题</p>\n<p>因为共享内存存储的信息一旦发生改变对于不同的进程都是可见的，所以会涉及到读写一致性的问题</p>\n</li>\n<li><p>共享内存也变为了临界资源，存在进程进程之间的竞争</p>\n<p>需要保护机制，使得共享资源在任意时刻只能被一个进程访问。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"信号量\"><a href=\"#信号量\" class=\"headerlink\" title=\"信号量\"></a>信号量</h3><blockquote>\n<p>信号量可以提供对临界资源的保护</p>\n</blockquote>\n<p>信号量是一个整型的计数器，可以用于实现进程间的互斥以及同步，不是用于缓存进程间通信的数据。</p>\n<p>信号量的大小表示为资源的数量，对信号量的操作方式有两种原子操作</p>\n<ul>\n<li>一个是 <strong>P 操作</strong>，这个操作会把信号量减去 1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;= 0，则表明还有资源可使用，进程可正常继续执行。</li>\n<li>一个是 <strong>V 操作</strong>，这个操作会把信号量加上 1，相加后如果信号量 &lt;= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li>\n</ul>\n<p>通过PV操作可以控制进程对资源的互斥访问以及控制进程的同步顺序，<strong>涉及到操作系统的知识</strong></p>\n<h3 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h3><blockquote>\n<p>在进程工作异常情况下，需要通过信号来通知进程</p>\n</blockquote>\n<p>信号是进程间通信机制中的唯一的异步通信方式，因为可以在任何时候发送信号到某一进程，一旦有信号产生，用户就可以进行对信号处理。</p>\n<ul>\n<li><p>信号的处理方式</p>\n<ul>\n<li>执行默认操作： 例如linux中的SIGTERM 信号，就是终止进程的意思</li>\n<li>捕捉信号：可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数</li>\n<li>忽略信号：当不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。</li>\n</ul>\n</li>\n<li><p><code>SIGKILL</code> 和 <code>SEGSTOP</code>无法被捕捉和忽略。</p>\n</li>\n</ul>\n<h3 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h3><p>Socket通信实现的是在不同主机之间的通信，分为两种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式</p>\n<blockquote>\n<p>基于 TCP 协议的通信方式需要客户和服务器之间建立TCP连接，进行三次握手。</p>\n</blockquote>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234627976.png\" class=\"\" title=\"image-20240130234627976\">\n<ul>\n<li>服务端和客户端初始化 <code>socket</code>，得到文件描述符；</li>\n<li>服务端调用 <code>bind</code>，将绑定在 IP 地址和端口;</li>\n<li>服务端调用 <code>listen</code>，进行监听；</li>\n<li>服务端调用 <code>accept</code>，等待客户端连接；</li>\n<li>客户端调用 <code>connect</code>，向服务器端的地址和端口发起连接请求；</li>\n<li>服务端 <code>accept</code> 返回用于传输的 <code>socket</code> 的文件描述符；</li>\n<li>客户端调用 <code>write</code> 写入数据；服务端调用 <code>read</code> 读取数据；</li>\n<li>客户端断开连接时，会调用 <code>close</code>，那么服务端 <code>read</code> 读取数据的时候，就会读取到了 <code>EOF</code>，待处理完数据后，服务端调用 <code>close</code>，表示连接关闭。</li>\n</ul>\n<p>这里需要注意的是，服务端调用 <code>accept</code> 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>\n<p>所以，监听的 socket 和真正用来传送数据的 socket，是「<strong>两个</strong>」 socket，一个叫作<strong>监听 socket</strong>，一个叫作<strong>已完成连接 socket</strong>。</p>\n<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>\n<blockquote>\n<p>基于UDP的Socket通信</p>\n</blockquote>\n<img src=\"/2024/01/30/%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/image-20240130234754230.png\" class=\"\" title=\"image-20240130234754230\">\n<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>\n<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>\n<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>\n"}],"PostAsset":[{"_id":"source/_posts/GANES101现代计算机图形学入门-01/games101.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"games101.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104112951691.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104112951691.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104113151777-17084112899531.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104113151777-17084112899531.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104113151777.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104113151777.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104113201064.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104113201064.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104150955701-17084112899532.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104150955701-17084112899532.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104150955701.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104150955701.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164540980.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104164540980.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164542395.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104164542395.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164606082.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104164606082.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164704660-17084112899533.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104164704660-17084112899533.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164704660.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104164704660.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164849274-17084112899534.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104164849274-17084112899534.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104164849274.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104164849274.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104165645532-17084112899535.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104165645532-17084112899535.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231104165645532.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231104165645532.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231116154858801-17084112899536.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231116154858801-17084112899536.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231116154858801.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231116154858801.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231116155210293-17084112899537.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231116155210293-17084112899537.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-01/image-20231116155210293.png","post":"clsu1a9xp0007g4c28icxgmta","slug":"image-20231116155210293.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/games101.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"games101.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/games101_top.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"games101_top.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161524873-17084118809551.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116161524873-17084118809551.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161524873.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116161524873.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161727694-17084118809562.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116161727694-17084118809562.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161727694.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116161727694.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161842894-17084118809563.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116161842894-17084118809563.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116161842894.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116161842894.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116164956551-17084118809564.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116164956551-17084118809564.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116164956551.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116164956551.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116165833300-17084118809565.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116165833300-17084118809565.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116165833300.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116165833300.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116170519094.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116170519094.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116170520355-17084118809566.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116170520355-17084118809566.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116170520355.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116170520355.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116171040632.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116171040632.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116171041924-17084118809567.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116171041924-17084118809567.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116171041924.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116171041924.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116200444279-17084118809568.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116200444279-17084118809568.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116200444279.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116200444279.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201110927.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116201110927.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201112834-17084118809569.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116201112834-17084118809569.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201112834.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116201112834.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201139440-170841188095610.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116201139440-170841188095610.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231116201139440.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231116201139440.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231118142130480-170841188095611.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231118142130480-170841188095611.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231118142130480.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231118142130480.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231118142833380-170841188095612.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231118142833380-170841188095612.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/image-20231118142833380.png","post":"clsu1a9xr000ag4c2dayt0vir","slug":"image-20231118142833380.png","modified":1,"renderable":0},{"_id":"source/_posts/GANES101现代计算机图形学入门-02/IMG_0318(20231116-164749).PNG","post":"clsu1a9xr000ag4c2dayt0vir","slug":"IMG_0318(20231116-164749).PNG","modified":1,"renderable":0},{"_id":"source/_posts/git/image-20231204110955462.png","post":"clsu1a9xs000bg4c2h41edgfk","slug":"image-20231204110955462.png","modified":1,"renderable":0},{"_id":"source/_posts/git/image-20231204111125551.png","post":"clsu1a9xs000bg4c2h41edgfk","slug":"image-20231204111125551.png","modified":1,"renderable":0},{"_id":"source/_posts/git/image-20231204111350240.png","post":"clsu1a9xs000bg4c2h41edgfk","slug":"image-20231204111350240.png","modified":1,"renderable":0},{"_id":"source/_posts/git/image-20231204112945547.png","post":"clsu1a9xs000bg4c2h41edgfk","slug":"image-20231204112945547.png","modified":1,"renderable":0},{"_id":"source/_posts/git/image-20231204113100512.png","post":"clsu1a9xs000bg4c2h41edgfk","slug":"image-20231204113100512.png","modified":1,"renderable":0},{"_id":"source/_posts/git/image-20231204113208566.png","post":"clsu1a9xs000bg4c2h41edgfk","slug":"image-20231204113208566.png","modified":1,"renderable":0},{"_id":"source/_posts/git/image-20231204113304822.png","post":"clsu1a9xs000bg4c2h41edgfk","slug":"image-20231204113304822.png","modified":1,"renderable":0},{"_id":"source/_posts/大话设计模式/image-20231008153018253.png","post":"clsu1a9xt000fg4c25wi48691","slug":"image-20231008153018253.png","modified":1,"renderable":0},{"_id":"source/_posts/平方根倒数算法/WTF.png","post":"clsu1a9xu000gg4c27rvbc6j3","slug":"WTF.png","modified":1,"renderable":0},{"_id":"source/_posts/平方根倒数算法/运算过程.png","post":"clsu1a9xu000gg4c27rvbc6j3","slug":"运算过程.png","modified":1,"renderable":0},{"_id":"source/_posts/进程间的通信方式/image-20240130223824673.png","post":"clsu1a9xv000kg4c2cgj0a1ee","slug":"image-20240130223824673.png","modified":1,"renderable":0},{"_id":"source/_posts/进程间的通信方式/image-20240130223920751.png","post":"clsu1a9xv000kg4c2cgj0a1ee","slug":"image-20240130223920751.png","modified":1,"renderable":0},{"_id":"source/_posts/进程间的通信方式/image-20240130224638178.png","post":"clsu1a9xv000kg4c2cgj0a1ee","slug":"image-20240130224638178.png","modified":1,"renderable":0},{"_id":"source/_posts/进程间的通信方式/image-20240130232827259.png","post":"clsu1a9xv000kg4c2cgj0a1ee","slug":"image-20240130232827259.png","modified":1,"renderable":0},{"_id":"source/_posts/进程间的通信方式/image-20240130234556499.png","post":"clsu1a9xv000kg4c2cgj0a1ee","slug":"image-20240130234556499.png","modified":1,"renderable":0},{"_id":"source/_posts/进程间的通信方式/image-20240130234627976.png","post":"clsu1a9xv000kg4c2cgj0a1ee","slug":"image-20240130234627976.png","modified":1,"renderable":0},{"_id":"source/_posts/进程间的通信方式/image-20240130234754230.png","post":"clsu1a9xv000kg4c2cgj0a1ee","slug":"image-20240130234754230.png","modified":1,"renderable":0}],"PostCategory":[{"post_id":"clsu1a9xs000bg4c2h41edgfk","category_id":"clsu1a9xq0008g4c2hs0wck01","_id":"clsu1a9xu000hg4c2d68ofndd"},{"post_id":"clsu1a9xp0006g4c25wn1hv4s","category_id":"clsu1a9xq0008g4c2hs0wck01","_id":"clsu1a9xw000lg4c2bf5436z2"},{"post_id":"clsu1a9xt000fg4c25wi48691","category_id":"clsu1a9xs000dg4c2ef2mbedu","_id":"clsu1a9xw000ng4c2fqvb3eci"},{"post_id":"clsu1a9xp0007g4c28icxgmta","category_id":"clsu1a9xs000dg4c2ef2mbedu","_id":"clsu1a9xx000rg4c2ev6g0qtg"},{"post_id":"clsu1a9xu000gg4c27rvbc6j3","category_id":"clsu1a9xq0008g4c2hs0wck01","_id":"clsu1a9xx000tg4c259ov0n5n"},{"post_id":"clsu1a9xv000kg4c2cgj0a1ee","category_id":"clsu1a9xq0008g4c2hs0wck01","_id":"clsu1a9xx000vg4c291jy1png"},{"post_id":"clsu1a9xr000ag4c2dayt0vir","category_id":"clsu1a9xs000dg4c2ef2mbedu","_id":"clsu1a9xx000xg4c2e69v9c6w"},{"post_id":"clsu1a9xs000cg4c26mlshfag","category_id":"clsu1a9xw000pg4c2dgc1594l","_id":"clsu1a9xy000zg4c26uvb7xf6"}],"PostTag":[{"post_id":"clsu1a9xp0006g4c25wn1hv4s","tag_id":"clsu1a9xr0009g4c2fgdsd74t","_id":"clsu1a9xw000mg4c2d008hgv9"},{"post_id":"clsu1a9xp0006g4c25wn1hv4s","tag_id":"clsu1a9xt000eg4c2fg4b9u1p","_id":"clsu1a9xw000og4c2b2jy0847"},{"post_id":"clsu1a9xp0007g4c28icxgmta","tag_id":"clsu1a9xu000jg4c22rk95y5h","_id":"clsu1a9xx000sg4c23ecm4kdc"},{"post_id":"clsu1a9xr000ag4c2dayt0vir","tag_id":"clsu1a9xu000jg4c22rk95y5h","_id":"clsu1a9xx000wg4c2bq7u580d"},{"post_id":"clsu1a9xs000bg4c2h41edgfk","tag_id":"clsu1a9xx000ug4c2h8eb407a","_id":"clsu1a9xy0010g4c2dlgh3qv7"},{"post_id":"clsu1a9xs000cg4c26mlshfag","tag_id":"clsu1a9xx000yg4c2bggxh42k","_id":"clsu1a9xy0012g4c26rqjg6ig"},{"post_id":"clsu1a9xt000fg4c25wi48691","tag_id":"clsu1a9xy0011g4c25mhz8ukg","_id":"clsu1a9xy0014g4c2c5ra0etu"},{"post_id":"clsu1a9xu000gg4c27rvbc6j3","tag_id":"clsu1a9xy0013g4c262mk008q","_id":"clsu1a9xz0017g4c268i21qyg"},{"post_id":"clsu1a9xu000gg4c27rvbc6j3","tag_id":"clsu1a9xy0015g4c265ml9mlg","_id":"clsu1a9xz0018g4c25h2s4yqa"},{"post_id":"clsu1a9xv000kg4c2cgj0a1ee","tag_id":"clsu1a9xy0016g4c2989sgt49","_id":"clsu1a9xz001ag4c2gn3zeywn"},{"post_id":"clsu1a9xv000kg4c2cgj0a1ee","tag_id":"clsu1a9xz0019g4c2chawb4lf","_id":"clsu1a9xz001bg4c22vay6q1u"}],"Tag":[{"name":"C++","_id":"clsu1a9xr0009g4c2fgdsd74t"},{"name":"zlib","_id":"clsu1a9xt000eg4c2fg4b9u1p"},{"name":"计算机图形学 GAMES101","_id":"clsu1a9xu000jg4c22rk95y5h"},{"name":"git","_id":"clsu1a9xx000ug4c2h8eb407a"},{"name":"leetcode 算法 数组 字符串","_id":"clsu1a9xx000yg4c2bggxh42k"},{"name":"设计模式 UML","_id":"clsu1a9xy0011g4c25mhz8ukg"},{"name":"数学","_id":"clsu1a9xy0013g4c262mk008q"},{"name":"算法","_id":"clsu1a9xy0015g4c265ml9mlg"},{"name":"操作系统","_id":"clsu1a9xy0016g4c2989sgt49"},{"name":"进程通信","_id":"clsu1a9xz0019g4c2chawb4lf"}]}}