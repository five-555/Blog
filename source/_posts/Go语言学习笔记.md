---
title: Go语言基本语法
urlname: Go语言基本语法
date: 2023-12-14 17:16:50
tags: [go语言 并发]
categories: Go语言学习笔记
---

## 基本语法

### GO语言特性

* 并发编程

  Go语言中引入了`goroutine`，通过调用`go`关键字，可以让函数以goroutine的方式进行运行，以协程为单位进行运行。

  协程相比线程更加轻量级，也更节省系统资源。

  goroutine内部采用管道`channel`进行消息传递，从而实现共享内存。

* 错误处理

  函数通过返回错误类型`error`或者`bool`类型表明函数执行结果，通过判断返回值是否为`nil`。

  引入了defer关键字用于标准的错误处理流程，提供内置函数`panic`，`recover`完成异常抛出和捕捉

* 垃圾回收

  自带自动回收功能，不需要`delete`和`free`来释放内存

* 多返回值

  支持多返回值，可以用下划线作为占用符丢掉不要的返回值

* 匿名函数

  支持常规的匿名函数和闭包

```go
// hello.go

package main

import (
    "fmt" //导入fmt包，调用其中的Println()函数
)

func main() {
    fmt.Println("Hello，world！")
}
```

### 数据类型

* 常量

  使用`const`声明，可以限定常量类型，也可以不指定类型（称为字面常量）

```
const limit = 512
const top uint16 = 1421
const Pi float64 = 3.1415926
// 多重赋值
const x,y int = 1,2

// 多个常量赋值
const (
	one = 1
	two = 2
)
```

* iota

  `iota`是一个可以被编译器修改的常量，在`const`关键字出现时被重置为`0`，在下一个`const`出现之前，每出现一次`iota`，所代表的数字自动加1

```
const (
    a = iota  //a == 0
    b = iota  //b ==1
    c = iota  //c == 2
)

const d = iota //d==0,因为const的出现，iota被重置为0
```

* 变量

  变量使用`var`进行声明，可以使用`:=`对变量之间进行初始化，Go编译器会自动推导出该变量的类型

* 整型

  可以通过`unsafe.Sizeof`函数来查看字节长度

| 类型      | 说明                                                         |
| :-------- | :----------------------------------------------------------- |
| `byte`    | 等同于 uint8，uint8的别名                                    |
| `int`     | 依赖于不同平台下的实现，可以是 int32 或者 int64              |
| `int8`    | [-128, 127]                                                  |
| `int16`   | [-32768, 32767]                                              |
| `int32`   | [-2147483648, 2147483647]                                    |
| `int64`   | [-9223372036854775808, 9223372036854775807]                  |
| `rune`    | 等同于 int32，代表Unicode字符类型                            |
| `uint`    | 依赖于不同平台下的实现，可以是 uint32 或者 uint64            |
| `uint8`   | [0, 255]                                                     |
| `uint16`  | [0, 65535]                                                   |
| `uint32`  | [0, 4294967295]                                              |
| `uint64`  | [0, 18446744073709551615]                                    |
| `uintptr` | 一个可以恰好容纳指针值的无符号整型（对 32 位平台是 uint32, 对 64 位平台是 uint64） |

* 浮点类型

| 类型      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| float32   | ±3.402 823 466 385 288 598 117 041 834 845 169 254 40x1038 计算精度大概是小数点后 7 个十进制数 |
| float64   | ±1.797 693 134 862 315 708 145 274 237 317 043 567 981x1038 计算精度大概是小数点后 15 个十进制数 |
| complex32 | 复数，实部和虚部都是 float32                                 |
| complex64 | 复数，实部和虚部都是 float64                                 |

* 布尔类型

  `true`和`false`：布尔类型不能接受其他类型的赋值，不支持自动或强制的类型转换。

* 字符串

  * 字符串可以使用双引号`("")`或者反引号来创建。双引号用来创建可解析的字符串字面量，可解析的是指字符串中的一些符号可以被格式化为其他内容，如 `\n` 在在输出时候会被格式化成换行符，如果需要按照原始字符输出必须进行转义。而反引号创建的字符串原始是什么样，那输出还是什么，不需要进行任何转义。

  * 支持切片操作：对字符串中字符依次访问，可以使用 `range` 操作符。获取字符串的长度可能有两种含义，一种是指获取字符串的字节长度，一种是指获取字符串的字符数量。

  支持的操作

| 语法             | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| `s += t`         | 将字符串 t 追加到 s 末尾                                     |
| `s + t`          | 将字符串 s 和 t 级联                                         |
| `s[n]`           | 从字符串 s 中索引位置为 n 处的原始字节                       |
| `s[n:m]`         | 从位置 n 到位置 `m-1` 处取得的字符（字节）串                 |
| `s[n:]`          | 从位置 n 到位置 `len(s)-1` 处取得的字符（字节）串            |
| `s[:m]`          | 从位置 0 到位置 `m-1` 处取得的字符（字节）串                 |
| `len(s)`         | 字符串 s 中的字节数                                          |
| `len([]rune(s))` | 字符串 s 中字符的个数，可以使用更快的方法 `utf8.RuneCountInString()` |
| `[]rune(s)`      | 将字符串 s 转换为一个 unicode 值组成的串                     |
| `string(chars)`  | chars 类型是 `[]rune` 或者 `[]int32`, 将之转换为字符串       |
| `[]byte(s)`      | 无副本的将字符串 s 转换为一个原始的字节的切片数组，不保证转换的字节是合法的 UTF-8 编码字节 |

### 顺序编程

* if

  `if`后面可以紧接一个表达式`optionalStatement1`，表达式会在进入`block`前执行，决定进入`block`分支的是布尔表达式`booleanExpression1`

```go
if optionalStatement1; booleanExpression1 {
    block1
} else if optionalStatement2; booleanExpression2 {
    block2
} else {
    block3
}
```

* for

  `for`循环可以遍历数组，切片，映射等类型，也可以用于无限循环

```go
for { // 无限循环
    block
}

for booleanExpression { // while循环，在Go语言中没有while关键字

}

for index, char := range aString { // 迭代字符串

}

for item := range aChannel { // 迭代通道

}
```

* goto

  `goto`可以实现跳转，在程序代码前定义一个标签以后可以使用goto跳转到标签

* switch

**类型处理**

* 类型转换

* 类型断言

  将空接口类型转化为我们所需要的类型，这个操作称为类型断言。（有点难懂）

**defer**

* 当函数执行到最后时，`defer`语句会按照逆序执行，最后该函数返回，`defer`会在`return`之后执行。

### 面向对象编程

* 自定义类型及结构体

  Go的代码是以包结构来组织的，如果标识符（变量名，函数名，自定义类型），以大写字母开头的标识符是可以导出的，可以在任何导入了定义该标识符的包中使用，Go语言不支持继承，只支持组合。

  * 

* 方法

* 组合

* 接口

  > 接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。接口指定类型应具有的方法，类型决定如何实现这些方法。

  接口定义了一组方法的集合，任何类型只要实现了接口中定义的所有方法，就被认为实现了该接口。

  接口在Go中的实现方式是隐式的，无需显性地声明，这种设计允许对象在不同的上下文中被看作是不同的类型，从而实现了多态性。

```go
package main

import "fmt"

// Animal 接口定义了 Speak 方法
type Animal interface {
    Speak() string
}

// Dog 类型实现了 Animal 接口
type Dog struct{}

func (d Dog) Speak() string {
    return "Woof!"
}

// Cat 类型实现了 Animal 接口
type Cat struct{}

func (c Cat) Speak() string {
    return "Meow!"
}

func main() {
    // 定义一个接口类型的变量
    var animal Animal

    // 可以将不同类型的对象赋值给接口变量
    animal = Dog{}
    fmt.Println(animal.Speak()) // 输出: Woof!

    animal = Cat{}
    fmt.Println(animal.Speak()) // 输出: Meow!
}
```

