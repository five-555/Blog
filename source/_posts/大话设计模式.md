---
title: 大话设计模式
date: 2024-02-20 15:09:00
tags: [设计模式 UML]
categories: 学习笔记
cover:
top_img:
---
## 一、简单工厂模式

> 注意：命名规范、多个分支使用switch、考虑异常情况

面向对象的编程，对代码做到：可维护、可复用、灵活性好

* 业务的封装

  前后端分离，将业务逻辑和界面逻辑分开，让他们之间的耦合度下降，可以依赖面向对象的三大特性来实现

* 工厂模式

  通过工厂类，传入不同的字符串来返回不同继承类的构造函数，需要实例哪一个子类，可以通过传入参数来进行选择

  可以使用switch，或者使用map映射等方式

* UML类图

  * 依赖关系
  * 聚合关系
  * 合成关系
  * 继承关系
  * 关联关系
  * 接口关系
  * 泛化关系

![image-20231008153018253](大话设计模式/image-20231008153018253.png)

## 二、策略模式

> 策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的用户。

只有算法需要替换，而其它不需要替换

使用策略类，定义所有支持算法的公共接口

* 策略模式是一种定义一系列算法的方法，所有这些算法完成的是相同的工作，但是实现不同，可以以相同的方式调用所有的方法，减少了各种算法类与使用算法类之间的耦合
* 策略模式的优点可以简化单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试

```
策略模式的三个要点
1、基类，策略接口，用于子类继承该基类，并重写基类中的策略方法
2、具体的策略类，不同的策略类使用不同的方法来实现基类的虚方法
3、上下文，context，在上下文中，通过一个公共的方法，来调用不同子类实现的虚方法（使用传入不同子类对象来实现）

用户只需要使用context来使用不同对象传入即可以完成不同的策略选择
```

## 三、单一职责原则

> 对于一个类而言，应该仅有一个引起它变化的原因。
>
> 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。

## 四、开放-封闭原则

**软件实体（类、模块、函数等）应该可以扩展但不可修改，即对拓展开放，对修改封闭**

##  五、依赖倒置原则

1、高层模块不应该依赖底层模块，两个都应该依赖抽象

2、抽象不应该依赖细节，细节应该依赖抽象

* 里氏代换原则

  一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。

  即：子类型必须能够替换掉它们的父类型

```
和策略模式有一定的相似之处，例子

Device类
class Device:
    def turn_on(self):
        pass

    def turn_off(self):
        pass

子类
class Light(Device):
    def turn_on(self):
        print("Light is turned on")

    def turn_off(self):
        print("Light is turned off")

class Fan(Device):
    def turn_on(self):
        print("Fan is turned on")

    def turn_off(self):
        print("Fan is turned off")

class Speaker(Device):
    def turn_on(self):
        print("Speaker is turned on")

    def turn_off(self):
        print("Speaker is turned off")

高层模块
class DeviceController:
    def __init__(self, device):
        self.device = device

    def operate(self):
        self.device.turn_on()

    def stop(self):
        self.device.turn_off()

main
if __name__ == "__main__":
    light = Light()
    fan = Fan()
    speaker = Speaker()

    controller1 = DeviceController(light)
    controller2 = DeviceController(fan)
    controller3 = DeviceController(speaker)

    controller1.operate()
    controller2.operate()
    controller3.operate()

    controller1.stop()
    controller2.stop()
    controller3.stop()
高层模块 DeviceController 不直接依赖于具体的设备类（如 Light、Fan 和 Speaker），而是依赖于抽象的 Device 接口。这就是依赖倒置原则的应用，它使得高层模块更加灵活，可以轻松地切换和扩展不同类型的设备，而不需要修改高层模块的代码。这有助于创建松耦合的、易于维护和扩展的代码
```



## 六、装饰模式

**动态地给一个对象添加一些额外的职责**，就增加功能来说，装饰模式比生成子类更为灵活

在子类中定义一个父类对象，该对象使用需要装饰的对象作为初始化，并在子类中对该对象进行操作，即可达到，对对象的额外装饰结果，但是这一个对象和之前的对象不一定是同一个对象。

* 基本结构

```
1、父类：父类定义一个抽象的方法
2、子类：子类继承父类抽象方法并添加一些最基本的属性
3、装饰器类：装饰器类继承父类，并定义一个父类的保护类型数据
4、不同的装饰器类：不同的装饰器类继承于装饰器类，重写各自装饰器需要添加的职责

通常第“2”步中定义基本属性的子类，会作为第一层装饰包装子类，后续会作为参数传入到装饰器类中
```

装饰模式可以把类中的装饰功能从类中搬移去除，这样就可以简化原有的类。同事有效地把类的核心职责和装饰功能区分开，去除相关类中的重复的装饰逻辑，重复的装饰逻辑可以使用一个子类作为最基类型。

```
exp：
游戏中，不同人物角色使用不同技能进行装饰。最开始都是有一个人物的基类（低级的时候）。公共技能可以作为重复逻辑继承在一个类中，使用装饰模式，可以学习一些不同的技能。
```

## 七、代理模式

代理模式，为其它对象提供一种代理以控制对这个对象的访问

在客户与另一客户交互的过程中，中间会有一层代理，代理可以拥有两个客户的接口，作为中间实体来进行来促使两客户进行交互，在代理中如果需要交互，则需要定义一个客户的类，来调用该客户的方法。

* 代理模式应用场景

  远程代理：为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实

  虚拟代理：根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，浏览器中加载图片就是使用虚拟代理

  安全代理：用来控制真实对象访问时的权限

  智能指引：当掉哟个真实对象时，代理处理另外一些事

## 八、工厂方法模式

封装实例来创建过程，可以让创建实例的过程封装到工厂类中，避免耦合




## 九、原型模式

用原型（Prototype）实例指定创建对象的种类，并且通过复制这些原型创建新的对象

* 用法

  在类里面定义一个函数，函数可以返回一个原型对象

* 在类中定义修改原型中属性的set方法

* 在使用的过程中，只需要调用set方法修改不同的地方

深拷贝与浅拷贝，若在原型类中使用对象引用，在修改的时候记得使用深拷贝



## 十、模板方法模式

定义一个操作中的算法的骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤



## 十一、迪米特法则

> 最小知识原则

如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。