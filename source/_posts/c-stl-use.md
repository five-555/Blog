---
title: C++中常见容器的使用方法
categories: 技术研究
date: 2024-07-12 09:52:08
tags:
cover:
top_img:
---


# 序列容器

> 不知道如何解释，凭感觉吧，就是我们想象中的那样。

## vector

`vector`是我们常用的动态数组，它通过模板泛型编程的方式，让我们能够使用`vector`来存储任意对象。

`vector`的底层是内存当中一段连续的地址空间，地址空间连续的最大好处就是能够支持用户的随机访问，我们可以和操作数组一样，使用下标的方式来获取到容器中的对象。在`vector`中有两个关键的成员变量`size`和`capacity`，其中`size`表示的是当前容器中存储的对象实际个数，而`capacity`则是容器的最大容量。这两个成员是实现`vector`扩容的关键。


**常用的接口**

| 类别     | 成员函数                 | 描述                                                   |
|----------|--------------------------|--------------------------------------------------------|
| 容量相关 | `size()`                 | 返回容器中元素的个数。                                 |
|          | `max_size()`             | 返回容器所能容纳的最大元素数量。                       |
|          | `resize(n, val)`         | 调整容器的大小到 `n` 个元素，如果 `n` 大，则以 `val` 填充新位置。 |
|          | `capacity()`             | 返回不需要重新分配内存空间的情况下容器可容纳的元素数量。|
|          | `empty()`                | 检测容器是否为空。                                     |
|          | `reserve(n)`             | 请求容器容量至少为 `n` 个元素。                        |
|          | `shrink_to_fit()`        | 请求减少容器容量以节省空间。（C++11）                  |
| 修改内容 | `clear()`                | 移除所有元素，容器大小变为 0。                         |
|          | `insert(pos, elem)`      | 在迭代器 `pos` 指定的位置插入元素 `elem`。             |
|          | `emplace(position, args...)` | 在迭代器 `position` 指定的位置就地构造元素。（C++11）|
|          | `erase(pos)`             | 删除迭代器 `pos` 指定位置上的元素。                    |
|          | `push_back(elem)`        | 在容器尾部添加一个新元素 `elem`。                      |
|          | `emplace_back(args...)`  | 在容器尾部就地构造一个新元素。（C++11）                |
|          | `pop_back()`             | 移除容器尾部的最后一个元素。                           |
|          | `resize(n)`              | 改变容器中元素的数量为 `n`。                           |
|          | `swap(vec)`              | 与另一个同类型向量 `vec` 交换数据。                    |
| 元素访问 | `operator[]`             | 访问指定位置的元素。                                   |
|          | `at(index)`              | 访问指定位置的元素，包含边界检查。                     |
|          | `front()`                | 访问第一个元素。                                       |
|          | `back()`                 | 访问最后一个元素。                                     |
|          | `data()`                 | 返回指向容器头部元素的指针。                           |
| 迭代器   | `begin()` / `cbegin()`   | 返回指向容器开始的迭代器。                             |
|          | `end()` / `cend()`       | 返回指向容器结束（最后元素的下一个位置）的迭代器。     |
|          | `rbegin()` / `crbegin()` | 返回反向迭代器的起始位置。                             |
|          | `rend()` / `crend()`     | 返回反向迭代器的结束位置。                             |

* `vector`扩容机制
    
    > 通常能够触发扩容的行为有：往容器中添加元素、使用`resize`或`reserve`使大小超过容量、通过构造函数初始化超出默认容量

    `vector`扩容机制是通过重新分配内存来实现的，当向容器中添加元素，并且元素的数量超过了其内部数组容量时，会自动触发扩容。

    1、重新分配：首先，`vector` 会申请一个新的、更大的内存块来存储元素。新容量通常是当前容量的两倍，但这个增长因子并不是标准规定的，可能因不同的库实现而异。

    2、拷贝或移动元素：现有元素会被拷贝（或移动，如果它们支持 `move` 语义）到新的内存地址。

    3、释放旧内存：一旦旧元素被成功转移，原来的内存块将被释放。

    4、更新容量：`vector` 更新其容量值以反映新内存块的大小。

* `reserve`和`resize`
 
    如果我们能够预知到我们需要使用的`vector`容器的最大个数，我们可以使用`reserve`来为我们需要用到的容器，提前申请一片足够大的内存，这样就可以保证在程序运行过程中不需要去对容器进行扩容，因为`vector`的扩容是一个代价相对较大的一件事。

    `resize`是重新为容器设置`size`大小，如果容器当前的对象大于设置的`size`，则容器会被截断，如果小于，则会使用默认构造去填充新的后续空间，如果比`capacity`还要大，会涉及到触发容器的扩容。

    `reserve`是重新设置容量的大小，不会更改`size`的值，只有当需要申请的容量大于`capacity`，才会起作用，否则不会起任何作用。

* `push_back`和`emplace_back`

    使用`push_back()`向`vector`添加元素时，是在向函数传递一个已经存在的对象。这个对象是通过调用拷贝构造函数或移动构造函数来添加到容器末尾的。如果传递的是左值（例如一个变量），那么会调用拷贝构造函数；如果传递的是右值，则会调用移动构造函数（前提是该类型支持移动语义）。

    `emplace_back()`不需要传入一个已经构造好的对象，而是接受任意数量和类型的参数，并将它们直接传递给元素类型的构造函数。也就是说`emplace_back()`试图在容器管理的内存区域中直接构造对象，避免了额外的拷贝或移动步骤。

## list

`list`是我们常用的双向链表，通过节点来组织起来的数据结构，节点中会存有两个指针分别用来指向下一个节点的地址，和上一个节点的地址，通过链接的方式就能够形成一个双向链表的结构。通常链表在内存当中的地址并不是连续的，所以链表并不支持随机存取，无法通过下标的方式来进行访问。但是相比于`vector`来说，链表对于插入和删除工作来说更具有优势。

其实，我们能够很容易的自己构建自己的链表，只需要定义一个包含指向下一个节点的指针就可以了，所以在实际应用中，我个人用`list`这个数据结构并不是很多。自己的链表可以根据实际业务来给定相关特定的属性。

**常用的接口**

| 类别         | 成员函数                       | 描述                                                         |
|--------------|--------------------------------|--------------------------------------------------------------|
| 容量相关     | `size()`                       | 返回容器中元素的个数。                                       |
|              | `empty()`                      | 检查容器是否为空。                                           |
|              | `max_size()`                   | 返回容器所能容纳的最大元素数量。                             |
| 修改内容     | `clear()`                      | 移除所有元素，容器大小变为 0。                               |
|              | `insert(position, val)`        | 在迭代器 `position` 指定的位置插入值为 `val` 的元素。       |
|              | `emplace(position, args...)`   | 在迭代器 `position` 指定的位置就地构造元素。（C++11）      |
|              | `erase(position)` / `erase(first, last)` | 删除位于迭代器 `position` 或 `[first, last)` 范围内的元素。|
|              | `push_back(val)`               | 在容器尾部添加一个新元素。                                   |
|              | `emplace_back(args...)`        | 在容器尾部就地构造一个新元素。（C++11）                     |
|              | `pop_back()`                   | 移除容器尾部的最后一个元素。                                 |
|              | `push_front(val)`              | 在容器头部添加一个新元素。                                   |
|              | `emplace_front(args...)`       | 在容器头部就地构造一个新元素。（C++11）                     |
|              | `pop_front()`                  | 移除容器头部的第一个元素。                                   |
|              | `resize(n)`                    | 改变容器中元素的数量为 `n`。                                 |
|              | `swap(list)`                   | 与另一个同类型列表 `list` 交换数据。                         |
|              | `merge(x)`                     | 合并两个已排序的列表。                                       |
|              | `remove(val)`                  | 移除所有值为 `val` 的元素。                                   |
|              | `remove_if(predicate)`         | 移除满足特定条件的所有元素。                                 |
|              | `reverse()`                    | 反转列表中的元素顺序。                                       |
|              | `sort()`                       | 对列表中的元素进行排序。                                     |
|              | `unique()`                     | 移除连续重复的元素。                                         |
| 元素访问     | `front()`                      | 访问第一个元素。                                             |
|              | `back()`                       | 访问最后一个元素。                                           |
| 迭代器       | `begin()` / `cbegin()`         | 返回指向容器开始的迭代器。                                   |
|              | `end()` / `cend()`             | 返回指向容器结束（最后元素的下一个位置）的迭代器。           |
|              | `rbegin()` / `crbegin()`       | 返回反向迭代器的起始位置。                                   |
|              | `rend()` / `crend()`           | 返回反向迭代器的结束位置。                                   |

**链表Q&A**

* 检查链表是否有环

    快慢指针

* 反转链表

    头插法

* 合并有序链表

    归并

* 寻找倒数第k个节点

    先后节点

* 旋转链表

    多次反转链表

## deque

`deque`是`STL`容器中的双端队列，是支持能够从头增加元素的一种容器，相比于`vector`在插入上来说，会更加灵活。`deque`的内部不是使用单一连续内存块来存储元素的，而是采用一个中央控制器来管理多个固定大小的数组（成为缓冲区或段）。每个缓冲区可能存储多个元素，中央控制器是一个动态数组，包含指向这些缓冲区的指针。这样的设计，能够使得在两端添加或者一处元素时无需移动其他元素。



## array

# 容器适配器

## queue

## stack

## priority_queue

# 关联容器

## set

## map

## mutilset

## mutilmap

# 无序关联容器

## unordered_set

## unordered_map

## unordered_mutilset

## unordered_mutilmap
